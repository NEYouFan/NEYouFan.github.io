<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jenkins-ci容器化在Android项目构建中的应用 | 网易前端技术部</title>
  <meta name="author" content="网易前端技术部">
  
  <meta name="description" content="网易杭研前端技术部，分享最前沿的技术。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Jenkins-ci容器化在Android项目构建中的应用"/>
  <meta property="og:site_name" content="网易前端技术部"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="网易前端技术部" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">网易前端技术部</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-12-26T04:34:04.000Z"><a href="/2016/12/26/NeteaseFed/android/Jenkins-ci容器化在Android项目构建中的应用（公众号版）/">2016-12-26</a></time>
      
      
  
    <h1 class="title">Jenkins-ci容器化在Android项目构建中的应用</h1>
  

    </header>
    <div class="entry">
      
        <p>随着软件开发复杂度的不断提高，如何能在不断变化的需求中快速适应和保证软件的质量显得尤其的重要，<a href="http://baike.baidu.com/view/5253255.htm" target="_blank" rel="external">持续集成</a>正是针对这一类问题的一种软件开发实践。<a id="more"></a></p>
<p>本文中的<code>Jenkins-ci</code>容器化方案能够在项目构建过程中提取出更多自定义的需求信息并进一步将持续集成的环境参数配置标准化。<br>因此，在项目的构建过程中，我们对用户比较关心的信息（如代码质量、<code>apk</code>方法数和大小、资源文件变化、代码提交记录等）进行跟踪、收集、分析和统计，并将结果以图表的形式在通知邮件中展现给用户，让用户对项目的迭代情况有更多的了解。</p>
<h2 id="1-Jenkins配置以及构建通知邮件内容定制"><a href="#1-Jenkins配置以及构建通知邮件内容定制" class="headerlink" title="1 Jenkins配置以及构建通知邮件内容定制"></a>1 Jenkins配置以及构建通知邮件内容定制</h2><h3 id="1-1-Jenkins安装、配置与使用"><a href="#1-1-Jenkins安装、配置与使用" class="headerlink" title="1.1 Jenkins安装、配置与使用"></a>1.1 Jenkins安装、配置与使用</h3><p>关于详细的Jenkins安装、配置与使用说明，可参考文章<a href="http://wangkuiwu.github.io/2015/08/07/jenkins-01/" target="_blank" rel="external">Jenkins工具(一)之 Jenkins集成android工程</a><br>和<a href="http://wangkuiwu.github.io/2015/08/07/jenkins-02/" target="_blank" rel="external">Jenkins工具(二)之 Jenkins集成android工程</a>，文中不再详细叙述。</p>
<p>其中，构建中使用到的插件几个主要插件：</p>
<ul>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin" target="_blank" rel="external">Git plugin</a> Git工具集成</li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin" target="_blank" rel="external">Gitlab Plugin</a>和<a href="https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin" target="_blank" rel="external">Gitlab Hook Plugin</a> 支持Gitlab项目构建</li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Gradle+Plugin" target="_blank" rel="external">Gradle plugin</a> Gradle工具集成</li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+plugin" target="_blank" rel="external">Email Extension Plugin</a> 构建结构邮件通知</li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Git+Changelog+Plugin" target="_blank" rel="external">Git Changelog Plugin</a> 获取Git提交记录</li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Android+Lint+Plugin" target="_blank" rel="external">Android Lint Plugin</a> 收集分析Android Lint检查结果</li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/FindBugs+Plugin" target="_blank" rel="external">FindBugs Plugin</a> 收集分析FindBugs检查结果</li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/HTML+Publisher+Plugin" target="_blank" rel="external">HTML Publisher plugin</a> 支持HTML报告</li>
</ul>
<h3 id="1-2-构建结果邮件定制"><a href="#1-2-构建结果邮件定制" class="headerlink" title="1.2 构建结果邮件定制"></a>1.2 构建结果邮件定制</h3><p>完成<code>Jenkins</code>的安装以及环境参数配置后，新建一个项目用于构建，项目构建完成后需要将结果内容通过邮件的方式通知用户。将构建结果通知到用户的邮件内容的定制，则是本次实践的重点。</p>
<p>本次自动化构建将包括以下几个内容：<code>FireLine</code>（源码检查）、<code>Android Lint</code>、<code>FindBugs</code>（Class文件检查）、<code>Apk</code>包大小和方法数统计、资源文件统计，以及<code>Git commit</code>日志分析。</p>
<h4 id="1-2-1-Email-Extension-配置"><a href="#1-2-1-Email-Extension-配置" class="headerlink" title="1.2.1 Email Extension 配置"></a>1.2.1 Email Extension 配置</h4><p>构建结果邮件内容定制依赖于前面提到的<code>Email Extension Plugin</code>，该插件目前支持<code>Jelly</code>和<code>Groovy</code>两种语法编写模板，本文的模板内容定制将采用<code>Groovy</code>（个人认为<code>Jelly</code>标签不够灵活）。同时，创建的模板文件要放在<code>Jenkins</code>根目录下的<code>email-templates</code>文件夹下。模板文件配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;SCRIPT, template=&quot;ht-ci.template&quot;&#125;</div></pre></td></tr></table></figure>
<p>另外，想要在模板中获取构建结果信息，可以通过获取<code>Jenkins</code>环境中的<code>Action</code>对象来实现。<code>Action</code>是插件用来在<code>Job</code>或<code>Build</code>页面增加功能的一种主要方式，是<code>Jenkins</code>最常用的一个扩展点。如<code>org.jenkinsci.plugins.android_lint.LintResultAction</code>、hudson.plugins.findbugs.FindBugsResultAction等，后文将多次用到。</p>
<h4 id="1-2-2-Android-Lint"><a href="#1-2-2-Android-Lint" class="headerlink" title="1.2.2 Android Lint"></a>1.2.2 Android Lint</h4><p><code>Android Lint</code>是一个静态代码分析工具，它能够对你的<code>Android</code>项目中潜在的<code>bug</code>、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。支持自定义Lint规则，可参考文章<a href="http://carrotsight.com/2016/01/29/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%80%EF%BC%89.html" target="_blank" rel="external">浅谈Android自定义Lint规则的实现 （一）</a>、<a href="http://carrotsight.com/2016/02/01/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89.html" target="_blank" rel="external">浅谈Android自定义Lint规则的实现 （二）</a>。</p>
<p>安装插件<code>Android Lint Plugin</code>后，进入项目的配置页，并添加构建后操作<code>Publish Android Lint results</code>，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在<code>Invoke Gradle Script</code>的<code>Task</code>中添加对应的<code>lint</code>检查任务。</p>
<p>通过阅读<a href="https://github.com/jenkinsci/android-lint-plugin" target="_blank" rel="external"> android-lint-plugin </a>的源码可知，只要获取<a href="https://github.com/jenkinsci/android-lint-plugin/blob/8e88de5c9ec2f2d58bf0965592f6ffed040f0542/src/main/java/org/jenkinsci/plugins/android_lint/LintResultAction.java" target="_blank" rel="external">org.jenkinsci.plugins.android_lint.LintResultAction</a>对应的<code>Action</code>实例，就可以得到<code>lint</code>检查的数据。</p>
<p>最终，邮件中的显示结果如图：</p>
<p><img src="https://nos.netease.com/popo/9da8a7374fe8ba7f4b91e78acb27392e.jpg" alt=""></p>
<p>点击链接地址，会跳转到<code>Lint Issues</code>的包含图文描述的界面，如图：</p>
<p><img src="http://nos.netease.com/knowledge/e8b39b38-131f-4043-9178-3fc8ad4861c1" alt="Lint Issues"> </p>
<p>不过需要注意的是，默认情况下，在<code>Gradle</code>插件<code>com.android.application</code>的<code>android</code>对象中，<code>lintOptions</code>的<code>abortOnError</code>参数为<code>true</code>，在执行<code>lint</code>命令时，遇到错误即中止构建。因此，若希望<code>lint</code>执行出错后继续构建，则需要将该参数置为<code>false</code>，可以在<code>build.gradle</code>文件中动态修改：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">afterEvaluate &#123; project -&gt;</div><div class="line">    <span class="keyword">if</span> (project.properties.containsKey(<span class="string">'android'</span>)) &#123; <span class="comment">//针对android应用和android库项目</span></div><div class="line">        project.android.lintOptions.abortOnError <span class="literal">false</span> <span class="comment">//禁止遇到错误中止构建  </span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="1-2-3-FindBugs"><a href="#1-2-3-FindBugs" class="headerlink" title="1.2.3 FindBugs"></a>1.2.3 FindBugs</h4><p><a href="https://zh.wikipedia.org/wiki/FindBugs" target="_blank" rel="external">Findbugs</a>是一个静态分析工具，用来查找<code>Java</code>代码中的程序错误，将字节码与一组缺陷模式进行对比以发现可能的问题，并根据其可能产生的影响或严重程度，而对开发者的提示。并且，这组缺陷模式是可配置的，通过配置可以过滤掉一些我们不想或不需要检测的问题。</p>
<p><code>FindBugs</code>和<code>Android Lint</code>的集成方式基本一致。在安装插件<code>FindBugs Plugin</code>后，进入项目配置页，并添加构建后操作<code>Publish FindBugs analysis results</code>，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在<code>Invoke Gradle Script</code>的<code>Task</code>中添加对应的<code>findbugs</code>检查任务。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//findbugs插件</span></div><div class="line">apply <span class="string">plugin:</span> <span class="string">'findbugs'</span> </div><div class="line">task findbugs(<span class="string">type:</span> FindBugs, <span class="string">dependsOn:</span> <span class="string">'assembleDebug'</span>) &#123;<span class="comment">//依赖Debug打包所产生的class文件</span></div><div class="line">    ...</div><div class="line">    excludeFilter = file(<span class="string">"$&#123;project.rootDir&#125;/configs/scripts/findbugs-filter.xml"</span>) <span class="comment">//配置过滤文件，减少不必要的检查</span></div><div class="line">    classes = files(<span class="string">"$&#123;project.buildDir&#125;/intermediates/classes/"</span>)<span class="comment">//默认分析的class文件对象</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合<a href="https://github.com/jenkinsci/findbugs-plugin" target="_blank" rel="external">findbugs-plugin</a>的源码可知，只要获取<a href="https://github.com/jenkinsci/findbugs-plugin/blob/master/plugin/src/main/java/hudson/plugins/findbugs/FindBugsResultAction.java" target="_blank" rel="external">hudson.plugins.findbugs.FindBugsResultAction</a>对应的<code>Action</code>实例，就可以得到分析结果。最后，在邮件中的显示结果如图：</p>
<p><img src="https://nos.netease.com/popo/743676cae801faeb937ab0e828fb4476.jpg" alt=""></p>
<p>点击链接地址，同样跳转到<code>FindBugs</code>的图文界面。</p>
<p><img src="https://nos.netease.com/popo/610530e913c4ab0f321321c359ea9f53.jpg" alt=""></p>
<h6 id="动态集成自定义的gradle任务方案"><a href="#动态集成自定义的gradle任务方案" class="headerlink" title="动态集成自定义的gradle任务方案"></a>动态集成自定义的gradle任务方案</h6><p>在项目持续集成时，我们需要添加一些自定义的任务，但是又要尽量避免修改用户的项目代码。因此，本文采用了一个比较折中的方案：<br>在<code>Jenkins</code>的根目录下建一个<code>configs</code>文件夹，放置一些项目构建过程使用的第三方库、脚本以及配置文件等；然后在项目构建之前，通过执行<code>Job</code>配置页的脚本将该文件夹及其内容复制到目标构建项目的工作空间中，同时修改项目的<code>build.gradle</code>文件；最后在项目构建过程中，调用这些第三方库、脚本以及配置文件，来完成自定义的额外的构建任务。</p>
<p><code>FindBugs</code>任务的集成就应用了上述方案，后续介绍的<code>FireLine</code>集成以及<code>Apk</code>大小、方法数和资源文件统计的集成亦是如此。</p>
<p>例如，修改<code>build.gradle</code>文件，动态引入<code>jenkins.gradle</code>文件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">project(<span class="string">':app'</span>) &#123; <span class="comment">//在项目的主moudle（一般默认是app）中引用构建相关的gradle脚本</span></div><div class="line">    apply <span class="string">from:</span> rootProject.getRootDir().getAbsolutePath() + <span class="string">'/configs/scripts/jenkins.gradle'</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-4-FireLine"><a href="#1-2-4-FireLine" class="headerlink" title="1.2.4 FireLine"></a>1.2.4 FireLine</h4><p><a href="http://magic.360.cn/index.html" target="_blank" rel="external">火线</a>（<code>FireLine</code>）提供一种静态代码（指<code>java</code>源码，后来据说又支持<code>class</code>文件）扫描服务，基于<code>PMD</code>开源。它是360公司针对自己的产品定制的安全检查规则，使用这些规则对源代码进行扫描检测，找出代码潜在的安全风险。目前，对外也可以使用。因此，本文对该工具进行了集成。</p>
<p><code>FireLine</code>对外提供一个<code>jar</code>包，必须通过命令行的形式运行，因此需要添加一个<code>fireLine</code>的任务：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//扫描java源码，需指定扫描对象以及结果存储位置</span></div><div class="line">task fireLine &lt;&lt; &#123;</div><div class="line">    <span class="keyword">def</span> fireLineDir=env.JENKINS_HOME+<span class="string">"/jobs/"</span>+env.JOB_NAME+<span class="string">"/builds/"</span>+env.BUILD_NUMBER+<span class="string">"/"</span></div><div class="line">    exec &#123;</div><div class="line">        workingDir <span class="string">'./'</span></div><div class="line">        <span class="comment">//命令行执行jar包</span></div><div class="line">        commandLine <span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"$&#123;project.rootDir&#125;/configs/jars/fireline.jar"</span>, <span class="string">"scanSrcDir="</span>+env.WORKSPACE, <span class="string">"reportSaveDir="</span>+fireLineDir,<span class="string">"reportFileName=fireLineResult"</span>,<span class="string">"user=netease"</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构建后，检查结果在邮件中显示如图：</p>
<p><img src="https://nos.netease.com/popo/70d4c25e2675849aa5b760c258ad655e.jpg" alt=""></p>
<p>点击链接地址，跳转到需要<code>HTML Publisher Plugin</code>支持的火线检查的详细界面：</p>
<p><img src="https://nos.netease.com/popo/8ad710117b1e3f862f24d23b783fde84.jpg" alt=""></p>
<p>注意，若<code>FireLine</code>报告不能正常显示，这是由于它使用了<code>JavaScript</code>，这里需要设置<code>jenkins</code>允许脚本执行（<code>allow-scripts</code>），需要在系统设置页的<code>Jenkins Script Console</code>选项中输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;) </div><div class="line">``` </div><div class="line"></div><div class="line">并执行，从而修改`Jenkins`的默认配置参数，然后重新构建项目即可，详细问题可参考`stackoverflow`上的回答[the &apos;allow-scripts&apos; permission is not set](http://stackoverflow.com/questions/34315723/blocked-script-execution-in-url-because-the-documents-frame-is-sandboxed-and)。</div><div class="line"></div><div class="line">#### 1.2.5 Apk方法数、大小以及资源文件分析</div><div class="line">随着项目的不断迭代更新，`android`应用不得不面对`64k`方法数限制、`Apk`体积不断变大的问题。因此，本次实践中将对该类数据进行收集分析，更加直观的展现给关注该类信息的用户。</div><div class="line">######  Apk方法数、大小统计</div><div class="line">在`Apk`方法数统计集成中，采用了开源的`Gradle`插件项目-[dexcount-gradle-plugin](https://github.com/KeepSafe/dexcount-gradle-plugin)，该插件会根据配置为打包的每个`Apk`文件生成一份方法数统计的文件。</div><div class="line"></div><div class="line">```groovy</div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral() // or jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.6.1&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// make sure this line comes *after* you apply the Android plugin</div><div class="line">apply plugin: &apos;com.getkeepsafe.dexcount&apos;</div></pre></td></tr></table></figure>
<p>配置完成后，执行<code>assemble</code>任务时，会在<code>app/build/outputs</code>目录下生成<code>apk</code>方法数统计数据文件：</p>
<p><img src="https://nos.netease.com/popo/c139efda8d19abae9869aadc6fdb044b.jpg" alt=""></p>
<p>因此，在本次<code>jenkins-ci</code>实践中，我们需要做就是在构建项目中动态添加该插件，并将该插件生成的统计数据进行收集、转换。</p>
<p>和集成<code>findbugs</code>插件不同的是，这里还需要动态修改<code>app</code>项目的<code>buildscript</code>对象，并保证该插件是在<code>com.android.application</code>之后被应用。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//动态修改`app`项目的`buildscript`对象</span></div><div class="line">project(<span class="string">':app'</span>) &#123;</div><div class="line">    apply <span class="string">from:</span> rootProject.getRootDir().getAbsolutePath() + <span class="string">'/configs/scripts/buildscript.gradle'</span>, <span class="string">to:</span> buildscript</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并通过调用<code>gradle</code>中的<code>PluginManager</code>对象的<code>void withPlugin(String id, Action&lt;? super AppliedPlugin&gt; action)</code>方法，来监听插件的添加事件。当<code>com.android.application</code>插件被添加时，就可以动态添加<code>dexcount-gradle-plugin</code>插件。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pluginManager.withPlugin(<span class="string">"com.android.application"</span>, <span class="keyword">new</span> Action&lt;AppliedPlugin&gt;() &#123;</div><div class="line">    <span class="keyword">void</span> execute(AppliedPlugin appliedPlugin) &#123;</div><div class="line">        project(<span class="string">':app'</span>) &#123; <span class="comment">//主module名称</span></div><div class="line">            apply <span class="string">plugin:</span> <span class="string">'com.getkeepsafe.dexcount'</span> <span class="comment">//引入apk方法数统计插件</span></div><div class="line">            apply <span class="string">plugin:</span> <span class="string">"com.netease.hearttouch.resourcesize"</span> <span class="comment">//引入资源文件统计插件</span></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>最后，为了在<code>jenkins</code>中使用该数据，创建一个<code>apkMethodCounts</code>任务将上述的所有的<code>json</code>格式文件进行统一解析转换，并将解析结果和生成的<code>Apk</code>文件–对应起来。构建结果如图：</p>
<p><img src="https://nos.netease.com/popo/ab6fd8a20b0836902c48f3d02ddec216.jpg" alt=""></p>
<h6 id="资源文件大小统计"><a href="#资源文件大小统计" class="headerlink" title="资源文件大小统计"></a>资源文件大小统计</h6><p>资源文件统计插件<a href="https://g.hz.netease.com/hearttouch-android/resource_size_plugin" target="_blank" rel="external">resource-size-plugin</a>与<code>dexcount-gradle-plugin</code>的使用方法基本一致，该插件也是需要通过动态添加。</p>
<p>插件配置完成后，执行<code>resourcesize</code>任务，会在<code>app/build/outputs</code>目录下生成分析结果<code>resoucesize.txt</code>。其中，第一行表示所有资源文件的总大小，后面每行代表单个文件最大的文件名称以及文件大小：</p>
<p><img src="https://nos.netease.com/popo/d900de430614c344379c01aad3af8c98.jpg?imageView&amp;thumbnail=500x300" alt=""></p>
<p>最后，将数据进行简单处理，在<code>jenkins</code>的构建结果中显示如图：</p>
<p><img src="https://nos.netease.com/popo/5571e696f32a9e23bf86ce558ab0d22a.jpg?imageView&amp;thumbnail=0x400" alt=""></p>
<h4 id="1-2-6-Git-Changelog分析"><a href="#1-2-6-Git-Changelog分析" class="headerlink" title="1.2.6 Git Changelog分析"></a>1.2.6 Git Changelog分析</h4><p>随着项目的迭代，代码的提交越来越频繁，代码的管理显得越来越重要。而<code>commit message</code>是开发者是对自己所提交代码的唯一说明，它能够直接反映开发者的意图，并方便快速查询和浏览，是必不可少的。在这些<code>commit message</code>中，比较重要的主要有<code>feature</code>（新功能）和<code>bug fix</code>（问题修复）两种类型，也是一个产品的关注点。</p>
<p>因此，为了在构建中提取该类信息，在参考网上的一些<code>Git</code>规范的基础上，整理出一份<a href="https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md" target="_blank" rel="external">Git提交规范</a>，规定了完整的<code>git</code>提交日志由信息头部、信息主体和信息尾部构成，其中信息头部需要包含类型、范围和主题三类信息。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>):<span class="tag">&lt;<span class="name">subject</span>&gt;</span></div><div class="line"> 空行</div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"> 空行</div><div class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></div></pre></td></tr></table></figure>
<p>详细规范描述可参考<a href="https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md" target="_blank" rel="external">规范文档</a>。另外，<a href="https://github.com/commitizen/cz-cli" target="_blank" rel="external">Commitizen</a>是一个撰写合格<code>Commit message</code>的工具，很好用，推荐～。使用该工提交代码之后，会自动生成上述格式规范的日志信息。</p>
<p>通过<code>Commitizen</code>工具（或者手动）提交之后，在<code>GitLab</code>上生成的<code>Commit message</code>如图：</p>
<p><img src="https://nos.netease.com/popo/1de9a4ecf80b34eefcbfcaed7d8f271e.jpg" alt=""></p>
<p>从图中的示例可以看出，两个<code>Commit message</code>的类型是<code>feature</code>和<code>bug fix</code>的，因此<code>Jenkins</code>构建的过程中需要进行处理并显示给用户。<br>￼<br><img src="https://nos.netease.com/popo/f4d85368b1fdf419de676e7dec91aac4.jpg" alt=""></p>
<p>另外，为了能够解析<code>bug fix</code>类型提交中的<code>jira</code>上的问题并生成跳转链接，需要在项目根目录下添加一个<code>jenkins.xml</code>文件，示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">jenkins</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">jira</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.netease.com/projects/MINIFIVE/issues/MINIFIVE-#<span class="tag">&lt;/<span class="name">url</span>&gt;</span> <span class="comment">&lt;!--#作为占位符--&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">jira</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">jenkins</span>&gt;</span></div></pre></td></tr></table></figure>
<p>综上，关于自定义<code>Jenkins-ci</code>构建通知邮件内容的部分已经介绍完了，下面我们要讲一下<code>Jenkins</code>与<code>Docker</code>结合如何实现快速配置。</p>
<h2 id="2-Jenkins与Docker结合实现快速配置"><a href="#2-Jenkins与Docker结合实现快速配置" class="headerlink" title="2 Jenkins与Docker结合实现快速配置"></a>2 Jenkins与Docker结合实现快速配置</h2><p><a href="https://www.docker.com/" target="_blank" rel="external">Docker</a>是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的<code>Linux</code>机器上，也可以实现虚拟化。基于<code>Docker</code>轻量级、可移植的特点，本次实践将<code>Jenkins-ci</code>的构建环境配置打包到<code>Docker</code>中，从而实现快速配置。</p>
<h3 id="2-1-Dockerfile文件配置"><a href="#2-1-Dockerfile文件配置" class="headerlink" title="2.1 Dockerfile文件配置"></a>2.1 Dockerfile文件配置</h3><p>创建一个自定义的<code>docker</code>镜像，可以通过<code>Dockerfile</code>描述文件来自动完成。<code>Dockerfile</code>文件包含了创建镜像所需要的<a href="http://seanlook.com/2014/11/17/dockerfile-introduction/" target="_blank" rel="external">全部指令</a>，可以使用<code>Docker build</code>命令来创建镜像。</p>
<p>本文中使用的<code>Dockerfile</code>是基于<code>jenkinsci</code>开源的<a href="https://github.com/jenkinsci/docker" target="_blank" rel="external">jenkins</a>镜像，并根据需求进行了定制，部分内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">FROM jenkins:latest  //已配好java和git环境</div><div class="line">...</div><div class="line"># Same as &quot;export TERM=dumb&quot;; prevents error &quot;Could not open terminal for stdout: $TERM not set&quot;</div><div class="line">ENV TERM dumb</div><div class="line"></div><div class="line">#support 32 bit binary on a 64 bit system</div><div class="line">RUN  apt-get update &amp;&amp; apt-get install -y lib32z1 lib32stdc++6 wget &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</div><div class="line"></div><div class="line"># 下载Android Sdk</div><div class="line">...</div><div class="line">RUN cd /opt &amp;&amp; \</div><div class="line">    wget $&#123;ANDROID_SDK_URL&#125; &amp;&amp; \</div><div class="line">    tar -xzf $&#123;ANDROID_SDK_FILENAME&#125; &amp;&amp; \</div><div class="line">    rm $&#123;ANDROID_SDK_FILENAME&#125; &amp;&amp;\</div><div class="line">    echo y | android update sdk --no-ui --all --filter tools,platform-tools,extra-android-m2repository,android-23,build-tools-23.0.0,build-tools-23.0.1,build-tools-23.0.2,build-tools-23.0.3</div><div class="line">...</div><div class="line"></div><div class="line"># 拷贝JENKINS_HOME文件夹的内容至$JENKINS_HOME目录下，该文件夹与Dockerfile在同一目录，包含了jenkins ci的全部配置信</div><div class="line">ADD JENKINS_HOME $JENKINS_HOME</div><div class="line"></div><div class="line">EXPOSE 8080</div></pre></td></tr></table></figure>
<p>在配置文件中，我们使用<code>wget</code>命令去官方下载最新的<code>linux</code>下<code>android SDK</code>包，并配置环境，然后使用<code>android</code>命令选择和自己项目匹配的<code>SDK</code>以及工具的版本（本次打包的镜像下载了<code>android-23</code>以及系列的编译工具，用户可根据需求自行修改）。</p>
<h3 id="2-2-使用Dockerfile文件构建镜像"><a href="#2-2-使用Dockerfile文件构建镜像" class="headerlink" title="2.2 使用Dockerfile文件构建镜像"></a>2.2 使用Dockerfile文件构建镜像</h3><p>由于<code>Docker</code>是基于<code>Linux</code>，在<code>Mac OS</code>上运行起来需要一个虚拟的<code>Linux</code>环境，它还需要若干工具支持:</p>
<ul>
<li>VirtualBox：虚拟机，用来运行<code>Linux</code></li>
<li>docker-machine：用来管理虚拟机</li>
<li>docker：<code>Docker</code>本身</li>
<li>docker-compose(Mac OS only)：用来管理多个<code>docker</code>容器</li>
<li>Kitematic：用来管理远程<code>Docker Hub</code></li>
</ul>
<p>上述工具安装完毕后（推荐使用<a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a>），就可以创建虚拟机，配置<code>docker</code>环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver virtualbox dev   //1、创建虚拟机</div><div class="line"></div><div class="line">docker-machine env dev    //2、查看dev信息</div><div class="line"></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env dev)</span>"</span>   //3、添加到环境变量，关联当前shell</div></pre></td></tr></table></figure>
<p>然后，进入到<code>Dockerfile</code>所在的目录，就可以执行<code>build</code>命令打包镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker build -t [docker-image-name\id] .</div><div class="line">``` </div><div class="line">目前，该镜像已经上传到[网易蜂巢](https://c.163.com/)，可通过一下命令获取：</div><div class="line"></div><div class="line">```bash</div><div class="line">docker pull hub.c.163.com/netease163/ht-jenkinsci:latest</div></pre></td></tr></table></figure>
<p>更多内容可参考<a href="https://c.163.com/wiki/index.php?title=%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F" target="_blank" rel="external">网易蜂巢使用指南</a>。<br>综上，本次<code>Jenkins-ci</code>容器化实践就讲完了～有问题或建议可以联系我，一起交流～</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://jenkins.io/" target="_blank" rel="external">jenkins官网</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Plugins" target="_blank" rel="external">jenkins插件</a></li>
<li><a href="http://wangkuiwu.github.io/2015/08/07/jenkins-02/" target="_blank" rel="external">Jenkins集成android工程</a></li>
<li><a href="https://github.com/jenkinsci/jenkins" target="_blank" rel="external">jenkins-ci</a></li>
<li><a href="http://javadoc.jenkins-ci.org/overview-summary.html" target="_blank" rel="external">jenkins的Api文档</a></li>
<li><a href="http://itfish.net/article/53357.html" target="_blank" rel="external">Jenkins构建Android项目持续集成之findbugs的使用
</a></li>
<li><a href="https://github.com/KeepSafe/dexcount-gradle-plugin" target="_blank" rel="external">dexcount-gradle-plugin</a></li>
<li><a href="http://magic.360.cn/index.html" target="_blank" rel="external">FireLine</a></li>
<li><a href="https://github.com/jenkinsci/email-ext-plugin" target="_blank" rel="external">email-ext-plugin</a></li>
<li><a href="https://github.com/jenkinsci/findbugs-plugin" target="_blank" rel="external">findbugs-plugin</a></li>
<li><a href="https://segmentfault.com/a/1190000004881029" target="_blank" rel="external">Android中使用FindBugs</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="external">Commit message和Change log编写指南</a></li>
<li><a href="https://github.com/paulwellnerbou/git-changelog-jenkins-plugin" target="_blank" rel="external">git-changelog-plugin</a></li>
<li><a href="http://qa.blog.163.com/blog/static/19014700220131011102715643/" target="_blank" rel="external">持续集成之Jenkins插件使用-邮件通知模板化</a></li>
<li><a href="http://www.qisanfen.com/?p=474" target="_blank" rel="external">搭建linux（ubuntu 14.04）下的android开发环境</a></li>
<li><a href="http://qianngchn.github.io/wiki/8.html" target="_blank" rel="external">Ubuntu下全命令行搭建Android开发环境</a></li>
<li><a href="http://www.jianshu.com/p/13c132503d01" target="_blank" rel="external">Run Docker on your Mac</a></li>
<li><a href="http://developerworks.github.io/2014/09/07/android-ci-server/#%E5%AE%89%E8%A3%85Android_SDK" target="_blank" rel="external">搭建Android持续集成服务器</a></li>
<li><a href="http://blog.saymagic.cn/2016/01/25/docker-image-for-android.html" target="_blank" rel="external">构建编译Android项目的Docker镜像</a></li>
<li><a href="http://www.larrycaiyu.com/2014/11/04/use-docker-for-your-jenkins-demo-1.html" target="_blank" rel="external">使用docker来提升你的Jenkins</a></li>
<li><a href="http://ju.outofmemory.cn/entry/145390" target="_blank" rel="external">Setup Jenkins for Android Integration Using Docker</a></li>
<li><a href="http://blog.csdn.net/sbsujjbcy/article/details/52215051" target="_blank" rel="external">Mac OSX Docker下搭建Android+Jenkins+Gitlab</a></li>
<li><a href="http://www.cnphp6.com/archives/115564" target="_blank" rel="external">gitlab与jenkins协同工作</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/android/">android</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://hellojql.github.io/2016/12/26/NeteaseFed/android/Jenkins-ci容器化在Android项目构建中的应用（公众号版）/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <SCRIPT language=javascript>
function search(formname) {
    formname.method = "get";
    formname.action = "http://www.baidu.com/baidu";
    document.search_form.word.value = document.search_form.word.value + " site:hellojql.github.io”;
    return true;
}
</SCRIPT>

<div class="search">
    <form name="search_form" target="_blank" onsubmit="search(this)">
        <input type="search" name="word" results="0" placeholder="" onblur="this.value=''">
        <!-- <input type="submit" value="搜索"> -->
    </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/android/">android</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 网易前端技术部
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android平台上的JavaScript引擎 | 网易前端技术部</title>
  <meta name="author" content="网易前端技术部">
  
  <meta name="description" content="网易杭研前端技术部，分享最前沿的技术。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Android平台上的JavaScript引擎"/>
  <meta property="og:site_name" content="网易前端技术部"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="网易前端技术部" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">网易前端技术部</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-12-26T04:34:04.000Z"><a href="/2016/12/26/NeteaseFed/android/Android JS引擎/">2016-12-26</a></time>
      
      
  
    <h1 class="title">Android平台上的JavaScript引擎</h1>
  

    </header>
    <div class="entry">
      
        <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>近期在产品中遇到了这样的一个问题：Web端已经存在一个功能完善的JavaScript库，如果将相关Web嵌入到App中，则WebView将带来一定的性能影响；如果Android端本地开发一个相同的库，则需要消耗大量的资源。考虑到代码复用和跨平台开发，团队调研了JS引擎在Android上的使用，希望解决”不经过WebView，而将JS库拿到Android端运行，并将运行结果交给本地输出”这一需求。<a id="more"></a></p>
<p>JS引擎能够解析JS脚本，通常被依附于浏览器中，例如Safari所使用的<strong>JavaScriptCore</strong>、Google Chrome所使用的<strong>V8</strong>和FireFox所使用的<strong>SpiderMonkey</strong>等等。也被用作移动端的跨平台开发，例如NativeScript(<a href="http://developer.telerik.com/featured/nativescript-works/)在iOS端和Android分别使用了JavaScriptCore和V8，ReactNative(https://facebook.github.io/react-native/docs/javascript-environment.html)则都使用了JavaScriptCore。" target="_blank" rel="external">http://developer.telerik.com/featured/nativescript-works/)在iOS端和Android分别使用了JavaScriptCore和V8，ReactNative(https://facebook.github.io/react-native/docs/javascript-environment.html)则都使用了JavaScriptCore。</a></p>
<h3 id="二、JS引擎介绍"><a href="#二、JS引擎介绍" class="headerlink" title="二、JS引擎介绍"></a>二、JS引擎介绍</h3><p>在Android系统中能运行的JS引擎有如下5种：</p>
<h4 id="1-JavaScriptCore-https-trac-webkit-org-wiki-JavaScriptCore"><a href="#1-JavaScriptCore-https-trac-webkit-org-wiki-JavaScriptCore" class="headerlink" title="1. JavaScriptCore(https://trac.webkit.org/wiki/JavaScriptCore)"></a>1. JavaScriptCore(<a href="https://trac.webkit.org/wiki/JavaScriptCore" target="_blank" rel="external">https://trac.webkit.org/wiki/JavaScriptCore</a>)</h4><p>JavaScriptCore是一个在WebKit中提供JS引擎的开源框架，最近更新日期是2016年9月26日。目前该引擎由Apple维护，使用于Safari浏览器，iOS7后也集成到了iPhone平台。</p>
<p>由于其使用C语言编写，因此在Android开发中并不能直接使用。Github上的开源项目<strong>AndroidJSCore</strong>(<a href="https://github.com/ericwlange/AndroidJSCore)能够帮助开发者经过调用Java接口而使用JavaScriptCore。该项目由**ericwlange**维护，最新版本3.0.1发布于2016年7月31日，有API文档和示例代码，但缺少相关技术文章，并仍存在一些性能问题。" target="_blank" rel="external">https://github.com/ericwlange/AndroidJSCore)能够帮助开发者经过调用Java接口而使用JavaScriptCore。该项目由**ericwlange**维护，最新版本3.0.1发布于2016年7月31日，有API文档和示例代码，但缺少相关技术文章，并仍存在一些性能问题。</a></p>
<h4 id="2-V8-https-developers-google-com-v8"><a href="#2-V8-https-developers-google-com-v8" class="headerlink" title="2. V8(https://developers.google.com/v8/)"></a>2. V8(<a href="https://developers.google.com/v8/" target="_blank" rel="external">https://developers.google.com/v8/</a>)</h4><p>V8是由Google开发并维护的高性能开源JS引擎，采用C++编写，使用于Google Chrome浏览器。最新版本为V8 5.5 beta，更新于2016年10月24日。</p>
<p>同JavaScriptCore一样，在Android开发中，相关接口需要通过一层包装进行调用。Github上的开源项目<strong>J2V8</strong>(<a href="https://github.com/eclipsesource/J2V8)，相关文章可在此处(http://eclipsesource.com/blogs/tag/j2v8/)查阅，最新版本4.6.0发布于2016年9月22日。" target="_blank" rel="external">https://github.com/eclipsesource/J2V8)，相关文章可在此处(http://eclipsesource.com/blogs/tag/j2v8/)查阅，最新版本4.6.0发布于2016年9月22日。</a></p>
<p>J2V8是一套针对V8的Java绑定。J2V8的开发为Android平台带来了高效的Javascript的执行环境，其以性能与内存消耗为设计目标。它采用了“基本类型优先”原则，意味着一个执行结果是基本类型，那么所返回的值也就是该基本类型。它还采用了“懒加载”技术，只有当JS执行结果被访问时，才会通过JNI复制到Java中。</p>
<p>此外J2V8提供了<code>release()</code>方法，开发者在某一对象不再需要时主动调用该方法去释放本地对象句柄，释放规则如下：</p>
<ul>
<li>如果是由代码创建的对象，那么必须释放它；如果一个对象是通过返回语句传回来的话，系统会替你释放它；</li>
<li>如果是由系统创建的对象，则无需担心释放，而如果对象是JS方法的返回值，就必须手动的释放它。</li>
</ul>
<h4 id="3-SpiderMonkey-https-developer-mozilla-org-en-US-docs-Mozilla-Projects-SpiderMonkey"><a href="#3-SpiderMonkey-https-developer-mozilla-org-en-US-docs-Mozilla-Projects-SpiderMonkey" class="headerlink" title="3. SpiderMonkey(https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey)"></a>3. SpiderMonkey(<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey</a>)</h4><p>开源JS引擎SpiderMonkey最初由Netscape开发，如今由Mozilla开发并维护，且被广泛用于Mozilla产品（如FireFox）。最新版本为SpiderMonkey 45，更新于2016年4月14日。</p>
<p>SpiderMonkey提供了一些核心的JavaScript数据类型，如数字，字符串，数组，对象等等，以及一些方法如Array.push。它还使得每个应用程序都容易将其自己的对象和方法暴露给JavaScript代码。应用开发者可以决定应用如何将与所写脚本相关的对象暴露出来。</p>
<h4 id="4-Rhino-https-developer-mozilla-org-en-US-docs-Mozilla-Projects-Rhino"><a href="#4-Rhino-https-developer-mozilla-org-en-US-docs-Mozilla-Projects-Rhino" class="headerlink" title="4. Rhino(https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino)"></a>4. Rhino(<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino</a>)</h4><p>Rhino是由Mozilla开发的开源JS引擎。采用Java编写，因此可以直接调用，在JDK 6、JDK 7中更是捆绑了该引擎。最新版本为Rhino 1.7.7.1，更新于2016年2月1日。</p>
<p>其提供的特性包括：</p>
<ul>
<li>JavaScript 1.7的全部特性</li>
<li>可以用脚本方式调用Java</li>
<li>用一个JavaScript Shell来执行JavaScript脚本</li>
<li>用一个JavaScript编译器来将JavaScript脚本文件转换成Java类文件</li>
<li>用一个JavaScript调试器来调试Rhino执行的脚本</li>
</ul>
<h4 id="5-Nashorn-http-openjdk-java-net-projects-nashorn"><a href="#5-Nashorn-http-openjdk-java-net-projects-nashorn" class="headerlink" title="5. Nashorn(http://openjdk.java.net/projects/nashorn/)"></a>5. Nashorn(<a href="http://openjdk.java.net/projects/nashorn/" target="_blank" rel="external">http://openjdk.java.net/projects/nashorn/</a>)</h4><p>Nashorn由Oracle开发并维护，从JDK 8开始，Rhino被Nashorn代替，成为JDK默认JS引擎。Nashorn同JDK 8一同发布和开源，较Rhino而言性能更好，但不支持Android Dalvik虚拟机。</p>
<h3 id="三、JS引擎性能比较"><a href="#三、JS引擎性能比较" class="headerlink" title="三、JS引擎性能比较"></a>三、JS引擎性能比较</h3><p>从可用性方面考虑，选取了JavaScriptCore+AndroidJSCore（下文由“JSCore”指代）、V8+J2V8（下文由“J2V8”指代）和Rhino三种方案进行实验。</p>
<h4 id="创建JS环境"><a href="#创建JS环境" class="headerlink" title="创建JS环境"></a>创建JS环境</h4><p>部分引擎并不支持直接运行文件，因此将JS代码作为字符串交给JS引擎执行，执行过程中可以调用已注册到JS上下文的Java方法。</p>
<h5 id="JSCore"><a href="#JSCore" class="headerlink" title="JSCore"></a>JSCore</h5><pre><code>//创建JS上下文
JSContext context = new JSContext();
//创建Java方法
JSFunction func = new JSFunction(context, &quot;func&quot;) {
    public void func(String msg) {
        //相关处理
    }
};
//将Java方法注册到JS上下文
context.property(&quot;func&quot;, func);
//执行JS
context.evaluateScript(/*JS代码*/);
</code></pre><h5 id="J2V8"><a href="#J2V8" class="headerlink" title="J2V8"></a>J2V8</h5><pre><code>//创建JS上下文
V8 context = V8.createV8Runtime();
//创建Java方法，并注册到JS上下文
context.registerJavaMethod(new JavaVoidCallback() {
    public void invoke(final V8Object receiver, final V8Array parameters) {
        //相关处理
    }
}, &quot;func&quot;);
//执行JS
context.executeScript(js);
//释放资源
context.release();
</code></pre><h5 id="Rhino"><a href="#Rhino" class="headerlink" title="Rhino"></a>Rhino</h5><pre><code>class Func {
    void func(String msg) {
        //相关处理
    }
}

//创建JS上下文
Context context = Context.enter();
context.setOptimizationLevel(-1);
Scriptable scope = context.initStandardObjects();
try {
    //执行JS
    context.evaluateString(scope, js, &quot;RhinoUtil&quot;, 1, null);

    //将Java方法封装到类中，并作为参数传递给JS方法
    Function function = (Function) scope.get(&quot;rhinofunc&quot;, scope);
    function.call(context, scope, scope, new Object[]{new Func()});
} finally {
    Context.exit();
}
</code></pre><h4 id="实验〇：包的依赖"><a href="#实验〇：包的依赖" class="headerlink" title="实验〇：包的依赖"></a>实验〇：包的依赖</h4><p>比较各方案依赖包引入后，apk的体积增量：</p>
<table>
<thead>
<tr>
<th></th>
<th>依赖包占用(MB)</th>
<th>依赖方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>J2V8</td>
<td>8.2</td>
<td>compile ‘com.eclipsesource.j2v8:j2v8:4.6.0@aar’</td>
</tr>
<tr>
<td>JSCore</td>
<td>44.9😳</td>
<td>compile ‘com.github.ericwlange:AndroidJSCore:3.0.1’</td>
</tr>
<tr>
<td>Rhino</td>
<td>0.6</td>
<td>将jar包放入libs文件夹下</td>
</tr>
</tbody>
</table>
<ul>
<li>J2V8引入的是全平台包，实际上它有针对Linux、Windows、MacOS、Android各平台进行打包，而Android平台最新版本为3.0.5（约4MB），并不是最新的4.6.0版本</li>
<li>具AndroidJsCore作者回答，由于必须针对各CPU架构进行打包，而有7种CPU架构，每种架构包约6MB，因此整个依赖包体积相比之下显得庞大，但也可以通过ABIs Splits进行拆分。</li>
<li>Rhino的jar包仅1.2M，因此apk增量并不显著。</li>
</ul>
<h4 id="实验一：空循环"><a href="#实验一：空循环" class="headerlink" title="实验一：空循环"></a>实验一：空循环</h4><p>JSCore和J2V8执行JS代码如下：</p>
<pre><code>var i = 0;
for (;i &lt; /*次数*/; i++) {
}
</code></pre><p>Rhino执行JS代码如下：</p>
<pre><code>function rhinofunc(f) {
    var i = 0;
    for (;i &lt; /*次数*/; i++) {
    }
}
</code></pre><p>循环次数分别设置为100万、1000万、1亿次，在Java代码中执行JS前输出开始时间，在JS执行后输出结束时间，相减得出执行时间记录如下：</p>
<table>
<thead>
<tr>
<th>执行时间(ms)</th>
<th>100万次</th>
<th>1000万次</th>
<th>1亿次</th>
</tr>
</thead>
<tbody>
<tr>
<td>J2V8</td>
<td>17.6</td>
<td>122.8</td>
<td>1116.6</td>
</tr>
<tr>
<td>JSCore</td>
<td>22</td>
<td>173.2</td>
<td>1551</td>
</tr>
<tr>
<td>Rhino</td>
<td>2078.4</td>
<td>22358.4</td>
<td>198600😳</td>
</tr>
</tbody>
</table>
<p>由实验结果可以看到：J2V8和JSCore相比，J2V8执行时间更短，但两者时间都在同一数量级上。而Rhino执行时间远大于前两者，根本原因在于Java程序运行较C/C++慢。</p>
<h4 id="实验二：JS调用Java方法"><a href="#实验二：JS调用Java方法" class="headerlink" title="实验二：JS调用Java方法"></a>实验二：JS调用Java方法</h4><p>JSCore和J2V8执行JS代码如下：</p>
<pre><code>var i = 0;
for (;i &lt; /*次数*/; i++) {
    func();
}
</code></pre><p>Rhino执行JS代码如下：</p>
<pre><code>function rhinofunc(f) {
    var i = 0;
    for (;i &lt; /*次数*/; i++) {
        f.func();
    }
}
</code></pre><p>调用次数分别设置为1万、10万、100万次，记录执行时间如下：</p>
<table>
<thead>
<tr>
<th>执行时间(ms)</th>
<th>1万次</th>
<th>10万次</th>
<th>100万次</th>
</tr>
</thead>
<tbody>
<tr>
<td>J2V8</td>
<td>490.2</td>
<td>4855.8</td>
<td>47527</td>
</tr>
<tr>
<td>JSCore</td>
<td>1287.6</td>
<td>13448.2</td>
<td>121586.8😳</td>
</tr>
<tr>
<td>Rhino</td>
<td>408.2</td>
<td>4007.2</td>
<td>36752.4</td>
</tr>
</tbody>
</table>
<p>启动App时记录占用内存，JS执行过程中记录最高占用内存，相减得出占用内存。</p>
<table>
<thead>
<tr>
<th>占用内存(KB)</th>
<th>1万次</th>
<th>10万次</th>
<th>100万次</th>
</tr>
</thead>
<tbody>
<tr>
<td>J2V8</td>
<td>7264</td>
<td>14004</td>
<td>17328</td>
</tr>
<tr>
<td>JSCore</td>
<td>15368</td>
<td>15140</td>
<td>16720</td>
</tr>
<tr>
<td>Rhino</td>
<td>2776</td>
<td>9084</td>
<td>9116</td>
</tr>
</tbody>
</table>
<p>同样也是由于开发语言的差异，在JS调用Java上Rhino性能更优。执行时间方面，J2V8接近Rhino，而JSCore则远落后于前两种方案，这可能与其Java绑定层有很大关系。对于J2V8和JSCore则需要先经过JNI包装层才能调用到Java方法，而大量的JNI调用是非常耗时、耗内存的。</p>
<h4 id="实验三：JS递归计算斐波那契"><a href="#实验三：JS递归计算斐波那契" class="headerlink" title="实验三：JS递归计算斐波那契"></a>实验三：JS递归计算斐波那契</h4><p>JS代码斐波那契函数如下：</p>
<pre><code>function fibo(n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    else {
        return fibo(n - 1) + fibo(n - 2);
    }
}
</code></pre><table>
<thead>
<tr>
<th>执行时间(ms)</th>
<th>fibo(20)</th>
<th>fibo(30)</th>
<th>fibo(40)</th>
</tr>
</thead>
<tbody>
<tr>
<td>J2V8</td>
<td>4</td>
<td>67.6</td>
<td>8158.6</td>
</tr>
<tr>
<td>JSCore</td>
<td>6.6</td>
<td>76.2</td>
<td>7884.4</td>
</tr>
<tr>
<td>Rhino</td>
<td>248.4</td>
<td>26898</td>
<td>???😳</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>占用内存(KB)</th>
<th>fibo(20)</th>
<th>fibo(30)</th>
<th>fibo(40)</th>
</tr>
</thead>
<tbody>
<tr>
<td>J2V8</td>
<td>6148</td>
<td>6120</td>
<td>17328</td>
</tr>
<tr>
<td>JSCore</td>
<td>6204</td>
<td>6200</td>
<td>16720</td>
</tr>
<tr>
<td>Rhino</td>
<td>5284</td>
<td>9052</td>
<td>9116</td>
</tr>
</tbody>
</table>
<p>Rhino运行JS时频繁GC，虽然使其所占内存较少，但执行速度非常缓慢，相比之下J2V8和JSCore方案效率更高。</p>
<h4 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h4><p>单从JS引擎来说：Rhino执行不需要通过JNI且占用更少的内存，但执行效率很低；V8和JavaScriptCore等C语言开发的引擎远胜于Rhino等Java开发的引擎，但需要一层Java包装层，并存在JNI调用性能问题。就J2V8和AndroidJSCore两个包装层而言：J2V8的可用性、可靠性、健壮性更优；AndroidJSCore还存在着不少的性能问题，在上述实验中出现较少，但实际开发中还存在很多坑。</p>
<p>以上三种实现方案中更推荐J2V8方案。对于内存问题，J2V8的内存释放机制较为完善，在实际开发中可以通过主动release来释放内存；对于JNI调用性能问题，J2V8团队也在尝试通过批处理回调来进行优化，在将来的版本中会得到改善。</p>
<h3 id="四、J2V8的Android开发实例"><a href="#四、J2V8的Android开发实例" class="headerlink" title="四、J2V8的Android开发实例"></a>四、J2V8的Android开发实例</h3><p>有以下一段JS代码，其中Canvas绘制了一些简单的图形：</p>
<pre><code>var c=document.getElementById(&quot;myCanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);

ctx.beginPath();
ctx.arc(100, 100, 25, 0, 360, false);
ctx.moveTo(20,20);
ctx.lineTo(20,100);
ctx.lineTo(70,100);
ctx.moveTo(100, 100);
ctx.setLineWidth(15);
ctx.setStrokeColor(&quot;#188ffc&quot;);
ctx.stroke();

ctx.setFillColor(&quot;#188ffc&quot;);
ctx.fillText(&quot;Hello World!&quot;,150,50);
</code></pre><p>其在Web端绘制效果如下：</p>
<p><img src="web_shape.png" alt="HelloWorld"></p>
<p>实例中，借助J2V8在Android端运行同样一段脚本，使图形绘制到Android Canvas中。下面给出简单实现，主要思路为自定义View，JS中将要绘制的图形先存储到在List中，待整个JS脚本执行完毕，再将所有图形在<code>View.onDraw(Canvas canvas)</code>中通过Android Canvas绘制。</p>
<ol>
<li><p>将ctx封装为V8Object，并在其中对应实现JS Canvas的方法</p>
<pre><code>public class JustContext {
    protected V8 mRuntime;
    protected V8Object mCtx;
    private ArrayList&lt;AbstractDraw&gt; mShapeList = new ArrayList&lt;&gt;();

    public JustContext(V8 v8Runtime) {
        mRuntime = v8Runtime;
        initCtx();
    }

    public V8Object getCtx() {
        return mCtx;
    }

    public ArrayList&lt;AbstractDraw&gt; getShapeList() {
        return mShapeList;
    }

    protected void initCtx() {
        mCtx = new V8Object(mRuntime);

        //将Java方法注册到该V8Object中
        mCtx.registerJavaMethod(this, &quot;beginPath&quot;, &quot;beginPath&quot;, null);
        mCtx.registerJavaMethod(this, &quot;closePath&quot;, &quot;closePath&quot;, null);

        ...
    }

    public void clean() {
        mCtx.release();
    }

    public void beginPath() {...}

    public void closePath() {...}

    ...
}
</code></pre></li>
</ol>
<ol>
<li><p>自定义View，在View的<code>onDraw(Canvas canvas)</code>方法中将传入的图形List绘制出来</p>
<pre><code>public class JustView extends View implements Serializable {
    ...

    private ArrayList&lt;AbstractDraw&gt; mShapeList = new ArrayList&lt;&gt;();

    public void setShapeList(ArrayList&lt;AbstractDraw&gt; shapeList) {
        this.mShapeList = shapeList;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        for (AbstractDraw abstractDraw : mShapeList) {
            abstractDraw.draw(canvas);
        }
    }

    ...
}
</code></pre></li>
<li><p>将ctx注册到JS上下文，并执行JS代码，执行完毕后将绘制图形List传递给View</p>
<pre><code>JustView mJustView;
...

public void runJs(String js) {
    V8 context = V8.createV8Runtime();
    JustContext ctx = new JustContext(context);
    context.add(&quot;ctx&quot;, ctx.getCtx());
    context.executeScript(js);

    //释放内存
    ctx.clean();
    context.release();

    mJustView.setShapeList(ctx.getShapeList());
}

...
</code></pre></li>
</ol>
<ol>
<li><p>因为已将ctx注册到JS上下文，因此可以直接使用<code>ctx</code>变量，并运行如下JS代码</p>
<pre><code>ctx.beginPath();
ctx.arc(100, 100, 25, 0, 360, false);
ctx.moveTo(20,20);
ctx.lineTo(20,100);
ctx.lineTo(70,100);
ctx.moveTo(100, 100);
ctx.setLineWidth(15);
ctx.setStrokeColor(&quot;#188ffc&quot;);
ctx.stroke();        
ctx.setFillColor(&quot;#188ffc&quot;);
ctx.fillText(&quot;Hello World!&quot;,150,50);
</code></pre><p> 绘制结果如下：</p>
<p> <img src="android_shape.png" alt="HelloWorld"></p>
</li>
</ol>
<p>以上仅是该实例的简单实现，详细的代码和设计可以根据需求的不同而进行细化，此处(<a href="https://github.com/LiuHongtao/JustDraw)提供一份具体实现的参考。由于每执行一个Canvas方法都将调用一次Java方法，该方案当绘制量过大的时候会出现JNI调用的性能问题，在性能方面也存在优化的空间，后续工作中将进行调用的优化，减少JNI调用次数。" target="_blank" rel="external">https://github.com/LiuHongtao/JustDraw)提供一份具体实现的参考。由于每执行一个Canvas方法都将调用一次Java方法，该方案当绘制量过大的时候会出现JNI调用的性能问题，在性能方面也存在优化的空间，后续工作中将进行调用的优化，减少JNI调用次数。</a></p>
<p>J2V8的团队开发的一套移动端跨平台框架<strong>Tabris.js</strong>(<a href="https://tabrisjs.com/)，支持Android和iOS平台，又于近期宣布支持Windows" target="_blank" rel="external">https://tabrisjs.com/)，支持Android和iOS平台，又于近期宣布支持Windows</a> 10。该框架旨在编写一份JavaScript代码，而能生成Android和iOS两个平台的本地应用。它在Android上使用了J2V8作为JS引擎方案，在iOS上使用系统自带的JSCore。</p>
<p>不同于ReactNative、Weex之类的框架，它的亮点在于不通过WebView，但却能使用Web APIs，如Canvas 2d context（据了解，Weex也正在测试Canvas组件并即将开源）、XMLHttpRequest、localStorage。该框架通过批处理回调减少了JNI的调用，在一定程度上解决了JNI性能问题，例如其Canvas相关代码<code>tabris.CanvasContext</code>中，先将每次调用的Canvas方法和参数存储起来，并在适当的时候通过一次JNI调用来传递要执行的Canvas方法，相关代码如下：</p>
<pre><code>defineMethod(&quot;fillText&quot;, 3, function(text, x, y /* , maxWidth */) {
    this._strings.push(text);
    this._booleans.push(false, false, false);
    this._doubles.push(x, y);
});

function defineMethod(name, reqArgCount, fn) {
    tabris.CanvasContext.prototype[name] = function() {
        if (reqArgCount &amp;&amp; arguments.length &lt; reqArgCount) {
            throw new Error(&quot;Not enough arguments to CanvasContext.&quot; + name);
        }
        this._pushOperation(name);
        if (fn) {
            fn.apply(this, arguments);
        }
    };
}

_pushOperation: function(operation) {
    if (this._opCodes.indexOf(operation) &lt; 0) {
        this._newOpCodes.push(operation);
        this._opCodes.push(operation);
    }
    this._operations.push(this._opCodes.indexOf(operation));
}

_flush: function() {
    if (this._operations.length &gt; 0) {
        this._gc._nativeCall(&quot;draw&quot;, {packedOperations: [
          this._newOpCodes,
          this._operations,
          this._doubles,
          this._booleans,
          this._strings,
          this._ints]});
        this._newOpCodes = [];
      this._operations = [];
      this._doubles = [];
      this._booleans = [];
      this._strings = [];
      this._ints = [];
    }
}
</code></pre><p>也就是说Tabris.js更完整的的实现了本节中的方案，这也使得“将Web端JS库直接拿到移动端执行，并由本地输出结果”变得更加容易。</p>
<p>相关文章</p>
<ul>
<li>Developing a mobile cross-platform library - Part 3. JavaScript</li>
</ul>
<p>(<a href="https://www.skyscanner.net/blogs/developing-mobile-cross-platform-library-part-3-javascript" target="_blank" rel="external">https://www.skyscanner.net/blogs/developing-mobile-cross-platform-library-part-3-javascript</a>)</p>
<ul>
<li>Part I: How to Choose a JavaScript Engine for iOS and Android Development</li>
</ul>
<p>(<a href="http://openaphid.github.io/blog/2013/01/17/part-i-how-to-choose-a-javascript-engine-for-ios-and-android-apps/" target="_blank" rel="external">http://openaphid.github.io/blog/2013/01/17/part-i-how-to-choose-a-javascript-engine-for-ios-and-android-apps/</a>)</p>
<ul>
<li>Getting Started With J2V8</li>
</ul>
<p>(<a href="http://eclipsesource.com/blogs/getting-started-with-j2v8/" target="_blank" rel="external">http://eclipsesource.com/blogs/getting-started-with-j2v8/</a>)</p>
<ul>
<li>J2V8-A Highly Efficient JS Runtime For Java</li>
</ul>
<p>(<a href="https://www.eclipsecon.org/na2015/sites/default/files/slides/J2V8_0.pdf" target="_blank" rel="external">https://www.eclipsecon.org/na2015/sites/default/files/slides/J2V8_0.pdf</a>)</p>
<ul>
<li>Smile: Deploying a mobile app has never been so easy</li>
</ul>
<p>(<a href="http://eclipsesource.com/blogs/2016/08/10/smile-deploying-a-mobile-app-has-never-been-so-easy/" target="_blank" rel="external">http://eclipsesource.com/blogs/2016/08/10/smile-deploying-a-mobile-app-has-never-been-so-easy/</a>)</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/android/">android</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://hellojql.github.io/2016/12/26/NeteaseFed/android/Android JS引擎/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <SCRIPT language=javascript>
function search(formname) {
    formname.method = "get";
    formname.action = "http://www.baidu.com/baidu";
    document.search_form.word.value = document.search_form.word.value + " site:hellojql.github.io”;
    return true;
}
</SCRIPT>

<div class="search">
    <form name="search_form" target="_blank" onsubmit="search(this)">
        <input type="search" name="word" results="0" placeholder="" onblur="this.value=''">
        <!-- <input type="submit" value="搜索"> -->
    </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/android/">android</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 网易前端技术部
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>

{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/Jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/Jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/Jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/Jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/Jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"d521efeeeef0e873b9267c7de98082c5a51b83ae","modified":1483597621000},{"_id":"themes/Jacman/.DS_Store","hash":"d0b50c4bee08ed02da295d6812d38219b705d0ec","modified":1483598540000},{"_id":"themes/Jacman/_config.yml","hash":"a6b8852c7dfad835b0e1d420898b479360f5ea31","modified":1483598552000},{"_id":"themes/Jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1483597248000},{"_id":"themes/Jacman/README_zh.md","hash":"d6014b16eaccc97dc54a7779c9e36003752410e1","modified":1483597248000},{"_id":"themes/Jacman/README.md","hash":"75a5c9fbd7c9cec4d2f277042d2fee550e4936be","modified":1483597248000},{"_id":"source/_posts/.DS_Store","hash":"591b4ad77c0ed39aab91468be86a867c656f714f","modified":1483597633000},{"_id":"themes/Jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1483597248000},{"_id":"themes/Jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1483597248000},{"_id":"themes/Jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1483597248000},{"_id":"themes/Jacman/layout/.DS_Store","hash":"142033ad7691e5dc649e1bfccda3e99a2f4b1176","modified":1483598270000},{"_id":"themes/Jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1483597248000},{"_id":"themes/Jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1483597248000},{"_id":"themes/Jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1483597248000},{"_id":"themes/Jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1483597248000},{"_id":"themes/Jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1483597248000},{"_id":"themes/Jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1483597248000},{"_id":"themes/Jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1483597248000},{"_id":"themes/Jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1483597248000},{"_id":"source/_posts/ios/.DS_Store","hash":"f8c107d12454d739608c50c13e0c226d66565249","modified":1483596851000},{"_id":"source/_posts/android/.DS_Store","hash":"a994b6fc653278499ee1690f72f5430325a78744","modified":1483596286000},{"_id":"source/_posts/android/Jenkins-ci容器化在Android项目构建中的应用（公众号版）.md","hash":"e2c2df729f68bcccaa7582598aa86f757f114cfb","modified":1483596155000},{"_id":"source/_posts/android/网易 Android 工程模板化实践.md","hash":"7d780f913ee62ac7e1531883b3cc511126e339ef","modified":1483596823000},{"_id":"source/_posts/ios/关于LLVM这些东西你必须要知道 .md","hash":"b1ff2de916a3f5c7bf1b8afc5159e38825cd3667","modified":1483596912000},{"_id":"themes/Jacman/layout/_partial/.DS_Store","hash":"2638a4802e4362d15235243434ae867cfd8a71ae","modified":1483598449000},{"_id":"themes/Jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/comment.ejs","hash":"4b4e13ae539fbd672b6ee31b31c8496b44d8b46d","modified":1482836975000},{"_id":"themes/Jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/footer.ejs","hash":"09fa1b4d99db4a548ab981ca3724c827034cc19e","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1483597248000},{"_id":"themes/Jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1483597248000},{"_id":"themes/Jacman/layout/_widget/weibo.ejs","hash":"70cfd82a1a4fc3e759abf5f20325ca655559744f","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1483597248000},{"_id":"themes/Jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1483597248000},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1483597248000},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1483597248000},{"_id":"themes/Jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1483597248000},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1483597248000},{"_id":"themes/Jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1483597248000},{"_id":"themes/Jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1483597248000},{"_id":"themes/Jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1483597248000},{"_id":"themes/Jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1483597248000},{"_id":"themes/Jacman/source/img/author.jpg","hash":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1483597248000},{"_id":"themes/Jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483597248000},{"_id":"themes/Jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483597248000},{"_id":"themes/Jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483597248000},{"_id":"themes/Jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483597248000},{"_id":"themes/Jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483597248000},{"_id":"themes/Jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483597248000},{"_id":"themes/Jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483597248000},{"_id":"themes/Jacman/source/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1483597248000},{"_id":"themes/Jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1483597248000},{"_id":"themes/Jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1483597248000},{"_id":"themes/Jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1483597248000},{"_id":"themes/Jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1483597248000},{"_id":"themes/Jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1483597248000},{"_id":"themes/Jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1483597248000},{"_id":"themes/Jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1483597248000},{"_id":"themes/Jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1483597248000},{"_id":"themes/Jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1483597248000},{"_id":"themes/Jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1483597248000},{"_id":"source/_posts/android/Android Js引擎/.DS_Store","hash":"da16757a80ed05681975b6d9ce9258dac021baa7","modified":1483595132000},{"_id":"themes/Jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1483597248000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/.DS_Store","hash":"4ad3d37df3542ffb20418076b27270cb01bdfc85","modified":1483097488000},{"_id":"source/_posts/ios/移动端混合编程/.DS_Store","hash":"3302196371db08029771a83ca833e4fde7a18e74","modified":1483594946000},{"_id":"themes/Jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1483597248000},{"_id":"source/_posts/android/Android Js引擎/Android平台上的JavaScript引擎.md","hash":"90e9693db493b957788d5b4c97a71d9c379b72b4","modified":1483595152000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现.md","hash":"9a423568ae9e4012e180c2465d5cd447b323b5f6","modified":1483097486000},{"_id":"themes/Jacman/layout/_partial/post/article.ejs","hash":"f4a076a8520d37b1be80b4e6ed560f379a141adb","modified":1483597248000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程.md","hash":"454976c0bb060a5898cfd6fcf335a440d8d5a79c","modified":1483594945000},{"_id":"themes/Jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/post/header.ejs","hash":"f825562e2c9a6753dbacb99f1dcfaa93b73ca7b4","modified":1483597248000},{"_id":"themes/Jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1483597248000},{"_id":"themes/Jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1483597248000},{"_id":"themes/Jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/aside.styl","hash":"4193e3d4fa00feb8ad578b86b30d5316265e70fb","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/footer.styl","hash":"bea5728074d4e33b12824d225f0d8eedb33b325e","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1483597248000},{"_id":"themes/Jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1483597248000},{"_id":"themes/Jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1483597248000},{"_id":"themes/Jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483597248000},{"_id":"themes/Jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1483597248000},{"_id":"themes/Jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1483597248000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/.DS_Store","hash":"9749b5d80d226ca9f50759ee8986b30119194ed1","modified":1483090908000},{"_id":"source/_posts/android/Android Js引擎/Android平台上的JavaScript引擎/android_shape.png","hash":"1b7fc1898697c602c0f4e60b4336e55318f18f8c","modified":1482803257000},{"_id":"source/_posts/android/Android Js引擎/Android平台上的JavaScript引擎/web_shape.png","hash":"009fa50c4d50decb775de374730947e88288d1d9","modified":1482803257000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCopyProperty.png","hash":"f9869a99ec3996be9d5f01c2ae9f6364c717ae73","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMDlsymClose.png","hash":"88169ff44a016f63e7af6cd8572b68a0975fff15","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMErrorPropertyForKey.png","hash":"b58689e3d90fd8f9070e978a7a028af384f43f75","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRightPropertyForKey.png","hash":"dd5cd2e1ed4d876c708cdb88e1be3ab4ec3d7add","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/.DS_Store","hash":"e841e8f4022594a0ff8e1a373389fcb8f0318803","modified":1483090897000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/ProxyDelegateInvocation.png","hash":"4ef5d600f5e2a679334ee49b7e492d8aff9f84b6","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/Objective-CAOP.png","hash":"4b6dee338d5ed1d337632055121829222c7d9186","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/reactnative2.png","hash":"d87d5437847c9cb1d9f99e288d6bf6a970d8b840","modified":1483090683000},{"_id":"themes/Jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1483597248000},{"_id":"themes/Jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1483597248000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview.png","hash":"f1438b8d8d21ae714be6dfc2614351095820dedc","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRequestSearch.png","hash":"8d78eb3c9b8b03baafc622d96bff911052920ce6","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMUseSample.png","hash":"522273349113c6530d29cb7554bde958909394f9","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRequest.png","hash":"d4c53b7a92a363a1a3d40574f702e6002a64facb","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/cordova.png","hash":"e4f42f8f6197f81483b2f3a5895bacdf22736eb5","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview3.png","hash":"ca791a58075a9751fd90c714377f0eb368e04327","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMUITrace.png","hash":"69563edf715a8072c2eafb82ef859f9d2f18c384","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/reactnative.png","hash":"dd11e1d8ee931678fb7e41a157c6db0157d2bb2f","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/p-rn.gif","hash":"cb73ed1f92166baaa2b050e00e16e014741d1487","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/5+.png","hash":"725ce5c9d78a1017ec2589d4cc19d4a9d0639799","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/reactnative-scrollview.png","hash":"0831b86fba39accf593d38c3b4ff747126101536","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/p-native.gif","hash":"5b4b372d244226ae13336cf2223a50c7572ec3f3","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview2.png","hash":"d1d4da0d21f751b1da82210300ddc9d7be8c8126","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMURLConnectionHook.png","hash":"378721492c8accf8fc8f28f0f2bf123996286cf3","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCFHookCreate.png","hash":"121322992ef11637b535f5cbc217761c0e6d2312","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMAOPTheory.png","hash":"7f0b598350627b4e376d1ef0c2de5d7bb1684e42","modified":1483090682000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMStruct.png","hash":"2278f93dc879694caca893e9461145ae350ad9e4","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMFindSymbolIMPLocation.png","hash":"1705cf56393bb8fe436d01bac305ad0a7775eb97","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMStructDesign.png","hash":"b1a420efad831fee10c35fab2c2226f7ecbd0f81","modified":1483090683000},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCFHookConnectionFlow.png","hash":"32bef9f4fcac31141e1af9e59629cae056bcd713","modified":1483090683000},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview.gif","hash":"2cea790b005cc4df67e27c16f964035a24988483","modified":1483090683000},{"_id":"public/archives/index.html","hash":"83a62c74b426a42f171a1249d2c2fe14970b77a3","modified":1483598657839},{"_id":"public/archives/2016/index.html","hash":"1031a9c545e9a7252a5250953da589501ab57f66","modified":1483598657839},{"_id":"public/archives/2016/11/index.html","hash":"394e99495165584afdbb906fe9bc870d66ad4318","modified":1483598657839},{"_id":"public/archives/2016/12/index.html","hash":"89266cae901a65d55b04135d516f3efaf43df6b8","modified":1483598657839},{"_id":"public/categories/android/index.html","hash":"dfb94829af68efa7d71664e94d116634b3c00647","modified":1483598657840},{"_id":"public/categories/ios/index.html","hash":"8dd78042852285234d734a3872008f74592523f7","modified":1483598657840},{"_id":"public/tags/Jenkins/index.html","hash":"6df2bbba4e57f9f7a85fbeedf2d0cc9d78ac24bd","modified":1483598657840},{"_id":"public/tags/ci容器/index.html","hash":"640a8ae5892967e62e651505f6637b3746960d43","modified":1483598657840},{"_id":"public/tags/android工程模板/index.html","hash":"63682bb76d85a50fbe84b571e1728d5c13f40b13","modified":1483598657840},{"_id":"public/tags/LLVM/index.html","hash":"8ac75283754c8a0d90b16787942d699a05ec1dd5","modified":1483598657840},{"_id":"public/tags/Js引擎/index.html","hash":"7dc331328194c0bba41790d2d59ef18de963e150","modified":1483598657840},{"_id":"public/tags/NeteaseAPM/index.html","hash":"d996a82ced6b228d8e15f2f580cf1aecedc355a6","modified":1483598657840},{"_id":"public/tags/混合开发框架/index.html","hash":"7267113fa5a8574e774aa560aae095425d8dad94","modified":1483598657840},{"_id":"public/2016/12/29/ios/关于LLVM这些东西你必须要知道 /index.html","hash":"e9a2086c0b9315596544d3009c028487b9f87d6e","modified":1483598657841},{"_id":"public/2016/12/23/android/Android Js引擎/Android平台上的JavaScript引擎/index.html","hash":"e9140e8867bd5689a3be07691392ce2dadc11551","modified":1483598657841},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/index.html","hash":"1af3577f07ce598a5e773d1f7e3a141dd9490436","modified":1483598657841},{"_id":"public/2016/12/09/android/Jenkins-ci容器化在Android项目构建中的应用（公众号版）/index.html","hash":"14961b06c15e13e5633072d8da9e536638f73174","modified":1483598657841},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/index.html","hash":"e386afbc26bec8d5f535b44f19255262afc033d2","modified":1483598657841},{"_id":"public/2016/11/25/android/网易 Android 工程模板化实践/index.html","hash":"2413e581f51d0e9293639a74d58bdd32296f1b40","modified":1483598657841},{"_id":"public/index.html","hash":"58b933dff0d15cdff5c04b248e0bca15bec3d4fd","modified":1483598657841},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483598657852},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483598657852},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483598657852},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483598657852},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483598657852},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483598657852},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1483598657852},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1483598657852},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1483598657852},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1483598657852},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1483598657852},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1483598657852},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1483598657852},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1483598657852},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1483598657852},{"_id":"public/img/author.jpg","hash":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1483598657852},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483598657852},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483598657853},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483598657853},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483598657853},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483598657853},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483598657853},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483598657853},{"_id":"public/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1483598657853},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1483598657853},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1483598657853},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1483598657853},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483598657853},{"_id":"public/2016/12/23/android/Android Js引擎/Android平台上的JavaScript引擎/android_shape.png","hash":"1b7fc1898697c602c0f4e60b4336e55318f18f8c","modified":1483598657853},{"_id":"public/2016/12/23/android/Android Js引擎/Android平台上的JavaScript引擎/web_shape.png","hash":"009fa50c4d50decb775de374730947e88288d1d9","modified":1483598657853},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/reactnative2.png","hash":"d87d5437847c9cb1d9f99e288d6bf6a970d8b840","modified":1483598657853},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/superwebview.png","hash":"f1438b8d8d21ae714be6dfc2614351095820dedc","modified":1483598657853},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCopyProperty.png","hash":"f9869a99ec3996be9d5f01c2ae9f6364c717ae73","modified":1483598657853},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMErrorPropertyForKey.png","hash":"b58689e3d90fd8f9070e978a7a028af384f43f75","modified":1483598657853},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMDlsymClose.png","hash":"88169ff44a016f63e7af6cd8572b68a0975fff15","modified":1483598657853},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRightPropertyForKey.png","hash":"dd5cd2e1ed4d876c708cdb88e1be3ab4ec3d7add","modified":1483598657853},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/Objective-CAOP.png","hash":"4b6dee338d5ed1d337632055121829222c7d9186","modified":1483598657854},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/ProxyDelegateInvocation.png","hash":"4ef5d600f5e2a679334ee49b7e492d8aff9f84b6","modified":1483598657854},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1483598658547},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1483598658550},{"_id":"public/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1483598658552},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1483598658552},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/superwebview3.png","hash":"ca791a58075a9751fd90c714377f0eb368e04327","modified":1483598658552},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRequestSearch.png","hash":"8d78eb3c9b8b03baafc622d96bff911052920ce6","modified":1483598658552},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMUseSample.png","hash":"522273349113c6530d29cb7554bde958909394f9","modified":1483598658552},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1483598658560},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1483598658560},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1483598658560},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1483598658560},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483598658560},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1483598658560},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1483598658560},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483598658560},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1483598658560},{"_id":"public/css/style.css","hash":"f26a0e7e0c5f1031e6a1d030b662e4e8a4d008e0","modified":1483598658560},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1483598658560},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1483598658560},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1483598658560},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1483598658560},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRequest.png","hash":"d4c53b7a92a363a1a3d40574f702e6002a64facb","modified":1483598658560},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/cordova.png","hash":"e4f42f8f6197f81483b2f3a5895bacdf22736eb5","modified":1483598658561},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1483598658568},{"_id":"public/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1483598658568},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMUITrace.png","hash":"69563edf715a8072c2eafb82ef859f9d2f18c384","modified":1483598658569},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/reactnative.png","hash":"dd11e1d8ee931678fb7e41a157c6db0157d2bb2f","modified":1483598658569},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/p-rn.gif","hash":"cb73ed1f92166baaa2b050e00e16e014741d1487","modified":1483598658574},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/5+.png","hash":"725ce5c9d78a1017ec2589d4cc19d4a9d0639799","modified":1483598658579},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/p-native.gif","hash":"5b4b372d244226ae13336cf2223a50c7572ec3f3","modified":1483598658579},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/reactnative-scrollview.png","hash":"0831b86fba39accf593d38c3b4ff747126101536","modified":1483598658579},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/superwebview2.png","hash":"d1d4da0d21f751b1da82210300ddc9d7be8c8126","modified":1483598658595},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMURLConnectionHook.png","hash":"378721492c8accf8fc8f28f0f2bf123996286cf3","modified":1483598658600},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMStruct.png","hash":"2278f93dc879694caca893e9461145ae350ad9e4","modified":1483598658601},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCFHookCreate.png","hash":"121322992ef11637b535f5cbc217761c0e6d2312","modified":1483598658603},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMAOPTheory.png","hash":"7f0b598350627b4e376d1ef0c2de5d7bb1684e42","modified":1483598658605},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMStructDesign.png","hash":"b1a420efad831fee10c35fab2c2226f7ecbd0f81","modified":1483598658611},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMFindSymbolIMPLocation.png","hash":"1705cf56393bb8fe436d01bac305ad0a7775eb97","modified":1483598658613},{"_id":"public/2016/12/16/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCFHookConnectionFlow.png","hash":"32bef9f4fcac31141e1af9e59629cae056bcd713","modified":1483598658615},{"_id":"public/2016/12/02/ios/移动端混合编程/移动端混合编程/superwebview.gif","hash":"2cea790b005cc4df67e27c16f964035a24988483","modified":1483598658640}],"Category":[{"name":"android","_id":"cixk0c23q00027ekkubvck7pk"},{"name":"ios","_id":"cixk0c24400087ekk566a4s3e"}],"Data":[],"Page":[],"Post":[{"title":"Jenkins-ci容器化在Android项目构建中的应用","date":"2016-12-08T16:00:00.000Z","author":"付光鑫","_content":"随着软件开发复杂度的不断提高，如何能在不断变化的需求中快速适应和保证软件的质量显得尤其的重要，[持续集成](http://baike.baidu.com/view/5253255.htm)正是针对这一类问题的一种软件开发实践。 <!-- more -->\n\n本文中的`Jenkins-ci`容器化方案能够在项目构建过程中提取出更多自定义的需求信息并进一步将持续集成的环境参数配置标准化。\n因此，在项目的构建过程中，我们对用户比较关心的信息（如代码质量、`apk`方法数和大小、资源文件变化、代码提交记录等）进行跟踪、收集、分析和统计，并将结果以图表的形式在通知邮件中展现给用户，让用户对项目的迭代情况有更多的了解。\n\n# 1. Jenkins配置以及构建通知邮件内容定制\n\n## 1.1 Jenkins安装、配置与使用\n\n关于详细的Jenkins安装、配置与使用说明，可参考文章[Jenkins工具(一)之 Jenkins集成android工程](http://wangkuiwu.github.io/2015/08/07/jenkins-01/)\n和[Jenkins工具(二)之 Jenkins集成android工程](http://wangkuiwu.github.io/2015/08/07/jenkins-02/)，文中不再详细叙述。\n\n其中，构建中使用到的插件几个主要插件：\n\n* [Git plugin](https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin) Git工具集成\n* [Gitlab Plugin](https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin)和[Gitlab Hook Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin) 支持Gitlab项目构建\n* [Gradle plugin](https://wiki.jenkins-ci.org/display/JENKINS/Gradle+Plugin) Gradle工具集成\n* [Email Extension Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+plugin) 构建结构邮件通知\n* [Git Changelog Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Git+Changelog+Plugin) 获取Git提交记录\n* [Android Lint Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Android+Lint+Plugin) 收集分析Android Lint检查结果\n* [FindBugs Plugin](https://wiki.jenkins-ci.org/display/JENKINS/FindBugs+Plugin) 收集分析FindBugs检查结果\n* [HTML Publisher plugin](https://wiki.jenkins-ci.org/display/JENKINS/HTML+Publisher+Plugin) 支持HTML报告\n\n## 1.2 构建结果邮件定制\n\n完成`Jenkins`的安装以及环境参数配置后，新建一个项目用于构建，项目构建完成后需要将结果内容通过邮件的方式通知用户。将构建结果通知到用户的邮件内容的定制，则是本次实践的重点。\n\n本次自动化构建将包括以下几个内容：`FireLine`（源码检查）、`Android Lint`、`FindBugs`（Class文件检查）、`Apk`包大小和方法数统计、资源文件统计，以及`Git commit`日志分析。\n\n### 1.2.1 Email Extension 配置\n\n构建结果邮件内容定制依赖于前面提到的`Email Extension Plugin`，该插件目前支持`Jelly`和`Groovy`两种语法编写模板，本文的模板内容定制将采用`Groovy`（个人认为`Jelly`标签不够灵活）。同时，创建的模板文件要放在`Jenkins`根目录下的`email-templates`文件夹下。模板文件配置如下：\n\n```\n${SCRIPT, template=\"ht-ci.template\"}\n```\n\n另外，想要在模板中获取构建结果信息，可以通过获取`Jenkins`环境中的`Action`对象来实现。`Action`是插件用来在`Job`或`Build`页面增加功能的一种主要方式，是`Jenkins`最常用的一个扩展点。如`org.jenkinsci.plugins.android_lint.LintResultAction`、hudson.plugins.findbugs.FindBugsResultAction等，后文将多次用到。\n\n### 1.2.2 Android Lint\n\n`Android Lint`是一个静态代码分析工具，它能够对你的`Android`项目中潜在的`bug`、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。支持自定义Lint规则，可参考文章[浅谈Android自定义Lint规则的实现 （一）](http://carrotsight.com/2016/01/29/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%80%EF%BC%89.html)、[浅谈Android自定义Lint规则的实现 （二）](http://carrotsight.com/2016/02/01/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89.html)。\n\n安装插件`Android Lint Plugin`后，进入项目的配置页，并添加构建后操作`Publish Android Lint results`，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在`Invoke Gradle Script`的`Task`中添加对应的`lint`检查任务。\n\n通过阅读[ android-lint-plugin ](https://github.com/jenkinsci/android-lint-plugin)的源码可知，只要获取[org.jenkinsci.plugins.android_lint.LintResultAction](https://github.com/jenkinsci/android-lint-plugin/blob/8e88de5c9ec2f2d58bf0965592f6ffed040f0542/src/main/java/org/jenkinsci/plugins/android_lint/LintResultAction.java)对应的`Action`实例，就可以得到`lint`检查的数据。\n\n最终，邮件中的显示结果如图：\n\n![](https://nos.netease.com/popo/9da8a7374fe8ba7f4b91e78acb27392e.jpg)\n\n点击链接地址，会跳转到`Lint Issues`的包含图文描述的界面，如图：\n\n![Lint Issues](http://nos.netease.com/knowledge/e8b39b38-131f-4043-9178-3fc8ad4861c1) \n\n不过需要注意的是，默认情况下，在`Gradle`插件`com.android.application`的`android`对象中，`lintOptions`的`abortOnError`参数为`true`，在执行`lint`命令时，遇到错误即中止构建。因此，若希望`lint`执行出错后继续构建，则需要将该参数置为`false`，可以在`build.gradle`文件中动态修改：\n\n```groovy\n...\nafterEvaluate { project ->\n    if (project.properties.containsKey('android')) { //针对android应用和android库项目\n        project.android.lintOptions.abortOnError false //禁止遇到错误中止构建  \n    }\n}\n...\n```\n\n### 1.2.3 FindBugs\n\n[Findbugs](https://zh.wikipedia.org/wiki/FindBugs)是一个静态分析工具，用来查找`Java`代码中的程序错误，将字节码与一组缺陷模式进行对比以发现可能的问题，并根据其可能产生的影响或严重程度，而对开发者的提示。并且，这组缺陷模式是可配置的，通过配置可以过滤掉一些我们不想或不需要检测的问题。\n\n`FindBugs`和`Android Lint`的集成方式基本一致。在安装插件`FindBugs Plugin`后，进入项目配置页，并添加构建后操作`Publish FindBugs analysis results`，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在`Invoke Gradle Script`的`Task`中添加对应的`findbugs `检查任务。\n\n```groovy\n//findbugs插件\napply plugin: 'findbugs' \ntask findbugs(type: FindBugs, dependsOn: 'assembleDebug') {//依赖Debug打包所产生的class文件\n    ...\n    excludeFilter = file(\"${project.rootDir}/configs/scripts/findbugs-filter.xml\") //配置过滤文件，减少不必要的检查\n    classes = files(\"${project.buildDir}/intermediates/classes/\")//默认分析的class文件对象\n    ...\n}\n\n```\n\n结合[findbugs-plugin](https://github.com/jenkinsci/findbugs-plugin)的源码可知，只要获取[hudson.plugins.findbugs.FindBugsResultAction](https://github.com/jenkinsci/findbugs-plugin/blob/master/plugin/src/main/java/hudson/plugins/findbugs/FindBugsResultAction.java)对应的`Action`实例，就可以得到分析结果。最后，在邮件中的显示结果如图：\n\n![](https://nos.netease.com/popo/743676cae801faeb937ab0e828fb4476.jpg)\n\n点击链接地址，同样跳转到`FindBugs`的图文界面。\n\n![](https://nos.netease.com/popo/610530e913c4ab0f321321c359ea9f53.jpg)\n\n### 1.2.4 动态集成自定义的gradle任务方案\n\n在项目持续集成时，我们需要添加一些自定义的任务，但是又要尽量避免修改用户的项目代码。因此，本文采用了一个比较折中的方案：\n在`Jenkins`的根目录下建一个`configs`文件夹，放置一些项目构建过程使用的第三方库、脚本以及配置文件等；然后在项目构建之前，通过执行`Job`配置页的脚本将该文件夹及其内容复制到目标构建项目的工作空间中，同时修改项目的`build.gradle`文件；最后在项目构建过程中，调用这些第三方库、脚本以及配置文件，来完成自定义的额外的构建任务。\n\n`FindBugs`任务的集成就应用了上述方案，后续介绍的`FireLine`集成以及`Apk`大小、方法数和资源文件统计的集成亦是如此。\n\n例如，修改`build.gradle`文件，动态引入`jenkins.gradle`文件：\n\n```\ngroovy\nproject(':app') { //在项目的主moudle（一般默认是app）中引用构建相关的gradle脚本\n    apply from: rootProject.getRootDir().getAbsolutePath() + '/configs/scripts/jenkins.gradle'\n    ...\n}\n\n```\n\n### 1.2.5 FireLine\n\nFireLine 提供一种静态代码（指`java`源码，后来据说又支持`class`文件）扫描服务，基于`PMD`开源。它是360公司针对自己的产品定制的安全检查规则，使用这些规则对源代码进行扫描检测，找出代码潜在的安全风险。目前，对外也可以使用。因此，本文对该工具进行了集成。\n\nFireLine 对外提供一个`jar`包，必须通过命令行的形式运行，因此需要添加一个`fireLine`的任务：\n\n```\ngroovy\n//扫描java源码，需指定扫描对象以及结果存储位置\ntask fireLine << {\n    def fireLineDir=env.JENKINS_HOME+\"/jobs/\"+env.JOB_NAME+\"/builds/\"+env.BUILD_NUMBER+\"/\"\n    exec {\n        workingDir './'\n        //命令行执行jar包\n        commandLine \"java\", \"-jar\", \"${project.rootDir}/configs/jars/fireline.jar\", \"scanSrcDir=\"+env.WORKSPACE, \"reportSaveDir=\"+fireLineDir,\"reportFileName=fireLineResult\",\"user=netease\"\n    }\n    ...\n}\n```\n构建后，检查结果在邮件中显示如图：\n\n![](https://nos.netease.com/popo/70d4c25e2675849aa5b760c258ad655e.jpg)\n\n点击链接地址，跳转到需要`HTML Publisher Plugin`支持的火线检查的详细界面：\n\n![](https://nos.netease.com/popo/8ad710117b1e3f862f24d23b783fde84.jpg)\n\n注意，若`FireLine`报告不能正常显示，这是由于它使用了`JavaScript`，这里需要设置`jenkins`允许脚本执行（`allow-scripts`），需要在系统设置页的`Jenkins Script Console`选项中输入命令：\n\n ```\n System.setProperty(\"hudson.model.DirectoryBrowserSupport.CSP\", \"\") \n \n ```\n  \n并执行，从而修改`Jenkins`的默认配置参数，然后重新构建项目即可。\n\n### 1.2.6 Apk方法数、大小以及资源文件分析\n\n随着项目的不断迭代更新，`android`应用不得不面对`64k`方法数限制、`Apk`体积不断变大的问题。因此，本次实践中将对该类数据进行收集分析，更加直观的展现给关注该类信息的用户。\n\n#### 1.2.6.1 Apk方法数、大小统计\n\n在Apk方法数统计集成中，采用了开源的`Gradle`插件项目-[dexcount-gradle-plugin](https://github.com/KeepSafe/dexcount-gradle-plugin)，该插件会根据配置为打包的每个`Apk`文件生成一份方法数统计的文件。\n\n```groovy\nbuildscript {\n    repositories {\n        mavenCentral() // or jcenter()\n    }\n    dependencies {\n        classpath 'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.6.1'\n    }\n}\n\n// make sure this line comes *after* you apply the Android plugin\napply plugin: 'com.getkeepsafe.dexcount'\n```\n配置完成后，执行`assemble`任务时，会在`app/build/outputs`目录下生成`apk`方法数统计数据文件：\n\n![]( https://nos.netease.com/popo/c139efda8d19abae9869aadc6fdb044b.jpg)\n\n因此，在本次`jenkins-ci`实践中，我们需要做就是在构建项目中动态添加该插件，并将该插件生成的统计数据进行收集、转换。\n\n和集成`findbugs`插件不同的是，这里还需要动态修改`app`项目的`buildscript`对象，并保证该插件是在`com.android.application`之后被应用。\n\n```groovy\n//动态修改`app`项目的`buildscript`对象\nproject(':app') {\n    apply from: rootProject.getRootDir().getAbsolutePath() + '/configs/scripts/buildscript.gradle', to: buildscript\n    ...\n}\n```\n并通过调用`gradle`中的`PluginManager`对象的`void withPlugin(String id, Action<? super AppliedPlugin> action)`方法，来监听插件的添加事件。当`com.android.application`插件被添加时，就可以动态添加`dexcount-gradle-plugin`插件。\n\n```groovy\npluginManager.withPlugin(\"com.android.application\", new Action<AppliedPlugin>() {\n    void execute(AppliedPlugin appliedPlugin) {\n        project(':app') { //主module名称\n            apply plugin: 'com.getkeepsafe.dexcount' //引入apk方法数统计插件\n            apply plugin: \"com.netease.hearttouch.resourcesize\" //引入资源文件统计插件\n            ...\n        }\n    }\n})\n```\n最后，为了在`jenkins`中使用该数据，创建一个`apkMethodCounts`任务将上述的所有的`json`格式文件进行统一解析转换，并将解析结果和生成的`Apk`文件--对应起来。构建结果如图：\n\n![](https://nos.netease.com/popo/ab6fd8a20b0836902c48f3d02ddec216.jpg)\n\n#### 1.2.6.2 资源文件大小统计\n\n资源文件统计插件[resource-size-plugin](https://g.hz.netease.com/hearttouch-android/resource_size_plugin)与`dexcount-gradle-plugin`的使用方法基本一致，该插件也是需要通过动态添加。\n\n插件配置完成后，执行`resourcesize`任务，会在`app/build/outputs`目录下生成分析结果`resoucesize.txt`。其中，第一行表示所有资源文件的总大小，后面每行代表单个文件最大的文件名称以及文件大小：\n\n![](https://nos.netease.com/popo/d900de430614c344379c01aad3af8c98.jpg?imageView&thumbnail=500x300)\n\n最后，将数据进行简单处理，在`jenkins`的构建结果中显示如图：\n\n![]( https://nos.netease.com/popo/5571e696f32a9e23bf86ce558ab0d22a.jpg?imageView&thumbnail=0x400)\n\n### 1.2.7 Git Changelog分析\n\n随着项目的迭代，代码的提交越来越频繁，代码的管理显得越来越重要。而`commit message`是开发者是对自己所提交代码的唯一说明，它能够直接反映开发者的意图，并方便快速查询和浏览，是必不可少的。在这些`commit message`中，比较重要的主要有`feature`（新功能）和`bug fix`（问题修复）两种类型，也是一个产品的关注点。\n\n因此，为了在构建中提取该类信息，在参考网上的一些`Git`规范的基础上，整理出一份[Git提交规范](https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md)，规定了完整的`git`提交日志由信息头部、信息主体和信息尾部构成，其中信息头部需要包含类型、范围和主题三类信息。\n\n```xml\n<type>(<scope>):<subject>\n 空行\n<body>\n 空行\n<footer>\n```\n详细规范描述可参考[规范文档](https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md)。另外，[Commitizen](https://github.com/commitizen/cz-cli)是一个撰写合格`Commit message`的工具，很好用，推荐～。使用该工提交代码之后，会自动生成上述格式规范的日志信息。\n\n通过`Commitizen`工具（或者手动）提交之后，在`GitLab`上生成的`Commit message`如图：\n\n![](https://nos.netease.com/popo/1de9a4ecf80b34eefcbfcaed7d8f271e.jpg)\n\n从图中的示例可以看出，两个`Commit message`的类型是`feature`和`bug fix`的，因此`Jenkins`构建的过程中需要进行处理并显示给用户。\n￼\n![]( https://nos.netease.com/popo/f4d85368b1fdf419de676e7dec91aac4.jpg)\n\n另外，为了能够解析`bug fix`类型提交中的`jira`上的问题并生成跳转链接，需要在项目根目录下添加一个`jenkins.xml`文件，示例如下：\n\n```xml\n<jenkins>\n<jira>\n        <url>http://jira.netease.com/projects/MINIFIVE/issues/MINIFIVE-#</url> <!--#作为占位符-->\n    </jira>\n</jenkins>\n```\n综上，关于自定义`Jenkins-ci`构建通知邮件内容的部分已经介绍完了，下面我们要讲一下`Jenkins`与`Docker`结合如何实现快速配置。\n\n# 2. Jenkins与Docker结合实现快速配置\n\n[Docker](https://www.docker.com/)是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的`Linux`机器上，也可以实现虚拟化。基于`Docker`轻量级、可移植的特点，本次实践将`Jenkins-ci`的构建环境配置打包到`Docker`中，从而实现快速配置。\n\n## 2.1 Dockerfile文件配置\n\n创建一个自定义的`docker`镜像，可以通过`Dockerfile`描述文件来自动完成。`Dockerfile`文件包含了创建镜像所需要的[全部指令](http://seanlook.com/2014/11/17/dockerfile-introduction/)，可以使用`Docker build`命令来创建镜像。\n\n本文中使用的`Dockerfile`是基于`jenkinsci`开源的[jenkins](https://github.com/jenkinsci/docker)镜像，并根据需求进行了定制，部分内容如下：\n\n```\nFROM jenkins:latest  //已配好java和git环境\n...\n# Same as \"export TERM=dumb\"; prevents error \"Could not open terminal for stdout: $TERM not set\"\nENV TERM dumb\n\n#support 32 bit binary on a 64 bit system\nRUN  apt-get update && apt-get install -y lib32z1 lib32stdc++6 wget && apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n# 下载Android Sdk\n...\nRUN cd /opt && \\\n    wget ${ANDROID_SDK_URL} && \\\n    tar -xzf ${ANDROID_SDK_FILENAME} && \\\n    rm ${ANDROID_SDK_FILENAME} &&\\\n    echo y | android update sdk --no-ui --all --filter tools,platform-tools,extra-android-m2repository,android-23,build-tools-23.0.0,build-tools-23.0.1,build-tools-23.0.2,build-tools-23.0.3\n...\n\n# 拷贝JENKINS_HOME文件夹的内容至$JENKINS_HOME目录下，该文件夹与Dockerfile在同一目录，包含了jenkins ci的全部配置信\nADD JENKINS_HOME $JENKINS_HOME\n\nEXPOSE 8080\n\n```\n\n在配置文件中，我们使用`wget`命令去官方下载最新的`linux`下`android SDK`包，并配置环境，然后使用`android`命令选择和自己项目匹配的`SDK`以及工具的版本（本次打包的镜像下载了`android-23`以及系列的编译工具，用户可根据需求自行修改）。\n\n## 2.2 使用Dockerfile文件构建镜像\n\n由于`Docker`是基于`Linux`，在`Mac OS`上运行起来需要一个虚拟的`Linux`环境，它还需要若干工具支持:\n\n* VirtualBox：虚拟机，用来运行`Linux`\n* docker-machine：用来管理虚拟机\n* docker：`Docker`本身\n* docker-compose(Mac OS only)：用来管理多个`docker`容器\n* Kitematic：用来管理远程`Docker Hub`\n\n上述工具安装完毕后（推荐使用[Homebrew](http://brew.sh/)），就可以创建虚拟机，配置`docker`环境：\n\n```bash\ndocker-machine create --driver virtualbox dev   //1、创建虚拟机\n\ndocker-machine env dev    //2、查看dev信息\n\neval \"$(docker-machine env dev)\"   //3、添加到环境变量，关联当前shell\n```\n然后，进入到`Dockerfile`所在的目录，就可以执行`build`命令打包镜像：\n\n```bash\ndocker build -t [docker-image-name\\id] .\n``` \n目前，该镜像已经上传到[网易蜂巢](https://c.163.com/)，可通过一下命令获取：\n\n```bash\ndocker pull hub.c.163.com/netease163/ht-jenkinsci:latest\n```\n更多内容可参考[网易蜂巢使用指南](https://c.163.com/wiki/index.php?title=%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F)。\n综上，本次`Jenkins-ci`容器化实践就讲完了～有问题或建议可以联系我，一起交流～\n\n# 3. 参考资料\n\n * [jenkins官网](https://jenkins.io/)\n * [jenkins插件](https://wiki.jenkins-ci.org/display/JENKINS/Plugins)\n * [Jenkins集成android工程](http://wangkuiwu.github.io/2015/08/07/jenkins-02/)\n * [jenkins-ci](https://github.com/jenkinsci/jenkins)\n * [jenkins的Api文档](http://javadoc.jenkins-ci.org/overview-summary.html)\n * [Jenkins构建Android项目持续集成之findbugs的使用\n](http://itfish.net/article/53357.html)\n * [dexcount-gradle-plugin](https://github.com/KeepSafe/dexcount-gradle-plugin)\n * [FireLine](http://magic.360.cn/index.html)\n * [email-ext-plugin](https://github.com/jenkinsci/email-ext-plugin)\n * [findbugs-plugin](https://github.com/jenkinsci/findbugs-plugin)\n * [Android中使用FindBugs](https://segmentfault.com/a/1190000004881029)\n * [Commit message和Change log编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n * [git-changelog-plugin](https://github.com/paulwellnerbou/git-changelog-jenkins-plugin)\n * [持续集成之Jenkins插件使用-邮件通知模板化](http://qa.blog.163.com/blog/static/19014700220131011102715643/)\n * [搭建linux（ubuntu 14.04）下的android开发环境](http://www.qisanfen.com/?p=474)\n * [Ubuntu下全命令行搭建Android开发环境](http://qianngchn.github.io/wiki/8.html)\n * [Run Docker on your Mac](http://www.jianshu.com/p/13c132503d01)\n * [搭建Android持续集成服务器](http://developerworks.github.io/2014/09/07/android-ci-server/#%E5%AE%89%E8%A3%85Android_SDK)\n* [构建编译Android项目的Docker镜像](http://blog.saymagic.cn/2016/01/25/docker-image-for-android.html)\n* [使用docker来提升你的Jenkins](http://www.larrycaiyu.com/2014/11/04/use-docker-for-your-jenkins-demo-1.html)\n* [Setup Jenkins for Android Integration Using Docker](http://ju.outofmemory.cn/entry/145390)\n* [Mac OSX Docker下搭建Android+Jenkins+Gitlab](http://blog.csdn.net/sbsujjbcy/article/details/52215051)\n* [gitlab与jenkins协同工作](http://www.cnphp6.com/archives/115564)\n\n\n","source":"_posts/android/Jenkins-ci容器化在Android项目构建中的应用（公众号版）.md","raw":"\n---\ntitle: Jenkins-ci容器化在Android项目构建中的应用\n\ndate: 2016-12-09\n\nauthor: 付光鑫\n\ncategories: android\n\ntags: \n- Jenkins\n- ci容器\n\n---\n随着软件开发复杂度的不断提高，如何能在不断变化的需求中快速适应和保证软件的质量显得尤其的重要，[持续集成](http://baike.baidu.com/view/5253255.htm)正是针对这一类问题的一种软件开发实践。 <!-- more -->\n\n本文中的`Jenkins-ci`容器化方案能够在项目构建过程中提取出更多自定义的需求信息并进一步将持续集成的环境参数配置标准化。\n因此，在项目的构建过程中，我们对用户比较关心的信息（如代码质量、`apk`方法数和大小、资源文件变化、代码提交记录等）进行跟踪、收集、分析和统计，并将结果以图表的形式在通知邮件中展现给用户，让用户对项目的迭代情况有更多的了解。\n\n# 1. Jenkins配置以及构建通知邮件内容定制\n\n## 1.1 Jenkins安装、配置与使用\n\n关于详细的Jenkins安装、配置与使用说明，可参考文章[Jenkins工具(一)之 Jenkins集成android工程](http://wangkuiwu.github.io/2015/08/07/jenkins-01/)\n和[Jenkins工具(二)之 Jenkins集成android工程](http://wangkuiwu.github.io/2015/08/07/jenkins-02/)，文中不再详细叙述。\n\n其中，构建中使用到的插件几个主要插件：\n\n* [Git plugin](https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin) Git工具集成\n* [Gitlab Plugin](https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin)和[Gitlab Hook Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin) 支持Gitlab项目构建\n* [Gradle plugin](https://wiki.jenkins-ci.org/display/JENKINS/Gradle+Plugin) Gradle工具集成\n* [Email Extension Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+plugin) 构建结构邮件通知\n* [Git Changelog Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Git+Changelog+Plugin) 获取Git提交记录\n* [Android Lint Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Android+Lint+Plugin) 收集分析Android Lint检查结果\n* [FindBugs Plugin](https://wiki.jenkins-ci.org/display/JENKINS/FindBugs+Plugin) 收集分析FindBugs检查结果\n* [HTML Publisher plugin](https://wiki.jenkins-ci.org/display/JENKINS/HTML+Publisher+Plugin) 支持HTML报告\n\n## 1.2 构建结果邮件定制\n\n完成`Jenkins`的安装以及环境参数配置后，新建一个项目用于构建，项目构建完成后需要将结果内容通过邮件的方式通知用户。将构建结果通知到用户的邮件内容的定制，则是本次实践的重点。\n\n本次自动化构建将包括以下几个内容：`FireLine`（源码检查）、`Android Lint`、`FindBugs`（Class文件检查）、`Apk`包大小和方法数统计、资源文件统计，以及`Git commit`日志分析。\n\n### 1.2.1 Email Extension 配置\n\n构建结果邮件内容定制依赖于前面提到的`Email Extension Plugin`，该插件目前支持`Jelly`和`Groovy`两种语法编写模板，本文的模板内容定制将采用`Groovy`（个人认为`Jelly`标签不够灵活）。同时，创建的模板文件要放在`Jenkins`根目录下的`email-templates`文件夹下。模板文件配置如下：\n\n```\n${SCRIPT, template=\"ht-ci.template\"}\n```\n\n另外，想要在模板中获取构建结果信息，可以通过获取`Jenkins`环境中的`Action`对象来实现。`Action`是插件用来在`Job`或`Build`页面增加功能的一种主要方式，是`Jenkins`最常用的一个扩展点。如`org.jenkinsci.plugins.android_lint.LintResultAction`、hudson.plugins.findbugs.FindBugsResultAction等，后文将多次用到。\n\n### 1.2.2 Android Lint\n\n`Android Lint`是一个静态代码分析工具，它能够对你的`Android`项目中潜在的`bug`、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。支持自定义Lint规则，可参考文章[浅谈Android自定义Lint规则的实现 （一）](http://carrotsight.com/2016/01/29/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%80%EF%BC%89.html)、[浅谈Android自定义Lint规则的实现 （二）](http://carrotsight.com/2016/02/01/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89.html)。\n\n安装插件`Android Lint Plugin`后，进入项目的配置页，并添加构建后操作`Publish Android Lint results`，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在`Invoke Gradle Script`的`Task`中添加对应的`lint`检查任务。\n\n通过阅读[ android-lint-plugin ](https://github.com/jenkinsci/android-lint-plugin)的源码可知，只要获取[org.jenkinsci.plugins.android_lint.LintResultAction](https://github.com/jenkinsci/android-lint-plugin/blob/8e88de5c9ec2f2d58bf0965592f6ffed040f0542/src/main/java/org/jenkinsci/plugins/android_lint/LintResultAction.java)对应的`Action`实例，就可以得到`lint`检查的数据。\n\n最终，邮件中的显示结果如图：\n\n![](https://nos.netease.com/popo/9da8a7374fe8ba7f4b91e78acb27392e.jpg)\n\n点击链接地址，会跳转到`Lint Issues`的包含图文描述的界面，如图：\n\n![Lint Issues](http://nos.netease.com/knowledge/e8b39b38-131f-4043-9178-3fc8ad4861c1) \n\n不过需要注意的是，默认情况下，在`Gradle`插件`com.android.application`的`android`对象中，`lintOptions`的`abortOnError`参数为`true`，在执行`lint`命令时，遇到错误即中止构建。因此，若希望`lint`执行出错后继续构建，则需要将该参数置为`false`，可以在`build.gradle`文件中动态修改：\n\n```groovy\n...\nafterEvaluate { project ->\n    if (project.properties.containsKey('android')) { //针对android应用和android库项目\n        project.android.lintOptions.abortOnError false //禁止遇到错误中止构建  \n    }\n}\n...\n```\n\n### 1.2.3 FindBugs\n\n[Findbugs](https://zh.wikipedia.org/wiki/FindBugs)是一个静态分析工具，用来查找`Java`代码中的程序错误，将字节码与一组缺陷模式进行对比以发现可能的问题，并根据其可能产生的影响或严重程度，而对开发者的提示。并且，这组缺陷模式是可配置的，通过配置可以过滤掉一些我们不想或不需要检测的问题。\n\n`FindBugs`和`Android Lint`的集成方式基本一致。在安装插件`FindBugs Plugin`后，进入项目配置页，并添加构建后操作`Publish FindBugs analysis results`，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在`Invoke Gradle Script`的`Task`中添加对应的`findbugs `检查任务。\n\n```groovy\n//findbugs插件\napply plugin: 'findbugs' \ntask findbugs(type: FindBugs, dependsOn: 'assembleDebug') {//依赖Debug打包所产生的class文件\n    ...\n    excludeFilter = file(\"${project.rootDir}/configs/scripts/findbugs-filter.xml\") //配置过滤文件，减少不必要的检查\n    classes = files(\"${project.buildDir}/intermediates/classes/\")//默认分析的class文件对象\n    ...\n}\n\n```\n\n结合[findbugs-plugin](https://github.com/jenkinsci/findbugs-plugin)的源码可知，只要获取[hudson.plugins.findbugs.FindBugsResultAction](https://github.com/jenkinsci/findbugs-plugin/blob/master/plugin/src/main/java/hudson/plugins/findbugs/FindBugsResultAction.java)对应的`Action`实例，就可以得到分析结果。最后，在邮件中的显示结果如图：\n\n![](https://nos.netease.com/popo/743676cae801faeb937ab0e828fb4476.jpg)\n\n点击链接地址，同样跳转到`FindBugs`的图文界面。\n\n![](https://nos.netease.com/popo/610530e913c4ab0f321321c359ea9f53.jpg)\n\n### 1.2.4 动态集成自定义的gradle任务方案\n\n在项目持续集成时，我们需要添加一些自定义的任务，但是又要尽量避免修改用户的项目代码。因此，本文采用了一个比较折中的方案：\n在`Jenkins`的根目录下建一个`configs`文件夹，放置一些项目构建过程使用的第三方库、脚本以及配置文件等；然后在项目构建之前，通过执行`Job`配置页的脚本将该文件夹及其内容复制到目标构建项目的工作空间中，同时修改项目的`build.gradle`文件；最后在项目构建过程中，调用这些第三方库、脚本以及配置文件，来完成自定义的额外的构建任务。\n\n`FindBugs`任务的集成就应用了上述方案，后续介绍的`FireLine`集成以及`Apk`大小、方法数和资源文件统计的集成亦是如此。\n\n例如，修改`build.gradle`文件，动态引入`jenkins.gradle`文件：\n\n```\ngroovy\nproject(':app') { //在项目的主moudle（一般默认是app）中引用构建相关的gradle脚本\n    apply from: rootProject.getRootDir().getAbsolutePath() + '/configs/scripts/jenkins.gradle'\n    ...\n}\n\n```\n\n### 1.2.5 FireLine\n\nFireLine 提供一种静态代码（指`java`源码，后来据说又支持`class`文件）扫描服务，基于`PMD`开源。它是360公司针对自己的产品定制的安全检查规则，使用这些规则对源代码进行扫描检测，找出代码潜在的安全风险。目前，对外也可以使用。因此，本文对该工具进行了集成。\n\nFireLine 对外提供一个`jar`包，必须通过命令行的形式运行，因此需要添加一个`fireLine`的任务：\n\n```\ngroovy\n//扫描java源码，需指定扫描对象以及结果存储位置\ntask fireLine << {\n    def fireLineDir=env.JENKINS_HOME+\"/jobs/\"+env.JOB_NAME+\"/builds/\"+env.BUILD_NUMBER+\"/\"\n    exec {\n        workingDir './'\n        //命令行执行jar包\n        commandLine \"java\", \"-jar\", \"${project.rootDir}/configs/jars/fireline.jar\", \"scanSrcDir=\"+env.WORKSPACE, \"reportSaveDir=\"+fireLineDir,\"reportFileName=fireLineResult\",\"user=netease\"\n    }\n    ...\n}\n```\n构建后，检查结果在邮件中显示如图：\n\n![](https://nos.netease.com/popo/70d4c25e2675849aa5b760c258ad655e.jpg)\n\n点击链接地址，跳转到需要`HTML Publisher Plugin`支持的火线检查的详细界面：\n\n![](https://nos.netease.com/popo/8ad710117b1e3f862f24d23b783fde84.jpg)\n\n注意，若`FireLine`报告不能正常显示，这是由于它使用了`JavaScript`，这里需要设置`jenkins`允许脚本执行（`allow-scripts`），需要在系统设置页的`Jenkins Script Console`选项中输入命令：\n\n ```\n System.setProperty(\"hudson.model.DirectoryBrowserSupport.CSP\", \"\") \n \n ```\n  \n并执行，从而修改`Jenkins`的默认配置参数，然后重新构建项目即可。\n\n### 1.2.6 Apk方法数、大小以及资源文件分析\n\n随着项目的不断迭代更新，`android`应用不得不面对`64k`方法数限制、`Apk`体积不断变大的问题。因此，本次实践中将对该类数据进行收集分析，更加直观的展现给关注该类信息的用户。\n\n#### 1.2.6.1 Apk方法数、大小统计\n\n在Apk方法数统计集成中，采用了开源的`Gradle`插件项目-[dexcount-gradle-plugin](https://github.com/KeepSafe/dexcount-gradle-plugin)，该插件会根据配置为打包的每个`Apk`文件生成一份方法数统计的文件。\n\n```groovy\nbuildscript {\n    repositories {\n        mavenCentral() // or jcenter()\n    }\n    dependencies {\n        classpath 'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.6.1'\n    }\n}\n\n// make sure this line comes *after* you apply the Android plugin\napply plugin: 'com.getkeepsafe.dexcount'\n```\n配置完成后，执行`assemble`任务时，会在`app/build/outputs`目录下生成`apk`方法数统计数据文件：\n\n![]( https://nos.netease.com/popo/c139efda8d19abae9869aadc6fdb044b.jpg)\n\n因此，在本次`jenkins-ci`实践中，我们需要做就是在构建项目中动态添加该插件，并将该插件生成的统计数据进行收集、转换。\n\n和集成`findbugs`插件不同的是，这里还需要动态修改`app`项目的`buildscript`对象，并保证该插件是在`com.android.application`之后被应用。\n\n```groovy\n//动态修改`app`项目的`buildscript`对象\nproject(':app') {\n    apply from: rootProject.getRootDir().getAbsolutePath() + '/configs/scripts/buildscript.gradle', to: buildscript\n    ...\n}\n```\n并通过调用`gradle`中的`PluginManager`对象的`void withPlugin(String id, Action<? super AppliedPlugin> action)`方法，来监听插件的添加事件。当`com.android.application`插件被添加时，就可以动态添加`dexcount-gradle-plugin`插件。\n\n```groovy\npluginManager.withPlugin(\"com.android.application\", new Action<AppliedPlugin>() {\n    void execute(AppliedPlugin appliedPlugin) {\n        project(':app') { //主module名称\n            apply plugin: 'com.getkeepsafe.dexcount' //引入apk方法数统计插件\n            apply plugin: \"com.netease.hearttouch.resourcesize\" //引入资源文件统计插件\n            ...\n        }\n    }\n})\n```\n最后，为了在`jenkins`中使用该数据，创建一个`apkMethodCounts`任务将上述的所有的`json`格式文件进行统一解析转换，并将解析结果和生成的`Apk`文件--对应起来。构建结果如图：\n\n![](https://nos.netease.com/popo/ab6fd8a20b0836902c48f3d02ddec216.jpg)\n\n#### 1.2.6.2 资源文件大小统计\n\n资源文件统计插件[resource-size-plugin](https://g.hz.netease.com/hearttouch-android/resource_size_plugin)与`dexcount-gradle-plugin`的使用方法基本一致，该插件也是需要通过动态添加。\n\n插件配置完成后，执行`resourcesize`任务，会在`app/build/outputs`目录下生成分析结果`resoucesize.txt`。其中，第一行表示所有资源文件的总大小，后面每行代表单个文件最大的文件名称以及文件大小：\n\n![](https://nos.netease.com/popo/d900de430614c344379c01aad3af8c98.jpg?imageView&thumbnail=500x300)\n\n最后，将数据进行简单处理，在`jenkins`的构建结果中显示如图：\n\n![]( https://nos.netease.com/popo/5571e696f32a9e23bf86ce558ab0d22a.jpg?imageView&thumbnail=0x400)\n\n### 1.2.7 Git Changelog分析\n\n随着项目的迭代，代码的提交越来越频繁，代码的管理显得越来越重要。而`commit message`是开发者是对自己所提交代码的唯一说明，它能够直接反映开发者的意图，并方便快速查询和浏览，是必不可少的。在这些`commit message`中，比较重要的主要有`feature`（新功能）和`bug fix`（问题修复）两种类型，也是一个产品的关注点。\n\n因此，为了在构建中提取该类信息，在参考网上的一些`Git`规范的基础上，整理出一份[Git提交规范](https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md)，规定了完整的`git`提交日志由信息头部、信息主体和信息尾部构成，其中信息头部需要包含类型、范围和主题三类信息。\n\n```xml\n<type>(<scope>):<subject>\n 空行\n<body>\n 空行\n<footer>\n```\n详细规范描述可参考[规范文档](https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md)。另外，[Commitizen](https://github.com/commitizen/cz-cli)是一个撰写合格`Commit message`的工具，很好用，推荐～。使用该工提交代码之后，会自动生成上述格式规范的日志信息。\n\n通过`Commitizen`工具（或者手动）提交之后，在`GitLab`上生成的`Commit message`如图：\n\n![](https://nos.netease.com/popo/1de9a4ecf80b34eefcbfcaed7d8f271e.jpg)\n\n从图中的示例可以看出，两个`Commit message`的类型是`feature`和`bug fix`的，因此`Jenkins`构建的过程中需要进行处理并显示给用户。\n￼\n![]( https://nos.netease.com/popo/f4d85368b1fdf419de676e7dec91aac4.jpg)\n\n另外，为了能够解析`bug fix`类型提交中的`jira`上的问题并生成跳转链接，需要在项目根目录下添加一个`jenkins.xml`文件，示例如下：\n\n```xml\n<jenkins>\n<jira>\n        <url>http://jira.netease.com/projects/MINIFIVE/issues/MINIFIVE-#</url> <!--#作为占位符-->\n    </jira>\n</jenkins>\n```\n综上，关于自定义`Jenkins-ci`构建通知邮件内容的部分已经介绍完了，下面我们要讲一下`Jenkins`与`Docker`结合如何实现快速配置。\n\n# 2. Jenkins与Docker结合实现快速配置\n\n[Docker](https://www.docker.com/)是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的`Linux`机器上，也可以实现虚拟化。基于`Docker`轻量级、可移植的特点，本次实践将`Jenkins-ci`的构建环境配置打包到`Docker`中，从而实现快速配置。\n\n## 2.1 Dockerfile文件配置\n\n创建一个自定义的`docker`镜像，可以通过`Dockerfile`描述文件来自动完成。`Dockerfile`文件包含了创建镜像所需要的[全部指令](http://seanlook.com/2014/11/17/dockerfile-introduction/)，可以使用`Docker build`命令来创建镜像。\n\n本文中使用的`Dockerfile`是基于`jenkinsci`开源的[jenkins](https://github.com/jenkinsci/docker)镜像，并根据需求进行了定制，部分内容如下：\n\n```\nFROM jenkins:latest  //已配好java和git环境\n...\n# Same as \"export TERM=dumb\"; prevents error \"Could not open terminal for stdout: $TERM not set\"\nENV TERM dumb\n\n#support 32 bit binary on a 64 bit system\nRUN  apt-get update && apt-get install -y lib32z1 lib32stdc++6 wget && apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n# 下载Android Sdk\n...\nRUN cd /opt && \\\n    wget ${ANDROID_SDK_URL} && \\\n    tar -xzf ${ANDROID_SDK_FILENAME} && \\\n    rm ${ANDROID_SDK_FILENAME} &&\\\n    echo y | android update sdk --no-ui --all --filter tools,platform-tools,extra-android-m2repository,android-23,build-tools-23.0.0,build-tools-23.0.1,build-tools-23.0.2,build-tools-23.0.3\n...\n\n# 拷贝JENKINS_HOME文件夹的内容至$JENKINS_HOME目录下，该文件夹与Dockerfile在同一目录，包含了jenkins ci的全部配置信\nADD JENKINS_HOME $JENKINS_HOME\n\nEXPOSE 8080\n\n```\n\n在配置文件中，我们使用`wget`命令去官方下载最新的`linux`下`android SDK`包，并配置环境，然后使用`android`命令选择和自己项目匹配的`SDK`以及工具的版本（本次打包的镜像下载了`android-23`以及系列的编译工具，用户可根据需求自行修改）。\n\n## 2.2 使用Dockerfile文件构建镜像\n\n由于`Docker`是基于`Linux`，在`Mac OS`上运行起来需要一个虚拟的`Linux`环境，它还需要若干工具支持:\n\n* VirtualBox：虚拟机，用来运行`Linux`\n* docker-machine：用来管理虚拟机\n* docker：`Docker`本身\n* docker-compose(Mac OS only)：用来管理多个`docker`容器\n* Kitematic：用来管理远程`Docker Hub`\n\n上述工具安装完毕后（推荐使用[Homebrew](http://brew.sh/)），就可以创建虚拟机，配置`docker`环境：\n\n```bash\ndocker-machine create --driver virtualbox dev   //1、创建虚拟机\n\ndocker-machine env dev    //2、查看dev信息\n\neval \"$(docker-machine env dev)\"   //3、添加到环境变量，关联当前shell\n```\n然后，进入到`Dockerfile`所在的目录，就可以执行`build`命令打包镜像：\n\n```bash\ndocker build -t [docker-image-name\\id] .\n``` \n目前，该镜像已经上传到[网易蜂巢](https://c.163.com/)，可通过一下命令获取：\n\n```bash\ndocker pull hub.c.163.com/netease163/ht-jenkinsci:latest\n```\n更多内容可参考[网易蜂巢使用指南](https://c.163.com/wiki/index.php?title=%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F)。\n综上，本次`Jenkins-ci`容器化实践就讲完了～有问题或建议可以联系我，一起交流～\n\n# 3. 参考资料\n\n * [jenkins官网](https://jenkins.io/)\n * [jenkins插件](https://wiki.jenkins-ci.org/display/JENKINS/Plugins)\n * [Jenkins集成android工程](http://wangkuiwu.github.io/2015/08/07/jenkins-02/)\n * [jenkins-ci](https://github.com/jenkinsci/jenkins)\n * [jenkins的Api文档](http://javadoc.jenkins-ci.org/overview-summary.html)\n * [Jenkins构建Android项目持续集成之findbugs的使用\n](http://itfish.net/article/53357.html)\n * [dexcount-gradle-plugin](https://github.com/KeepSafe/dexcount-gradle-plugin)\n * [FireLine](http://magic.360.cn/index.html)\n * [email-ext-plugin](https://github.com/jenkinsci/email-ext-plugin)\n * [findbugs-plugin](https://github.com/jenkinsci/findbugs-plugin)\n * [Android中使用FindBugs](https://segmentfault.com/a/1190000004881029)\n * [Commit message和Change log编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n * [git-changelog-plugin](https://github.com/paulwellnerbou/git-changelog-jenkins-plugin)\n * [持续集成之Jenkins插件使用-邮件通知模板化](http://qa.blog.163.com/blog/static/19014700220131011102715643/)\n * [搭建linux（ubuntu 14.04）下的android开发环境](http://www.qisanfen.com/?p=474)\n * [Ubuntu下全命令行搭建Android开发环境](http://qianngchn.github.io/wiki/8.html)\n * [Run Docker on your Mac](http://www.jianshu.com/p/13c132503d01)\n * [搭建Android持续集成服务器](http://developerworks.github.io/2014/09/07/android-ci-server/#%E5%AE%89%E8%A3%85Android_SDK)\n* [构建编译Android项目的Docker镜像](http://blog.saymagic.cn/2016/01/25/docker-image-for-android.html)\n* [使用docker来提升你的Jenkins](http://www.larrycaiyu.com/2014/11/04/use-docker-for-your-jenkins-demo-1.html)\n* [Setup Jenkins for Android Integration Using Docker](http://ju.outofmemory.cn/entry/145390)\n* [Mac OSX Docker下搭建Android+Jenkins+Gitlab](http://blog.csdn.net/sbsujjbcy/article/details/52215051)\n* [gitlab与jenkins协同工作](http://www.cnphp6.com/archives/115564)\n\n\n","slug":"android/Jenkins-ci容器化在Android项目构建中的应用（公众号版）","published":1,"updated":"2017-01-05T06:02:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixk0c23f00007ekkb4wnz5p0","content":"<p>随着软件开发复杂度的不断提高，如何能在不断变化的需求中快速适应和保证软件的质量显得尤其的重要，<a href=\"http://baike.baidu.com/view/5253255.htm\" target=\"_blank\" rel=\"external\">持续集成</a>正是针对这一类问题的一种软件开发实践。 <a id=\"more\"></a></p>\n<p>本文中的<code>Jenkins-ci</code>容器化方案能够在项目构建过程中提取出更多自定义的需求信息并进一步将持续集成的环境参数配置标准化。<br>因此，在项目的构建过程中，我们对用户比较关心的信息（如代码质量、<code>apk</code>方法数和大小、资源文件变化、代码提交记录等）进行跟踪、收集、分析和统计，并将结果以图表的形式在通知邮件中展现给用户，让用户对项目的迭代情况有更多的了解。</p>\n<h1 id=\"1-Jenkins配置以及构建通知邮件内容定制\"><a href=\"#1-Jenkins配置以及构建通知邮件内容定制\" class=\"headerlink\" title=\"1. Jenkins配置以及构建通知邮件内容定制\"></a>1. Jenkins配置以及构建通知邮件内容定制</h1><h2 id=\"1-1-Jenkins安装、配置与使用\"><a href=\"#1-1-Jenkins安装、配置与使用\" class=\"headerlink\" title=\"1.1 Jenkins安装、配置与使用\"></a>1.1 Jenkins安装、配置与使用</h2><p>关于详细的Jenkins安装、配置与使用说明，可参考文章<a href=\"http://wangkuiwu.github.io/2015/08/07/jenkins-01/\" target=\"_blank\" rel=\"external\">Jenkins工具(一)之 Jenkins集成android工程</a><br>和<a href=\"http://wangkuiwu.github.io/2015/08/07/jenkins-02/\" target=\"_blank\" rel=\"external\">Jenkins工具(二)之 Jenkins集成android工程</a>，文中不再详细叙述。</p>\n<p>其中，构建中使用到的插件几个主要插件：</p>\n<ul>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin\" target=\"_blank\" rel=\"external\">Git plugin</a> Git工具集成</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin\" target=\"_blank\" rel=\"external\">Gitlab Plugin</a>和<a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin\" target=\"_blank\" rel=\"external\">Gitlab Hook Plugin</a> 支持Gitlab项目构建</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Gradle+Plugin\" target=\"_blank\" rel=\"external\">Gradle plugin</a> Gradle工具集成</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+plugin\" target=\"_blank\" rel=\"external\">Email Extension Plugin</a> 构建结构邮件通知</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Git+Changelog+Plugin\" target=\"_blank\" rel=\"external\">Git Changelog Plugin</a> 获取Git提交记录</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Android+Lint+Plugin\" target=\"_blank\" rel=\"external\">Android Lint Plugin</a> 收集分析Android Lint检查结果</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/FindBugs+Plugin\" target=\"_blank\" rel=\"external\">FindBugs Plugin</a> 收集分析FindBugs检查结果</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/HTML+Publisher+Plugin\" target=\"_blank\" rel=\"external\">HTML Publisher plugin</a> 支持HTML报告</li>\n</ul>\n<h2 id=\"1-2-构建结果邮件定制\"><a href=\"#1-2-构建结果邮件定制\" class=\"headerlink\" title=\"1.2 构建结果邮件定制\"></a>1.2 构建结果邮件定制</h2><p>完成<code>Jenkins</code>的安装以及环境参数配置后，新建一个项目用于构建，项目构建完成后需要将结果内容通过邮件的方式通知用户。将构建结果通知到用户的邮件内容的定制，则是本次实践的重点。</p>\n<p>本次自动化构建将包括以下几个内容：<code>FireLine</code>（源码检查）、<code>Android Lint</code>、<code>FindBugs</code>（Class文件检查）、<code>Apk</code>包大小和方法数统计、资源文件统计，以及<code>Git commit</code>日志分析。</p>\n<h3 id=\"1-2-1-Email-Extension-配置\"><a href=\"#1-2-1-Email-Extension-配置\" class=\"headerlink\" title=\"1.2.1 Email Extension 配置\"></a>1.2.1 Email Extension 配置</h3><p>构建结果邮件内容定制依赖于前面提到的<code>Email Extension Plugin</code>，该插件目前支持<code>Jelly</code>和<code>Groovy</code>两种语法编写模板，本文的模板内容定制将采用<code>Groovy</code>（个人认为<code>Jelly</code>标签不够灵活）。同时，创建的模板文件要放在<code>Jenkins</code>根目录下的<code>email-templates</code>文件夹下。模板文件配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;SCRIPT, template=&quot;ht-ci.template&quot;&#125;</div></pre></td></tr></table></figure>\n<p>另外，想要在模板中获取构建结果信息，可以通过获取<code>Jenkins</code>环境中的<code>Action</code>对象来实现。<code>Action</code>是插件用来在<code>Job</code>或<code>Build</code>页面增加功能的一种主要方式，是<code>Jenkins</code>最常用的一个扩展点。如<code>org.jenkinsci.plugins.android_lint.LintResultAction</code>、hudson.plugins.findbugs.FindBugsResultAction等，后文将多次用到。</p>\n<h3 id=\"1-2-2-Android-Lint\"><a href=\"#1-2-2-Android-Lint\" class=\"headerlink\" title=\"1.2.2 Android Lint\"></a>1.2.2 Android Lint</h3><p><code>Android Lint</code>是一个静态代码分析工具，它能够对你的<code>Android</code>项目中潜在的<code>bug</code>、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。支持自定义Lint规则，可参考文章<a href=\"http://carrotsight.com/2016/01/29/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%80%EF%BC%89.html\" target=\"_blank\" rel=\"external\">浅谈Android自定义Lint规则的实现 （一）</a>、<a href=\"http://carrotsight.com/2016/02/01/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89.html\" target=\"_blank\" rel=\"external\">浅谈Android自定义Lint规则的实现 （二）</a>。</p>\n<p>安装插件<code>Android Lint Plugin</code>后，进入项目的配置页，并添加构建后操作<code>Publish Android Lint results</code>，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在<code>Invoke Gradle Script</code>的<code>Task</code>中添加对应的<code>lint</code>检查任务。</p>\n<p>通过阅读<a href=\"https://github.com/jenkinsci/android-lint-plugin\" target=\"_blank\" rel=\"external\"> android-lint-plugin </a>的源码可知，只要获取<a href=\"https://github.com/jenkinsci/android-lint-plugin/blob/8e88de5c9ec2f2d58bf0965592f6ffed040f0542/src/main/java/org/jenkinsci/plugins/android_lint/LintResultAction.java\" target=\"_blank\" rel=\"external\">org.jenkinsci.plugins.android_lint.LintResultAction</a>对应的<code>Action</code>实例，就可以得到<code>lint</code>检查的数据。</p>\n<p>最终，邮件中的显示结果如图：</p>\n<p><img src=\"https://nos.netease.com/popo/9da8a7374fe8ba7f4b91e78acb27392e.jpg\" alt=\"\"></p>\n<p>点击链接地址，会跳转到<code>Lint Issues</code>的包含图文描述的界面，如图：</p>\n<p><img src=\"http://nos.netease.com/knowledge/e8b39b38-131f-4043-9178-3fc8ad4861c1\" alt=\"Lint Issues\"> </p>\n<p>不过需要注意的是，默认情况下，在<code>Gradle</code>插件<code>com.android.application</code>的<code>android</code>对象中，<code>lintOptions</code>的<code>abortOnError</code>参数为<code>true</code>，在执行<code>lint</code>命令时，遇到错误即中止构建。因此，若希望<code>lint</code>执行出错后继续构建，则需要将该参数置为<code>false</code>，可以在<code>build.gradle</code>文件中动态修改：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">afterEvaluate &#123; project -&gt;</div><div class=\"line\">    <span class=\"keyword\">if</span> (project.properties.containsKey(<span class=\"string\">'android'</span>)) &#123; <span class=\"comment\">//针对android应用和android库项目</span></div><div class=\"line\">        project.android.lintOptions.abortOnError <span class=\"literal\">false</span> <span class=\"comment\">//禁止遇到错误中止构建  </span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<h3 id=\"1-2-3-FindBugs\"><a href=\"#1-2-3-FindBugs\" class=\"headerlink\" title=\"1.2.3 FindBugs\"></a>1.2.3 FindBugs</h3><p><a href=\"https://zh.wikipedia.org/wiki/FindBugs\" target=\"_blank\" rel=\"external\">Findbugs</a>是一个静态分析工具，用来查找<code>Java</code>代码中的程序错误，将字节码与一组缺陷模式进行对比以发现可能的问题，并根据其可能产生的影响或严重程度，而对开发者的提示。并且，这组缺陷模式是可配置的，通过配置可以过滤掉一些我们不想或不需要检测的问题。</p>\n<p><code>FindBugs</code>和<code>Android Lint</code>的集成方式基本一致。在安装插件<code>FindBugs Plugin</code>后，进入项目配置页，并添加构建后操作<code>Publish FindBugs analysis results</code>，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在<code>Invoke Gradle Script</code>的<code>Task</code>中添加对应的<code>findbugs</code>检查任务。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//findbugs插件</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'findbugs'</span> </div><div class=\"line\">task findbugs(<span class=\"string\">type:</span> FindBugs, <span class=\"string\">dependsOn:</span> <span class=\"string\">'assembleDebug'</span>) &#123;<span class=\"comment\">//依赖Debug打包所产生的class文件</span></div><div class=\"line\">    ...</div><div class=\"line\">    excludeFilter = file(<span class=\"string\">\"$&#123;project.rootDir&#125;/configs/scripts/findbugs-filter.xml\"</span>) <span class=\"comment\">//配置过滤文件，减少不必要的检查</span></div><div class=\"line\">    classes = files(<span class=\"string\">\"$&#123;project.buildDir&#125;/intermediates/classes/\"</span>)<span class=\"comment\">//默认分析的class文件对象</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结合<a href=\"https://github.com/jenkinsci/findbugs-plugin\" target=\"_blank\" rel=\"external\">findbugs-plugin</a>的源码可知，只要获取<a href=\"https://github.com/jenkinsci/findbugs-plugin/blob/master/plugin/src/main/java/hudson/plugins/findbugs/FindBugsResultAction.java\" target=\"_blank\" rel=\"external\">hudson.plugins.findbugs.FindBugsResultAction</a>对应的<code>Action</code>实例，就可以得到分析结果。最后，在邮件中的显示结果如图：</p>\n<p><img src=\"https://nos.netease.com/popo/743676cae801faeb937ab0e828fb4476.jpg\" alt=\"\"></p>\n<p>点击链接地址，同样跳转到<code>FindBugs</code>的图文界面。</p>\n<p><img src=\"https://nos.netease.com/popo/610530e913c4ab0f321321c359ea9f53.jpg\" alt=\"\"></p>\n<h3 id=\"1-2-4-动态集成自定义的gradle任务方案\"><a href=\"#1-2-4-动态集成自定义的gradle任务方案\" class=\"headerlink\" title=\"1.2.4 动态集成自定义的gradle任务方案\"></a>1.2.4 动态集成自定义的gradle任务方案</h3><p>在项目持续集成时，我们需要添加一些自定义的任务，但是又要尽量避免修改用户的项目代码。因此，本文采用了一个比较折中的方案：<br>在<code>Jenkins</code>的根目录下建一个<code>configs</code>文件夹，放置一些项目构建过程使用的第三方库、脚本以及配置文件等；然后在项目构建之前，通过执行<code>Job</code>配置页的脚本将该文件夹及其内容复制到目标构建项目的工作空间中，同时修改项目的<code>build.gradle</code>文件；最后在项目构建过程中，调用这些第三方库、脚本以及配置文件，来完成自定义的额外的构建任务。</p>\n<p><code>FindBugs</code>任务的集成就应用了上述方案，后续介绍的<code>FireLine</code>集成以及<code>Apk</code>大小、方法数和资源文件统计的集成亦是如此。</p>\n<p>例如，修改<code>build.gradle</code>文件，动态引入<code>jenkins.gradle</code>文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">groovy</div><div class=\"line\">project(&apos;:app&apos;) &#123; //在项目的主moudle（一般默认是app）中引用构建相关的gradle脚本</div><div class=\"line\">    apply from: rootProject.getRootDir().getAbsolutePath() + &apos;/configs/scripts/jenkins.gradle&apos;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"1-2-5-FireLine\"><a href=\"#1-2-5-FireLine\" class=\"headerlink\" title=\"1.2.5 FireLine\"></a>1.2.5 FireLine</h3><p>FireLine 提供一种静态代码（指<code>java</code>源码，后来据说又支持<code>class</code>文件）扫描服务，基于<code>PMD</code>开源。它是360公司针对自己的产品定制的安全检查规则，使用这些规则对源代码进行扫描检测，找出代码潜在的安全风险。目前，对外也可以使用。因此，本文对该工具进行了集成。</p>\n<p>FireLine 对外提供一个<code>jar</code>包，必须通过命令行的形式运行，因此需要添加一个<code>fireLine</code>的任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">groovy</div><div class=\"line\">//扫描java源码，需指定扫描对象以及结果存储位置</div><div class=\"line\">task fireLine &lt;&lt; &#123;</div><div class=\"line\">    def fireLineDir=env.JENKINS_HOME+&quot;/jobs/&quot;+env.JOB_NAME+&quot;/builds/&quot;+env.BUILD_NUMBER+&quot;/&quot;</div><div class=\"line\">    exec &#123;</div><div class=\"line\">        workingDir &apos;./&apos;</div><div class=\"line\">        //命令行执行jar包</div><div class=\"line\">        commandLine &quot;java&quot;, &quot;-jar&quot;, &quot;$&#123;project.rootDir&#125;/configs/jars/fireline.jar&quot;, &quot;scanSrcDir=&quot;+env.WORKSPACE, &quot;reportSaveDir=&quot;+fireLineDir,&quot;reportFileName=fireLineResult&quot;,&quot;user=netease&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构建后，检查结果在邮件中显示如图：</p>\n<p><img src=\"https://nos.netease.com/popo/70d4c25e2675849aa5b760c258ad655e.jpg\" alt=\"\"></p>\n<p>点击链接地址，跳转到需要<code>HTML Publisher Plugin</code>支持的火线检查的详细界面：</p>\n<p><img src=\"https://nos.netease.com/popo/8ad710117b1e3f862f24d23b783fde84.jpg\" alt=\"\"></p>\n<p>注意，若<code>FireLine</code>报告不能正常显示，这是由于它使用了<code>JavaScript</code>，这里需要设置<code>jenkins</code>允许脚本执行（<code>allow-scripts</code>），需要在系统设置页的<code>Jenkins Script Console</code>选项中输入命令：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;)</div></pre></td></tr></table></figure>\n<p>并执行，从而修改<code>Jenkins</code>的默认配置参数，然后重新构建项目即可。</p>\n<h3 id=\"1-2-6-Apk方法数、大小以及资源文件分析\"><a href=\"#1-2-6-Apk方法数、大小以及资源文件分析\" class=\"headerlink\" title=\"1.2.6 Apk方法数、大小以及资源文件分析\"></a>1.2.6 Apk方法数、大小以及资源文件分析</h3><p>随着项目的不断迭代更新，<code>android</code>应用不得不面对<code>64k</code>方法数限制、<code>Apk</code>体积不断变大的问题。因此，本次实践中将对该类数据进行收集分析，更加直观的展现给关注该类信息的用户。</p>\n<h4 id=\"1-2-6-1-Apk方法数、大小统计\"><a href=\"#1-2-6-1-Apk方法数、大小统计\" class=\"headerlink\" title=\"1.2.6.1 Apk方法数、大小统计\"></a>1.2.6.1 Apk方法数、大小统计</h4><p>在Apk方法数统计集成中，采用了开源的<code>Gradle</code>插件项目-<a href=\"https://github.com/KeepSafe/dexcount-gradle-plugin\" target=\"_blank\" rel=\"external\">dexcount-gradle-plugin</a>，该插件会根据配置为打包的每个<code>Apk</code>文件生成一份方法数统计的文件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">buildscript &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenCentral() <span class=\"comment\">// or jcenter()</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    dependencies &#123;</div><div class=\"line\">        classpath <span class=\"string\">'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.6.1'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// make sure this line comes *after* you apply the Android plugin</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.getkeepsafe.dexcount'</span></div></pre></td></tr></table></figure>\n<p>配置完成后，执行<code>assemble</code>任务时，会在<code>app/build/outputs</code>目录下生成<code>apk</code>方法数统计数据文件：</p>\n<p><img src=\"https://nos.netease.com/popo/c139efda8d19abae9869aadc6fdb044b.jpg\" alt=\"\"></p>\n<p>因此，在本次<code>jenkins-ci</code>实践中，我们需要做就是在构建项目中动态添加该插件，并将该插件生成的统计数据进行收集、转换。</p>\n<p>和集成<code>findbugs</code>插件不同的是，这里还需要动态修改<code>app</code>项目的<code>buildscript</code>对象，并保证该插件是在<code>com.android.application</code>之后被应用。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//动态修改`app`项目的`buildscript`对象</span></div><div class=\"line\">project(<span class=\"string\">':app'</span>) &#123;</div><div class=\"line\">    apply <span class=\"string\">from:</span> rootProject.getRootDir().getAbsolutePath() + <span class=\"string\">'/configs/scripts/buildscript.gradle'</span>, <span class=\"string\">to:</span> buildscript</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并通过调用<code>gradle</code>中的<code>PluginManager</code>对象的<code>void withPlugin(String id, Action&lt;? super AppliedPlugin&gt; action)</code>方法，来监听插件的添加事件。当<code>com.android.application</code>插件被添加时，就可以动态添加<code>dexcount-gradle-plugin</code>插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pluginManager.withPlugin(<span class=\"string\">\"com.android.application\"</span>, <span class=\"keyword\">new</span> Action&lt;AppliedPlugin&gt;() &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> execute(AppliedPlugin appliedPlugin) &#123;</div><div class=\"line\">        project(<span class=\"string\">':app'</span>) &#123; <span class=\"comment\">//主module名称</span></div><div class=\"line\">            apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.getkeepsafe.dexcount'</span> <span class=\"comment\">//引入apk方法数统计插件</span></div><div class=\"line\">            apply <span class=\"string\">plugin:</span> <span class=\"string\">\"com.netease.hearttouch.resourcesize\"</span> <span class=\"comment\">//引入资源文件统计插件</span></div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>最后，为了在<code>jenkins</code>中使用该数据，创建一个<code>apkMethodCounts</code>任务将上述的所有的<code>json</code>格式文件进行统一解析转换，并将解析结果和生成的<code>Apk</code>文件–对应起来。构建结果如图：</p>\n<p><img src=\"https://nos.netease.com/popo/ab6fd8a20b0836902c48f3d02ddec216.jpg\" alt=\"\"></p>\n<h4 id=\"1-2-6-2-资源文件大小统计\"><a href=\"#1-2-6-2-资源文件大小统计\" class=\"headerlink\" title=\"1.2.6.2 资源文件大小统计\"></a>1.2.6.2 资源文件大小统计</h4><p>资源文件统计插件<a href=\"https://g.hz.netease.com/hearttouch-android/resource_size_plugin\" target=\"_blank\" rel=\"external\">resource-size-plugin</a>与<code>dexcount-gradle-plugin</code>的使用方法基本一致，该插件也是需要通过动态添加。</p>\n<p>插件配置完成后，执行<code>resourcesize</code>任务，会在<code>app/build/outputs</code>目录下生成分析结果<code>resoucesize.txt</code>。其中，第一行表示所有资源文件的总大小，后面每行代表单个文件最大的文件名称以及文件大小：</p>\n<p><img src=\"https://nos.netease.com/popo/d900de430614c344379c01aad3af8c98.jpg?imageView&amp;thumbnail=500x300\" alt=\"\"></p>\n<p>最后，将数据进行简单处理，在<code>jenkins</code>的构建结果中显示如图：</p>\n<p><img src=\"https://nos.netease.com/popo/5571e696f32a9e23bf86ce558ab0d22a.jpg?imageView&amp;thumbnail=0x400\" alt=\"\"></p>\n<h3 id=\"1-2-7-Git-Changelog分析\"><a href=\"#1-2-7-Git-Changelog分析\" class=\"headerlink\" title=\"1.2.7 Git Changelog分析\"></a>1.2.7 Git Changelog分析</h3><p>随着项目的迭代，代码的提交越来越频繁，代码的管理显得越来越重要。而<code>commit message</code>是开发者是对自己所提交代码的唯一说明，它能够直接反映开发者的意图，并方便快速查询和浏览，是必不可少的。在这些<code>commit message</code>中，比较重要的主要有<code>feature</code>（新功能）和<code>bug fix</code>（问题修复）两种类型，也是一个产品的关注点。</p>\n<p>因此，为了在构建中提取该类信息，在参考网上的一些<code>Git</code>规范的基础上，整理出一份<a href=\"https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md\" target=\"_blank\" rel=\"external\">Git提交规范</a>，规定了完整的<code>git</code>提交日志由信息头部、信息主体和信息尾部构成，其中信息头部需要包含类型、范围和主题三类信息。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>(<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>):<span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span></div><div class=\"line\"> 空行</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"> 空行</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>详细规范描述可参考<a href=\"https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md\" target=\"_blank\" rel=\"external\">规范文档</a>。另外，<a href=\"https://github.com/commitizen/cz-cli\" target=\"_blank\" rel=\"external\">Commitizen</a>是一个撰写合格<code>Commit message</code>的工具，很好用，推荐～。使用该工提交代码之后，会自动生成上述格式规范的日志信息。</p>\n<p>通过<code>Commitizen</code>工具（或者手动）提交之后，在<code>GitLab</code>上生成的<code>Commit message</code>如图：</p>\n<p><img src=\"https://nos.netease.com/popo/1de9a4ecf80b34eefcbfcaed7d8f271e.jpg\" alt=\"\"></p>\n<p>从图中的示例可以看出，两个<code>Commit message</code>的类型是<code>feature</code>和<code>bug fix</code>的，因此<code>Jenkins</code>构建的过程中需要进行处理并显示给用户。<br>￼<br><img src=\"https://nos.netease.com/popo/f4d85368b1fdf419de676e7dec91aac4.jpg\" alt=\"\"></p>\n<p>另外，为了能够解析<code>bug fix</code>类型提交中的<code>jira</code>上的问题并生成跳转链接，需要在项目根目录下添加一个<code>jenkins.xml</code>文件，示例如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jenkins</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jira</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://jira.netease.com/projects/MINIFIVE/issues/MINIFIVE-#<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span> <span class=\"comment\">&lt;!--#作为占位符--&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">jira</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">jenkins</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>综上，关于自定义<code>Jenkins-ci</code>构建通知邮件内容的部分已经介绍完了，下面我们要讲一下<code>Jenkins</code>与<code>Docker</code>结合如何实现快速配置。</p>\n<h1 id=\"2-Jenkins与Docker结合实现快速配置\"><a href=\"#2-Jenkins与Docker结合实现快速配置\" class=\"headerlink\" title=\"2. Jenkins与Docker结合实现快速配置\"></a>2. Jenkins与Docker结合实现快速配置</h1><p><a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"external\">Docker</a>是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的<code>Linux</code>机器上，也可以实现虚拟化。基于<code>Docker</code>轻量级、可移植的特点，本次实践将<code>Jenkins-ci</code>的构建环境配置打包到<code>Docker</code>中，从而实现快速配置。</p>\n<h2 id=\"2-1-Dockerfile文件配置\"><a href=\"#2-1-Dockerfile文件配置\" class=\"headerlink\" title=\"2.1 Dockerfile文件配置\"></a>2.1 Dockerfile文件配置</h2><p>创建一个自定义的<code>docker</code>镜像，可以通过<code>Dockerfile</code>描述文件来自动完成。<code>Dockerfile</code>文件包含了创建镜像所需要的<a href=\"http://seanlook.com/2014/11/17/dockerfile-introduction/\" target=\"_blank\" rel=\"external\">全部指令</a>，可以使用<code>Docker build</code>命令来创建镜像。</p>\n<p>本文中使用的<code>Dockerfile</code>是基于<code>jenkinsci</code>开源的<a href=\"https://github.com/jenkinsci/docker\" target=\"_blank\" rel=\"external\">jenkins</a>镜像，并根据需求进行了定制，部分内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM jenkins:latest  //已配好java和git环境</div><div class=\"line\">...</div><div class=\"line\"># Same as &quot;export TERM=dumb&quot;; prevents error &quot;Could not open terminal for stdout: $TERM not set&quot;</div><div class=\"line\">ENV TERM dumb</div><div class=\"line\"></div><div class=\"line\">#support 32 bit binary on a 64 bit system</div><div class=\"line\">RUN  apt-get update &amp;&amp; apt-get install -y lib32z1 lib32stdc++6 wget &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</div><div class=\"line\"></div><div class=\"line\"># 下载Android Sdk</div><div class=\"line\">...</div><div class=\"line\">RUN cd /opt &amp;&amp; \\</div><div class=\"line\">    wget $&#123;ANDROID_SDK_URL&#125; &amp;&amp; \\</div><div class=\"line\">    tar -xzf $&#123;ANDROID_SDK_FILENAME&#125; &amp;&amp; \\</div><div class=\"line\">    rm $&#123;ANDROID_SDK_FILENAME&#125; &amp;&amp;\\</div><div class=\"line\">    echo y | android update sdk --no-ui --all --filter tools,platform-tools,extra-android-m2repository,android-23,build-tools-23.0.0,build-tools-23.0.1,build-tools-23.0.2,build-tools-23.0.3</div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\"># 拷贝JENKINS_HOME文件夹的内容至$JENKINS_HOME目录下，该文件夹与Dockerfile在同一目录，包含了jenkins ci的全部配置信</div><div class=\"line\">ADD JENKINS_HOME $JENKINS_HOME</div><div class=\"line\"></div><div class=\"line\">EXPOSE 8080</div></pre></td></tr></table></figure>\n<p>在配置文件中，我们使用<code>wget</code>命令去官方下载最新的<code>linux</code>下<code>android SDK</code>包，并配置环境，然后使用<code>android</code>命令选择和自己项目匹配的<code>SDK</code>以及工具的版本（本次打包的镜像下载了<code>android-23</code>以及系列的编译工具，用户可根据需求自行修改）。</p>\n<h2 id=\"2-2-使用Dockerfile文件构建镜像\"><a href=\"#2-2-使用Dockerfile文件构建镜像\" class=\"headerlink\" title=\"2.2 使用Dockerfile文件构建镜像\"></a>2.2 使用Dockerfile文件构建镜像</h2><p>由于<code>Docker</code>是基于<code>Linux</code>，在<code>Mac OS</code>上运行起来需要一个虚拟的<code>Linux</code>环境，它还需要若干工具支持:</p>\n<ul>\n<li>VirtualBox：虚拟机，用来运行<code>Linux</code></li>\n<li>docker-machine：用来管理虚拟机</li>\n<li>docker：<code>Docker</code>本身</li>\n<li>docker-compose(Mac OS only)：用来管理多个<code>docker</code>容器</li>\n<li>Kitematic：用来管理远程<code>Docker Hub</code></li>\n</ul>\n<p>上述工具安装完毕后（推荐使用<a href=\"http://brew.sh/\" target=\"_blank\" rel=\"external\">Homebrew</a>），就可以创建虚拟机，配置<code>docker</code>环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker-machine create --driver virtualbox dev   //1、创建虚拟机</div><div class=\"line\"></div><div class=\"line\">docker-machine env dev    //2、查看dev信息</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(docker-machine env dev)</span>\"</span>   //3、添加到环境变量，关联当前shell</div></pre></td></tr></table></figure>\n<p>然后，进入到<code>Dockerfile</code>所在的目录，就可以执行<code>build</code>命令打包镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker build -t [docker-image-name\\id] .</div><div class=\"line\">``` </div><div class=\"line\">目前，该镜像已经上传到[网易蜂巢](https://c.163.com/)，可通过一下命令获取：</div><div class=\"line\"></div><div class=\"line\">```bash</div><div class=\"line\">docker pull hub.c.163.com/netease163/ht-jenkinsci:latest</div></pre></td></tr></table></figure>\n<p>更多内容可参考<a href=\"https://c.163.com/wiki/index.php?title=%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F\" target=\"_blank\" rel=\"external\">网易蜂巢使用指南</a>。<br>综上，本次<code>Jenkins-ci</code>容器化实践就讲完了～有问题或建议可以联系我，一起交流～</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3. 参考资料\"></a>3. 参考资料</h1><ul>\n<li><a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"external\">jenkins官网</a></li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Plugins\" target=\"_blank\" rel=\"external\">jenkins插件</a></li>\n<li><a href=\"http://wangkuiwu.github.io/2015/08/07/jenkins-02/\" target=\"_blank\" rel=\"external\">Jenkins集成android工程</a></li>\n<li><a href=\"https://github.com/jenkinsci/jenkins\" target=\"_blank\" rel=\"external\">jenkins-ci</a></li>\n<li><a href=\"http://javadoc.jenkins-ci.org/overview-summary.html\" target=\"_blank\" rel=\"external\">jenkins的Api文档</a></li>\n<li><a href=\"http://itfish.net/article/53357.html\" target=\"_blank\" rel=\"external\">Jenkins构建Android项目持续集成之findbugs的使用\n</a></li>\n<li><a href=\"https://github.com/KeepSafe/dexcount-gradle-plugin\" target=\"_blank\" rel=\"external\">dexcount-gradle-plugin</a></li>\n<li><a href=\"http://magic.360.cn/index.html\" target=\"_blank\" rel=\"external\">FireLine</a></li>\n<li><a href=\"https://github.com/jenkinsci/email-ext-plugin\" target=\"_blank\" rel=\"external\">email-ext-plugin</a></li>\n<li><a href=\"https://github.com/jenkinsci/findbugs-plugin\" target=\"_blank\" rel=\"external\">findbugs-plugin</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004881029\" target=\"_blank\" rel=\"external\">Android中使用FindBugs</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"external\">Commit message和Change log编写指南</a></li>\n<li><a href=\"https://github.com/paulwellnerbou/git-changelog-jenkins-plugin\" target=\"_blank\" rel=\"external\">git-changelog-plugin</a></li>\n<li><a href=\"http://qa.blog.163.com/blog/static/19014700220131011102715643/\" target=\"_blank\" rel=\"external\">持续集成之Jenkins插件使用-邮件通知模板化</a></li>\n<li><a href=\"http://www.qisanfen.com/?p=474\" target=\"_blank\" rel=\"external\">搭建linux（ubuntu 14.04）下的android开发环境</a></li>\n<li><a href=\"http://qianngchn.github.io/wiki/8.html\" target=\"_blank\" rel=\"external\">Ubuntu下全命令行搭建Android开发环境</a></li>\n<li><a href=\"http://www.jianshu.com/p/13c132503d01\" target=\"_blank\" rel=\"external\">Run Docker on your Mac</a></li>\n<li><a href=\"http://developerworks.github.io/2014/09/07/android-ci-server/#%E5%AE%89%E8%A3%85Android_SDK\" target=\"_blank\" rel=\"external\">搭建Android持续集成服务器</a><ul>\n<li><a href=\"http://blog.saymagic.cn/2016/01/25/docker-image-for-android.html\" target=\"_blank\" rel=\"external\">构建编译Android项目的Docker镜像</a></li>\n<li><a href=\"http://www.larrycaiyu.com/2014/11/04/use-docker-for-your-jenkins-demo-1.html\" target=\"_blank\" rel=\"external\">使用docker来提升你的Jenkins</a></li>\n<li><a href=\"http://ju.outofmemory.cn/entry/145390\" target=\"_blank\" rel=\"external\">Setup Jenkins for Android Integration Using Docker</a></li>\n<li><a href=\"http://blog.csdn.net/sbsujjbcy/article/details/52215051\" target=\"_blank\" rel=\"external\">Mac OSX Docker下搭建Android+Jenkins+Gitlab</a></li>\n<li><a href=\"http://www.cnphp6.com/archives/115564\" target=\"_blank\" rel=\"external\">gitlab与jenkins协同工作</a></li>\n</ul>\n</li>\n</ul>\n","excerpt":"<p>随着软件开发复杂度的不断提高，如何能在不断变化的需求中快速适应和保证软件的质量显得尤其的重要，<a href=\"http://baike.baidu.com/view/5253255.htm\">持续集成</a>正是针对这一类问题的一种软件开发实践。","more":"</p>\n<p>本文中的<code>Jenkins-ci</code>容器化方案能够在项目构建过程中提取出更多自定义的需求信息并进一步将持续集成的环境参数配置标准化。<br>因此，在项目的构建过程中，我们对用户比较关心的信息（如代码质量、<code>apk</code>方法数和大小、资源文件变化、代码提交记录等）进行跟踪、收集、分析和统计，并将结果以图表的形式在通知邮件中展现给用户，让用户对项目的迭代情况有更多的了解。</p>\n<h1 id=\"1-Jenkins配置以及构建通知邮件内容定制\"><a href=\"#1-Jenkins配置以及构建通知邮件内容定制\" class=\"headerlink\" title=\"1. Jenkins配置以及构建通知邮件内容定制\"></a>1. Jenkins配置以及构建通知邮件内容定制</h1><h2 id=\"1-1-Jenkins安装、配置与使用\"><a href=\"#1-1-Jenkins安装、配置与使用\" class=\"headerlink\" title=\"1.1 Jenkins安装、配置与使用\"></a>1.1 Jenkins安装、配置与使用</h2><p>关于详细的Jenkins安装、配置与使用说明，可参考文章<a href=\"http://wangkuiwu.github.io/2015/08/07/jenkins-01/\">Jenkins工具(一)之 Jenkins集成android工程</a><br>和<a href=\"http://wangkuiwu.github.io/2015/08/07/jenkins-02/\">Jenkins工具(二)之 Jenkins集成android工程</a>，文中不再详细叙述。</p>\n<p>其中，构建中使用到的插件几个主要插件：</p>\n<ul>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin\">Git plugin</a> Git工具集成</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin\">Gitlab Plugin</a>和<a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin\">Gitlab Hook Plugin</a> 支持Gitlab项目构建</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Gradle+Plugin\">Gradle plugin</a> Gradle工具集成</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+plugin\">Email Extension Plugin</a> 构建结构邮件通知</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Git+Changelog+Plugin\">Git Changelog Plugin</a> 获取Git提交记录</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Android+Lint+Plugin\">Android Lint Plugin</a> 收集分析Android Lint检查结果</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/FindBugs+Plugin\">FindBugs Plugin</a> 收集分析FindBugs检查结果</li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/HTML+Publisher+Plugin\">HTML Publisher plugin</a> 支持HTML报告</li>\n</ul>\n<h2 id=\"1-2-构建结果邮件定制\"><a href=\"#1-2-构建结果邮件定制\" class=\"headerlink\" title=\"1.2 构建结果邮件定制\"></a>1.2 构建结果邮件定制</h2><p>完成<code>Jenkins</code>的安装以及环境参数配置后，新建一个项目用于构建，项目构建完成后需要将结果内容通过邮件的方式通知用户。将构建结果通知到用户的邮件内容的定制，则是本次实践的重点。</p>\n<p>本次自动化构建将包括以下几个内容：<code>FireLine</code>（源码检查）、<code>Android Lint</code>、<code>FindBugs</code>（Class文件检查）、<code>Apk</code>包大小和方法数统计、资源文件统计，以及<code>Git commit</code>日志分析。</p>\n<h3 id=\"1-2-1-Email-Extension-配置\"><a href=\"#1-2-1-Email-Extension-配置\" class=\"headerlink\" title=\"1.2.1 Email Extension 配置\"></a>1.2.1 Email Extension 配置</h3><p>构建结果邮件内容定制依赖于前面提到的<code>Email Extension Plugin</code>，该插件目前支持<code>Jelly</code>和<code>Groovy</code>两种语法编写模板，本文的模板内容定制将采用<code>Groovy</code>（个人认为<code>Jelly</code>标签不够灵活）。同时，创建的模板文件要放在<code>Jenkins</code>根目录下的<code>email-templates</code>文件夹下。模板文件配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;SCRIPT, template=&quot;ht-ci.template&quot;&#125;</div></pre></td></tr></table></figure>\n<p>另外，想要在模板中获取构建结果信息，可以通过获取<code>Jenkins</code>环境中的<code>Action</code>对象来实现。<code>Action</code>是插件用来在<code>Job</code>或<code>Build</code>页面增加功能的一种主要方式，是<code>Jenkins</code>最常用的一个扩展点。如<code>org.jenkinsci.plugins.android_lint.LintResultAction</code>、hudson.plugins.findbugs.FindBugsResultAction等，后文将多次用到。</p>\n<h3 id=\"1-2-2-Android-Lint\"><a href=\"#1-2-2-Android-Lint\" class=\"headerlink\" title=\"1.2.2 Android Lint\"></a>1.2.2 Android Lint</h3><p><code>Android Lint</code>是一个静态代码分析工具，它能够对你的<code>Android</code>项目中潜在的<code>bug</code>、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。支持自定义Lint规则，可参考文章<a href=\"http://carrotsight.com/2016/01/29/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%80%EF%BC%89.html\">浅谈Android自定义Lint规则的实现 （一）</a>、<a href=\"http://carrotsight.com/2016/02/01/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89.html\">浅谈Android自定义Lint规则的实现 （二）</a>。</p>\n<p>安装插件<code>Android Lint Plugin</code>后，进入项目的配置页，并添加构建后操作<code>Publish Android Lint results</code>，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在<code>Invoke Gradle Script</code>的<code>Task</code>中添加对应的<code>lint</code>检查任务。</p>\n<p>通过阅读<a href=\"https://github.com/jenkinsci/android-lint-plugin\"> android-lint-plugin </a>的源码可知，只要获取<a href=\"https://github.com/jenkinsci/android-lint-plugin/blob/8e88de5c9ec2f2d58bf0965592f6ffed040f0542/src/main/java/org/jenkinsci/plugins/android_lint/LintResultAction.java\">org.jenkinsci.plugins.android_lint.LintResultAction</a>对应的<code>Action</code>实例，就可以得到<code>lint</code>检查的数据。</p>\n<p>最终，邮件中的显示结果如图：</p>\n<p><img src=\"https://nos.netease.com/popo/9da8a7374fe8ba7f4b91e78acb27392e.jpg\" alt=\"\"></p>\n<p>点击链接地址，会跳转到<code>Lint Issues</code>的包含图文描述的界面，如图：</p>\n<p><img src=\"http://nos.netease.com/knowledge/e8b39b38-131f-4043-9178-3fc8ad4861c1\" alt=\"Lint Issues\"> </p>\n<p>不过需要注意的是，默认情况下，在<code>Gradle</code>插件<code>com.android.application</code>的<code>android</code>对象中，<code>lintOptions</code>的<code>abortOnError</code>参数为<code>true</code>，在执行<code>lint</code>命令时，遇到错误即中止构建。因此，若希望<code>lint</code>执行出错后继续构建，则需要将该参数置为<code>false</code>，可以在<code>build.gradle</code>文件中动态修改：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">afterEvaluate &#123; project -&gt;</div><div class=\"line\">    <span class=\"keyword\">if</span> (project.properties.containsKey(<span class=\"string\">'android'</span>)) &#123; <span class=\"comment\">//针对android应用和android库项目</span></div><div class=\"line\">        project.android.lintOptions.abortOnError <span class=\"literal\">false</span> <span class=\"comment\">//禁止遇到错误中止构建  </span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<h3 id=\"1-2-3-FindBugs\"><a href=\"#1-2-3-FindBugs\" class=\"headerlink\" title=\"1.2.3 FindBugs\"></a>1.2.3 FindBugs</h3><p><a href=\"https://zh.wikipedia.org/wiki/FindBugs\">Findbugs</a>是一个静态分析工具，用来查找<code>Java</code>代码中的程序错误，将字节码与一组缺陷模式进行对比以发现可能的问题，并根据其可能产生的影响或严重程度，而对开发者的提示。并且，这组缺陷模式是可配置的，通过配置可以过滤掉一些我们不想或不需要检测的问题。</p>\n<p><code>FindBugs</code>和<code>Android Lint</code>的集成方式基本一致。在安装插件<code>FindBugs Plugin</code>后，进入项目配置页，并添加构建后操作<code>Publish FindBugs analysis results</code>，根据页面提示设置参数，若不设置参数，则使用默认参数。同时，在<code>Invoke Gradle Script</code>的<code>Task</code>中添加对应的<code>findbugs</code>检查任务。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//findbugs插件</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'findbugs'</span> </div><div class=\"line\">task findbugs(<span class=\"string\">type:</span> FindBugs, <span class=\"string\">dependsOn:</span> <span class=\"string\">'assembleDebug'</span>) &#123;<span class=\"comment\">//依赖Debug打包所产生的class文件</span></div><div class=\"line\">    ...</div><div class=\"line\">    excludeFilter = file(<span class=\"string\">\"$&#123;project.rootDir&#125;/configs/scripts/findbugs-filter.xml\"</span>) <span class=\"comment\">//配置过滤文件，减少不必要的检查</span></div><div class=\"line\">    classes = files(<span class=\"string\">\"$&#123;project.buildDir&#125;/intermediates/classes/\"</span>)<span class=\"comment\">//默认分析的class文件对象</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结合<a href=\"https://github.com/jenkinsci/findbugs-plugin\">findbugs-plugin</a>的源码可知，只要获取<a href=\"https://github.com/jenkinsci/findbugs-plugin/blob/master/plugin/src/main/java/hudson/plugins/findbugs/FindBugsResultAction.java\">hudson.plugins.findbugs.FindBugsResultAction</a>对应的<code>Action</code>实例，就可以得到分析结果。最后，在邮件中的显示结果如图：</p>\n<p><img src=\"https://nos.netease.com/popo/743676cae801faeb937ab0e828fb4476.jpg\" alt=\"\"></p>\n<p>点击链接地址，同样跳转到<code>FindBugs</code>的图文界面。</p>\n<p><img src=\"https://nos.netease.com/popo/610530e913c4ab0f321321c359ea9f53.jpg\" alt=\"\"></p>\n<h3 id=\"1-2-4-动态集成自定义的gradle任务方案\"><a href=\"#1-2-4-动态集成自定义的gradle任务方案\" class=\"headerlink\" title=\"1.2.4 动态集成自定义的gradle任务方案\"></a>1.2.4 动态集成自定义的gradle任务方案</h3><p>在项目持续集成时，我们需要添加一些自定义的任务，但是又要尽量避免修改用户的项目代码。因此，本文采用了一个比较折中的方案：<br>在<code>Jenkins</code>的根目录下建一个<code>configs</code>文件夹，放置一些项目构建过程使用的第三方库、脚本以及配置文件等；然后在项目构建之前，通过执行<code>Job</code>配置页的脚本将该文件夹及其内容复制到目标构建项目的工作空间中，同时修改项目的<code>build.gradle</code>文件；最后在项目构建过程中，调用这些第三方库、脚本以及配置文件，来完成自定义的额外的构建任务。</p>\n<p><code>FindBugs</code>任务的集成就应用了上述方案，后续介绍的<code>FireLine</code>集成以及<code>Apk</code>大小、方法数和资源文件统计的集成亦是如此。</p>\n<p>例如，修改<code>build.gradle</code>文件，动态引入<code>jenkins.gradle</code>文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">groovy</div><div class=\"line\">project(&apos;:app&apos;) &#123; //在项目的主moudle（一般默认是app）中引用构建相关的gradle脚本</div><div class=\"line\">    apply from: rootProject.getRootDir().getAbsolutePath() + &apos;/configs/scripts/jenkins.gradle&apos;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"1-2-5-FireLine\"><a href=\"#1-2-5-FireLine\" class=\"headerlink\" title=\"1.2.5 FireLine\"></a>1.2.5 FireLine</h3><p>FireLine 提供一种静态代码（指<code>java</code>源码，后来据说又支持<code>class</code>文件）扫描服务，基于<code>PMD</code>开源。它是360公司针对自己的产品定制的安全检查规则，使用这些规则对源代码进行扫描检测，找出代码潜在的安全风险。目前，对外也可以使用。因此，本文对该工具进行了集成。</p>\n<p>FireLine 对外提供一个<code>jar</code>包，必须通过命令行的形式运行，因此需要添加一个<code>fireLine</code>的任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">groovy</div><div class=\"line\">//扫描java源码，需指定扫描对象以及结果存储位置</div><div class=\"line\">task fireLine &lt;&lt; &#123;</div><div class=\"line\">    def fireLineDir=env.JENKINS_HOME+&quot;/jobs/&quot;+env.JOB_NAME+&quot;/builds/&quot;+env.BUILD_NUMBER+&quot;/&quot;</div><div class=\"line\">    exec &#123;</div><div class=\"line\">        workingDir &apos;./&apos;</div><div class=\"line\">        //命令行执行jar包</div><div class=\"line\">        commandLine &quot;java&quot;, &quot;-jar&quot;, &quot;$&#123;project.rootDir&#125;/configs/jars/fireline.jar&quot;, &quot;scanSrcDir=&quot;+env.WORKSPACE, &quot;reportSaveDir=&quot;+fireLineDir,&quot;reportFileName=fireLineResult&quot;,&quot;user=netease&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构建后，检查结果在邮件中显示如图：</p>\n<p><img src=\"https://nos.netease.com/popo/70d4c25e2675849aa5b760c258ad655e.jpg\" alt=\"\"></p>\n<p>点击链接地址，跳转到需要<code>HTML Publisher Plugin</code>支持的火线检查的详细界面：</p>\n<p><img src=\"https://nos.netease.com/popo/8ad710117b1e3f862f24d23b783fde84.jpg\" alt=\"\"></p>\n<p>注意，若<code>FireLine</code>报告不能正常显示，这是由于它使用了<code>JavaScript</code>，这里需要设置<code>jenkins</code>允许脚本执行（<code>allow-scripts</code>），需要在系统设置页的<code>Jenkins Script Console</code>选项中输入命令：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;)</div></pre></td></tr></table></figure>\n<p>并执行，从而修改<code>Jenkins</code>的默认配置参数，然后重新构建项目即可。</p>\n<h3 id=\"1-2-6-Apk方法数、大小以及资源文件分析\"><a href=\"#1-2-6-Apk方法数、大小以及资源文件分析\" class=\"headerlink\" title=\"1.2.6 Apk方法数、大小以及资源文件分析\"></a>1.2.6 Apk方法数、大小以及资源文件分析</h3><p>随着项目的不断迭代更新，<code>android</code>应用不得不面对<code>64k</code>方法数限制、<code>Apk</code>体积不断变大的问题。因此，本次实践中将对该类数据进行收集分析，更加直观的展现给关注该类信息的用户。</p>\n<h4 id=\"1-2-6-1-Apk方法数、大小统计\"><a href=\"#1-2-6-1-Apk方法数、大小统计\" class=\"headerlink\" title=\"1.2.6.1 Apk方法数、大小统计\"></a>1.2.6.1 Apk方法数、大小统计</h4><p>在Apk方法数统计集成中，采用了开源的<code>Gradle</code>插件项目-<a href=\"https://github.com/KeepSafe/dexcount-gradle-plugin\">dexcount-gradle-plugin</a>，该插件会根据配置为打包的每个<code>Apk</code>文件生成一份方法数统计的文件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">buildscript &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenCentral() <span class=\"comment\">// or jcenter()</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    dependencies &#123;</div><div class=\"line\">        classpath <span class=\"string\">'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.6.1'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// make sure this line comes *after* you apply the Android plugin</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.getkeepsafe.dexcount'</span></div></pre></td></tr></table></figure>\n<p>配置完成后，执行<code>assemble</code>任务时，会在<code>app/build/outputs</code>目录下生成<code>apk</code>方法数统计数据文件：</p>\n<p><img src=\"https://nos.netease.com/popo/c139efda8d19abae9869aadc6fdb044b.jpg\" alt=\"\"></p>\n<p>因此，在本次<code>jenkins-ci</code>实践中，我们需要做就是在构建项目中动态添加该插件，并将该插件生成的统计数据进行收集、转换。</p>\n<p>和集成<code>findbugs</code>插件不同的是，这里还需要动态修改<code>app</code>项目的<code>buildscript</code>对象，并保证该插件是在<code>com.android.application</code>之后被应用。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//动态修改`app`项目的`buildscript`对象</span></div><div class=\"line\">project(<span class=\"string\">':app'</span>) &#123;</div><div class=\"line\">    apply <span class=\"string\">from:</span> rootProject.getRootDir().getAbsolutePath() + <span class=\"string\">'/configs/scripts/buildscript.gradle'</span>, <span class=\"string\">to:</span> buildscript</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并通过调用<code>gradle</code>中的<code>PluginManager</code>对象的<code>void withPlugin(String id, Action&lt;? super AppliedPlugin&gt; action)</code>方法，来监听插件的添加事件。当<code>com.android.application</code>插件被添加时，就可以动态添加<code>dexcount-gradle-plugin</code>插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pluginManager.withPlugin(<span class=\"string\">\"com.android.application\"</span>, <span class=\"keyword\">new</span> Action&lt;AppliedPlugin&gt;() &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> execute(AppliedPlugin appliedPlugin) &#123;</div><div class=\"line\">        project(<span class=\"string\">':app'</span>) &#123; <span class=\"comment\">//主module名称</span></div><div class=\"line\">            apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.getkeepsafe.dexcount'</span> <span class=\"comment\">//引入apk方法数统计插件</span></div><div class=\"line\">            apply <span class=\"string\">plugin:</span> <span class=\"string\">\"com.netease.hearttouch.resourcesize\"</span> <span class=\"comment\">//引入资源文件统计插件</span></div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>最后，为了在<code>jenkins</code>中使用该数据，创建一个<code>apkMethodCounts</code>任务将上述的所有的<code>json</code>格式文件进行统一解析转换，并将解析结果和生成的<code>Apk</code>文件–对应起来。构建结果如图：</p>\n<p><img src=\"https://nos.netease.com/popo/ab6fd8a20b0836902c48f3d02ddec216.jpg\" alt=\"\"></p>\n<h4 id=\"1-2-6-2-资源文件大小统计\"><a href=\"#1-2-6-2-资源文件大小统计\" class=\"headerlink\" title=\"1.2.6.2 资源文件大小统计\"></a>1.2.6.2 资源文件大小统计</h4><p>资源文件统计插件<a href=\"https://g.hz.netease.com/hearttouch-android/resource_size_plugin\">resource-size-plugin</a>与<code>dexcount-gradle-plugin</code>的使用方法基本一致，该插件也是需要通过动态添加。</p>\n<p>插件配置完成后，执行<code>resourcesize</code>任务，会在<code>app/build/outputs</code>目录下生成分析结果<code>resoucesize.txt</code>。其中，第一行表示所有资源文件的总大小，后面每行代表单个文件最大的文件名称以及文件大小：</p>\n<p><img src=\"https://nos.netease.com/popo/d900de430614c344379c01aad3af8c98.jpg?imageView&amp;thumbnail=500x300\" alt=\"\"></p>\n<p>最后，将数据进行简单处理，在<code>jenkins</code>的构建结果中显示如图：</p>\n<p><img src=\"https://nos.netease.com/popo/5571e696f32a9e23bf86ce558ab0d22a.jpg?imageView&amp;thumbnail=0x400\" alt=\"\"></p>\n<h3 id=\"1-2-7-Git-Changelog分析\"><a href=\"#1-2-7-Git-Changelog分析\" class=\"headerlink\" title=\"1.2.7 Git Changelog分析\"></a>1.2.7 Git Changelog分析</h3><p>随着项目的迭代，代码的提交越来越频繁，代码的管理显得越来越重要。而<code>commit message</code>是开发者是对自己所提交代码的唯一说明，它能够直接反映开发者的意图，并方便快速查询和浏览，是必不可少的。在这些<code>commit message</code>中，比较重要的主要有<code>feature</code>（新功能）和<code>bug fix</code>（问题修复）两种类型，也是一个产品的关注点。</p>\n<p>因此，为了在构建中提取该类信息，在参考网上的一些<code>Git</code>规范的基础上，整理出一份<a href=\"https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md\">Git提交规范</a>，规定了完整的<code>git</code>提交日志由信息头部、信息主体和信息尾部构成，其中信息头部需要包含类型、范围和主题三类信息。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>(<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>):<span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span></div><div class=\"line\"> 空行</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"> 空行</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>详细规范描述可参考<a href=\"https://g.hz.netease.com/mobile-android/document/blob/master/%E8%A7%84%E8%8C%83/git%E6%97%A5%E5%BF%97:%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83.md\">规范文档</a>。另外，<a href=\"https://github.com/commitizen/cz-cli\">Commitizen</a>是一个撰写合格<code>Commit message</code>的工具，很好用，推荐～。使用该工提交代码之后，会自动生成上述格式规范的日志信息。</p>\n<p>通过<code>Commitizen</code>工具（或者手动）提交之后，在<code>GitLab</code>上生成的<code>Commit message</code>如图：</p>\n<p><img src=\"https://nos.netease.com/popo/1de9a4ecf80b34eefcbfcaed7d8f271e.jpg\" alt=\"\"></p>\n<p>从图中的示例可以看出，两个<code>Commit message</code>的类型是<code>feature</code>和<code>bug fix</code>的，因此<code>Jenkins</code>构建的过程中需要进行处理并显示给用户。<br>￼<br><img src=\"https://nos.netease.com/popo/f4d85368b1fdf419de676e7dec91aac4.jpg\" alt=\"\"></p>\n<p>另外，为了能够解析<code>bug fix</code>类型提交中的<code>jira</code>上的问题并生成跳转链接，需要在项目根目录下添加一个<code>jenkins.xml</code>文件，示例如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jenkins</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jira</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://jira.netease.com/projects/MINIFIVE/issues/MINIFIVE-#<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span> <span class=\"comment\">&lt;!--#作为占位符--&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">jira</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">jenkins</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>综上，关于自定义<code>Jenkins-ci</code>构建通知邮件内容的部分已经介绍完了，下面我们要讲一下<code>Jenkins</code>与<code>Docker</code>结合如何实现快速配置。</p>\n<h1 id=\"2-Jenkins与Docker结合实现快速配置\"><a href=\"#2-Jenkins与Docker结合实现快速配置\" class=\"headerlink\" title=\"2. Jenkins与Docker结合实现快速配置\"></a>2. Jenkins与Docker结合实现快速配置</h1><p><a href=\"https://www.docker.com/\">Docker</a>是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的<code>Linux</code>机器上，也可以实现虚拟化。基于<code>Docker</code>轻量级、可移植的特点，本次实践将<code>Jenkins-ci</code>的构建环境配置打包到<code>Docker</code>中，从而实现快速配置。</p>\n<h2 id=\"2-1-Dockerfile文件配置\"><a href=\"#2-1-Dockerfile文件配置\" class=\"headerlink\" title=\"2.1 Dockerfile文件配置\"></a>2.1 Dockerfile文件配置</h2><p>创建一个自定义的<code>docker</code>镜像，可以通过<code>Dockerfile</code>描述文件来自动完成。<code>Dockerfile</code>文件包含了创建镜像所需要的<a href=\"http://seanlook.com/2014/11/17/dockerfile-introduction/\">全部指令</a>，可以使用<code>Docker build</code>命令来创建镜像。</p>\n<p>本文中使用的<code>Dockerfile</code>是基于<code>jenkinsci</code>开源的<a href=\"https://github.com/jenkinsci/docker\">jenkins</a>镜像，并根据需求进行了定制，部分内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM jenkins:latest  //已配好java和git环境</div><div class=\"line\">...</div><div class=\"line\"># Same as &quot;export TERM=dumb&quot;; prevents error &quot;Could not open terminal for stdout: $TERM not set&quot;</div><div class=\"line\">ENV TERM dumb</div><div class=\"line\"></div><div class=\"line\">#support 32 bit binary on a 64 bit system</div><div class=\"line\">RUN  apt-get update &amp;&amp; apt-get install -y lib32z1 lib32stdc++6 wget &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</div><div class=\"line\"></div><div class=\"line\"># 下载Android Sdk</div><div class=\"line\">...</div><div class=\"line\">RUN cd /opt &amp;&amp; \\</div><div class=\"line\">    wget $&#123;ANDROID_SDK_URL&#125; &amp;&amp; \\</div><div class=\"line\">    tar -xzf $&#123;ANDROID_SDK_FILENAME&#125; &amp;&amp; \\</div><div class=\"line\">    rm $&#123;ANDROID_SDK_FILENAME&#125; &amp;&amp;\\</div><div class=\"line\">    echo y | android update sdk --no-ui --all --filter tools,platform-tools,extra-android-m2repository,android-23,build-tools-23.0.0,build-tools-23.0.1,build-tools-23.0.2,build-tools-23.0.3</div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\"># 拷贝JENKINS_HOME文件夹的内容至$JENKINS_HOME目录下，该文件夹与Dockerfile在同一目录，包含了jenkins ci的全部配置信</div><div class=\"line\">ADD JENKINS_HOME $JENKINS_HOME</div><div class=\"line\"></div><div class=\"line\">EXPOSE 8080</div></pre></td></tr></table></figure>\n<p>在配置文件中，我们使用<code>wget</code>命令去官方下载最新的<code>linux</code>下<code>android SDK</code>包，并配置环境，然后使用<code>android</code>命令选择和自己项目匹配的<code>SDK</code>以及工具的版本（本次打包的镜像下载了<code>android-23</code>以及系列的编译工具，用户可根据需求自行修改）。</p>\n<h2 id=\"2-2-使用Dockerfile文件构建镜像\"><a href=\"#2-2-使用Dockerfile文件构建镜像\" class=\"headerlink\" title=\"2.2 使用Dockerfile文件构建镜像\"></a>2.2 使用Dockerfile文件构建镜像</h2><p>由于<code>Docker</code>是基于<code>Linux</code>，在<code>Mac OS</code>上运行起来需要一个虚拟的<code>Linux</code>环境，它还需要若干工具支持:</p>\n<ul>\n<li>VirtualBox：虚拟机，用来运行<code>Linux</code></li>\n<li>docker-machine：用来管理虚拟机</li>\n<li>docker：<code>Docker</code>本身</li>\n<li>docker-compose(Mac OS only)：用来管理多个<code>docker</code>容器</li>\n<li>Kitematic：用来管理远程<code>Docker Hub</code></li>\n</ul>\n<p>上述工具安装完毕后（推荐使用<a href=\"http://brew.sh/\">Homebrew</a>），就可以创建虚拟机，配置<code>docker</code>环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker-machine create --driver virtualbox dev   //1、创建虚拟机</div><div class=\"line\"></div><div class=\"line\">docker-machine env dev    //2、查看dev信息</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(docker-machine env dev)</span>\"</span>   //3、添加到环境变量，关联当前shell</div></pre></td></tr></table></figure>\n<p>然后，进入到<code>Dockerfile</code>所在的目录，就可以执行<code>build</code>命令打包镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker build -t [docker-image-name\\id] .</div><div class=\"line\">``` </div><div class=\"line\">目前，该镜像已经上传到[网易蜂巢](https://c.163.com/)，可通过一下命令获取：</div><div class=\"line\"></div><div class=\"line\">```bash</div><div class=\"line\">docker pull hub.c.163.com/netease163/ht-jenkinsci:latest</div></pre></td></tr></table></figure>\n<p>更多内容可参考<a href=\"https://c.163.com/wiki/index.php?title=%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F\">网易蜂巢使用指南</a>。<br>综上，本次<code>Jenkins-ci</code>容器化实践就讲完了～有问题或建议可以联系我，一起交流～</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3. 参考资料\"></a>3. 参考资料</h1><ul>\n<li><a href=\"https://jenkins.io/\">jenkins官网</a></li>\n<li><a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Plugins\">jenkins插件</a></li>\n<li><a href=\"http://wangkuiwu.github.io/2015/08/07/jenkins-02/\">Jenkins集成android工程</a></li>\n<li><a href=\"https://github.com/jenkinsci/jenkins\">jenkins-ci</a></li>\n<li><a href=\"http://javadoc.jenkins-ci.org/overview-summary.html\">jenkins的Api文档</a></li>\n<li><a href=\"http://itfish.net/article/53357.html\">Jenkins构建Android项目持续集成之findbugs的使用\n</a></li>\n<li><a href=\"https://github.com/KeepSafe/dexcount-gradle-plugin\">dexcount-gradle-plugin</a></li>\n<li><a href=\"http://magic.360.cn/index.html\">FireLine</a></li>\n<li><a href=\"https://github.com/jenkinsci/email-ext-plugin\">email-ext-plugin</a></li>\n<li><a href=\"https://github.com/jenkinsci/findbugs-plugin\">findbugs-plugin</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004881029\">Android中使用FindBugs</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\">Commit message和Change log编写指南</a></li>\n<li><a href=\"https://github.com/paulwellnerbou/git-changelog-jenkins-plugin\">git-changelog-plugin</a></li>\n<li><a href=\"http://qa.blog.163.com/blog/static/19014700220131011102715643/\">持续集成之Jenkins插件使用-邮件通知模板化</a></li>\n<li><a href=\"http://www.qisanfen.com/?p=474\">搭建linux（ubuntu 14.04）下的android开发环境</a></li>\n<li><a href=\"http://qianngchn.github.io/wiki/8.html\">Ubuntu下全命令行搭建Android开发环境</a></li>\n<li><a href=\"http://www.jianshu.com/p/13c132503d01\">Run Docker on your Mac</a></li>\n<li><a href=\"http://developerworks.github.io/2014/09/07/android-ci-server/#%E5%AE%89%E8%A3%85Android_SDK\">搭建Android持续集成服务器</a><ul>\n<li><a href=\"http://blog.saymagic.cn/2016/01/25/docker-image-for-android.html\">构建编译Android项目的Docker镜像</a></li>\n<li><a href=\"http://www.larrycaiyu.com/2014/11/04/use-docker-for-your-jenkins-demo-1.html\">使用docker来提升你的Jenkins</a></li>\n<li><a href=\"http://ju.outofmemory.cn/entry/145390\">Setup Jenkins for Android Integration Using Docker</a></li>\n<li><a href=\"http://blog.csdn.net/sbsujjbcy/article/details/52215051\">Mac OSX Docker下搭建Android+Jenkins+Gitlab</a></li>\n<li><a href=\"http://www.cnphp6.com/archives/115564\">gitlab与jenkins协同工作</a></li>\n</ul>\n</li>\n</ul>"},{"title":"网易Android工程模板化实践","date":"2016-11-24T16:00:00.000Z","author":"张丹","_content":"\n我们网易前端技术部 - 移动技术组作为公司的移动端基础技术部门，主要为其他部门提供解决方案、技术支持和产品孵化。在几年的积累过程中，我们拥有一些自己的框架和 SDK，如轻应用框架、热更新 SDK、网络请求库、本地存储库、页面管理等。服务过网易新闻、云音乐、考拉、易信等亿级产品，先后孵化过青果摄像头、二次元Gacha、严选等重要产品。<!-- more -->\n\n在多年的Android开发中，对于 Android 端产品开发，我们有如下几点体会：\n\n1. 产品孵化排期紧张\n\n2. 基础模块的需求具有相似性\n\n3. 基础模块的选型和工具类具有可重用性\n\n4. 网络请求的代码具有机械性\n\n对于各个基础模块，我们团队封装了自己的 SDK，如网络库、本地存储库、页面管理库、图片库等。使用我们的Activity模板生成的初始工程，就已经包含了我们提供的基础模块，产品团队的开发不需要再花费重复的时间做技术调研、选型、SDK封装集成等工作，而只需要关心自己的业务逻辑编写。我们期望产品团队只需 1 分钟就能得到自己的初始工程，并能马上投入业务逻辑开发，既能缩短开发周期，也能保证工程代码质量。\n\n# 1. Android 模板简介\n\n\nAndroid Studio 提供遵循 Android 设计和开发最佳实践的代码模板，以帮助我们快速并正确地创造出漂亮的、功能齐全的应用程序代码模板。Android Studio 中提供的模板列表在不断增加，按照它们添加的组件类型（如Activity或XML文件）可对模板进行如下分组：\n\n![template menu](http://i1.piimg.com/574381/beec462952f97623s.png)\n\n> 可通过文件->新建菜单或在项目窗口中右键单击调出上述模板菜单。\n\nAndroid Studio 模板位置：\n\nWindows 的路径在 `${android studio 安装路径}/plugins/android/lib/templates/`\n\nMacOS 的路径在 `${Android Studio.app 存放路径}/Contents/plugins/android/lib/templates/`\n\n该文件夹具体内容如下：\n\n- activities：Activity模板相关，如 EmptyActivity 文件夹用于创建一个空页面的模板，GoogleMapsActivity 文件夹对应创建一个地图页面的模板等\n\n- gradle：放置了 gradle 模板，用于在新建工程的根目录下生成 gradle 文件夹，支持用户不用安装 gradle 就能使用 gradlew 命令\n\n- gradle-project：工程模板相关，用于构建 module，Android Project，Java Library 等\n\n- other：构建文件模板等\n\n模板最常见的用途之一是向现有应用程序模块添加新的 Activity。 activities 文件夹正是 Android Studio 默认提供的 Activity 模板，涵盖了手机和平板电脑应用中常用的 Activiy 模板。用户也可以参照已有模板自定义符合特定需求的 Activity 模板。\n\n## 1.1 Activity 模板的文件结构\n\n下面我们分析最简单的一个模板 EmptyActivity，我们首先查看下 EmtpyActivity (空白页面模板) 里面的内容\n\n![EmptyActivity Structrue](http://p1.bpimg.com/574381/8d1ddec0941bfe72.png)\n\n> Android Studio 使用的是 FreeMarker 模板引擎，所以文件后缀都是 .ftl\n\n- globals.xml.ftl: 全局变量文件，保存一些全局变量，当中可以引用其他文件的全局变量\n\n- recipe.xml.ftl: 配置要引用的模板路径以及文件的生成规则\n\n- template.xml: 模板的配置信息，包括模板的显示图标，界面的表现，全局变量文件和执行文件的指定等\n\n- template_blank_activity.png: 显示的缩略图\n\n- SimpleActivity.java.ftl: Activity 模板文件\n\n\n## 1.2 代码生成流程\n\n目前我们已经基本了解了一个Activity模板的文件结构了，以及每个文件大致包含的东西，简单总结如下：\n\n- template 中parameter标签，主要用于提供参数\n\n- global.xml.ftl 主要用于提供参数\n\n- recipe.xml.ftl 主要用于生成我们实际需要的代码，资源文件等\n\n\t> 例如，利用参数 + MainActivity.java.ftl -> MainActivity.java，其实就是利用参数将ftl中的变量进行替换\n\n代码生成过程如下图所示：\n\n![13_code_generation_process.jpg](http://p1.bqimg.com/574381/c29d60650ace6c90.jpg)\n\n> 图片摘自 [Tutorial How To Create Custom Android Code Templates](http://robusttechhouse.com/tutorial-how-to-create-custom-android-code-templates/)\n\n# 2. HTTemplate Activity 模板实现\n\n我们编写一个Activity模板叫作：HTTemplate，内容如下：\n\n![HTTemplate Structrue](http://i1.piimg.com/574381/0fa65436eccbb6ce.png)\n\n## 2.1 template.xml\n\n指定模板名、描述、最低支持 sdk 版本、类别等，输入界面要求指定包名和 Application 类名\n\n## 2.2 globals.xml.ftl\n\n引用公共文件内容\n\n```\n<?xml version=\"1.0\"?>\n<globals>\n    <global id=\"hasNoActionBar\" type=\"boolean\" value=\"false\" />\n    <#include \"../common/common_globals.xml.ftl\" />\n</globals>\n```\n\n## 2.3 recipe.xml.ftl\n\n```\n<?xml version=\"1.0\"?>\n<recipe>\n\n    <!-- nei.json -->\n    <instantiate from=\"root/nei.json.ftl\"\n             to=\"${escapeXmlAttribute(topOut)}/nei.json\" />\n\n    <!-- manifest -->\n    <merge from=\"root/AndroidManifest.xml.ftl\"\n             to=\"${escapeXmlAttribute(manifestOut)}/AndroidManifest.xml\" />\n\n    <merge from=\"root/AndroidManifestPermissions.xml\"\n             to=\"${escapeXmlAttribute(manifestOut)}/AndroidManifest.xml\" />\n\n    <!-- 全部资源 -->\n    <copy from=\"root/res\"\n             to=\"${escapeXmlAttribute(resOut)}\" />\n\n    <!-- libs 库 -->\n    <copy from=\"root/libs\"\n             to=\"${escapeXmlAttribute(projectOut)}/libs\" />\n\n    <!-- gradle -->\n    <merge from=\"root/project_build.gradle.ftl\"\n             to=\"${escapeXmlAttribute(topOut)}/build.gradle\" />\n\n    <merge from=\"root/app_build.gradle.ftl\"\n             to=\"${escapeXmlAttribute(projectOut)}/build.gradle\" />\n\n    <!-- README -->\n    <instantiate from=\"root/README.md.ftl\"\n             to=\"${escapeXmlAttribute(topOut)}/README.md\" />\n\n    <!-- proguard-rules.pro.ftl -->\n    <copy from=\"root/proguard-rules.pro.ftl\"\n             to=\"${escapeXmlAttribute(projectOut)}/proguard-rules.pro.template\" />\n\n    <!-- java 代码 -->\n    <!-- application 文件夹 -->\n    <instantiate from=\"root/src/app_package/application/AppProfile.java.ftl\"\n                   to=\"${escapeXmlAttribute(srcOut)}/application/AppProfile.java\" />\n\n\n    ...\n\n    <!-- attrs.xml -->\n    <merge from=\"root/res/values/attrs.xml\"\n             to=\"${escapeXmlAttribute(resOut)}/values/attrs.xml\" />\n             \n    ...\n\n</recipe>\n\n```\n\n省略部分代码，主要的工作是\n\n- merge AndroidManifest.xml 文件\n\n- copy 或者 merge 资源文件\n\n- copy 或 instantiate java 代码\n\n- merge build.gradle 文件\n\n- merge settings.gradle 文件\n\n- copy lib 文件夹里面的全部内容\n\n- copy proguard-rules.pro 文件\n\n\n## 2.4 root 文件夹\n\n![root Structure](http://i1.piimg.com/574381/134add19853d8905.png)\n\n放置相关模板源文件，包括一些Activity、自定义View、通用工具类等。将其中以`.ftl`为后缀的源代码，按照 FreeMarker 语法进行替换。例如，使用了包名的地方，需要替换成 `${packageName}`：\n\n```\npackage ${packageName}.application;\nimport ${packageName}.R;\n```\n\n在gradle文件中配置私有maven库的地址、增加公用的依赖库、关闭lint的严格检查、配置APK多渠道打包等。\n\n## 2.5 模板图标\n\n添加 Activity 模板图标，并在 template.xml 中添加引用\n\n```\n<thumbs>\n    <thumb>template_thumb.png</thumb>\n</thumbs>\n```\n\n## 2.6 使用 Activity 模板生成初始工程\n\n将上述 HTTemplate 文件夹拷贝至 Android Studio 的 Activity 模板目录下：\n\nWindows 的路径在 \n\n```\n${android studio 安装路径}/plugins/android/lib/templates/activities\n```\n\nMacOS 的路径在 \n\n```\n${Android Studio.app 存放路径}/Contents/plugins/android/lib/templates/activities\n```\n\n重启 Android Studio，在新建工程过程中可以看到，出现了我们自定义的 Activity 模板项：\n\n![新建项目流程之选择Activity](http://p1.bpimg.com/574381/af37bc8f7a18c791s.png)\n\n直接运行生成的项目，效果如下：\n\n\n![工程运行效果图](http://p1.bpimg.com/574381/cbe2f56ec299f5ee.gif)\n\n\n到这里，使用我们的 Activity 模板生成的初始工程，就已经包含了我们提供的网络库、本地存储库、页面管理库、图片库等基础模块，开发人员接下来只需专注于业务逻辑的开发。\n\n# 3. 遇到的问题及解决方案\n\n为分析问题的原因，我们找到了 Android 模板相关源码：\n\nMac 平台：\n\n```\n${android studio安装路径}/Contents/plugins/android/lib/android.jar\n```\n\nWindows 平台：\n\n```\n${android studio安装路径}/plugins/android/lib/android.jar\n\n```\n\n以下问题的解答将涉及到部分源码。\n\n\n## 3.1 ${} 通配符冲突\n\n当工程模板实例化时，${} 会被 FreeMarker 语法处理，导致错误。\n\n解决办法：定义 FreeMarker 转义字符如下\n\n```\n$ ==> ${\"$\"}\n\n```\n\n## 3.2 Java 代码实例化问题\n\n模板中 java 代码较多，我们统一放在 root/src/ 文件夹下，里面有部分文件含有 FreeMarker 标签，有部分只是纯粹的 java 代码。而使用 instantiate 命令对整个文件夹进行实例化操作，并不会触发 FreeMarker 语法执行。\n\n解决办法：因 java 文件比较多，手写 recipe.xml 标签命令繁琐且容易出错。我们通过程序递归遍历 root/src/ 下的全部代码文件，并生成相应的 instantiate 或 copy 命令。\n\n## 3.3 copy 和 instantiate 问题\n\n### (1) gradle.properties 文件执行 copy 或者 instantiate 操作无效\n\n分析结果：查看 DefaultRecipeExecutor.copy 与 DefaultRecipeExecutor.instantiate 源码处理逻辑，得知执行 copy 和 instantiate 命令时，如果 from 指定一个非文件夹，且目标文件存在，则不执行拷贝。而在执行我们的 Activity 模板之前，已经执行了 gradle-projects/NewAndroidProject 工程模板，并生成了 gradle.properties 文件，因此执行 copy 或 instantiate 都因目标文件已经存在而不再执行。\n\n### (2) copy 和 instantiate 对文件夹操作的区别\n\n- 相同点：如果 from 指定一个文件夹，都是执行 copyTemplateResource 方法，二者没有区别；如果 from 指定一个非文件夹，且目标文件存在，则不执行文件操作。\n\n- 不同点：copy 命令不使用 FreemarkerUtils 对 FreeMarker 语法进行处理，而 instantiate 命令先执行 FreemarkerUtils 的静态方法 processFreemarkerTemplate 来处理 FreeMarker 语法，之后再执行文件拷贝操作。\n\n## 3.4 merge 问题\n\n### (1) proguard-rules.pro、gradle.properties 文件执行 merge 操作失败\n\n分析结果：根据 DefaultRecipeExecutor.merge 源码的逻辑，我们得知当 to 文件不存在，则执行 copy 或 instantiate 命令；如果 to 文件存在且可读，则仅对 xml 或 gradle 才能执行 merge 操作。\n\n解决办法：\n\n- 暂时生成 proguard-rules.pro.template 文件\n\n- 将定义在 gradle.properties 中的常量移动到 project_build.gradle.ftl 的 ext{ } 内\n\n### (2) settings.gradle 文件合并，指定 module 路径错误\n\n执行前：\n\n```\ninclude ':hteventbus', ':htrefreshrecyclerview', ':htrecycleview', ':hthttp'\n\nproject(':hteventbus').projectDir = new File('module/hteventbus')\nproject(':hthttp').projectDir = new File('module/hthttp')\nproject(':htrefreshrecyclerview').projectDir = new File('module/htrefreshrecyclerview')\nproject(':htrecycleview').projectDir = new File('module/htrecycleview')\n```\n\n执行后报错：\n\n```\nRuntimeException: java.lang.RuntimeException: When merging settings.gradle files, only include directives can be merged.\n```\n\n分析结果：查看 RecipeMergeUtils.mergeGradleSettingsFile 源码，得知当 settings.gradle 文件合并时，只允许每行开头是 include 命令，其他情况抛出异常。\n\n解决办法：去掉非 include 的操作代码，改用远程依赖引用这些 module，即在 dependencies{ } 中添加相应的依赖。\n\n### (3) build.gradle 文件合并，apply 语句合并错误\n\n执行前：\n\n```\napply plugin: 'com.neenbedankt.android-apt'\n```\n\n执行后：\n\n```\napply plugin: 'com.neenbedankt.android-apt' plugin: 'com.android.application'\n```\n\n分析结果：查看 GradleFileMerger 中的 mergeGradleFiles 方法，实际执行的是 mergePsi 方法，根据 mergePsi 合并逻辑，apply 不是 call 语句，且 apply 的第一个子元素不是 dependencies，因此添加 plugin: 'com.neenbedankt.android-apt' 到 toRoot 的 apply 子元素前面。\n\n解决办法：根据上面的分析，看起来 apply 的这个合成结果是 Android 模板的 bug，我们目前只能采用手工添加 apply 语句的方法。\n\n\n### (4) build.gradle 文件合并，dependencies{ } 内的 apt 语句消失\n\n执行前：\n\n```\ndependencies {\n    compile \"com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION\"\n    apt \"com.netease.hearttouch:ht-universalrouter-dispatch-process:$HEARTTOUCH_HTROUTER_DISPATCH_PROCESS_VERSION\"\n    ...\n}\n```\n\n执行后：\n\n```\ndependencies {\n    compile \"com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION\"\n    ...\n}\n```\n\n分析结果：查看 GradleFileMerger.mergeDependencies 源码，得知当 dependencies 合并时，仅处理 dependencies 中的 compile 子元素，其他如 apt、provided 命令都会被忽略掉。\n\n解决办法：由于源码并未提供非 compile 子元素的合并方案，我们目前只能采用手工添加 apt 语句的方法。\n\n\n\n# 4. 小结和后续工作\n\n到此，基本上完成了我们原先期望实现的初始工程：\n\n1. 提供 ht-template 支持生成我们的模板工程\n\n2. 提供 Android Studio 插件 (NEIPlugin)\n\n- 支持 ht-template 的下载安装\n\n- nei-toolkit 和 Node.js 的下载安装\n\n- nei-toolkit 和 Node.js 的使用，生成网络请求代码\n\n这里还是有一些因为 Android 模板自身的限制而无法完成的内容点：\n\n1. 无法在 settings.gradle 指定 module 路径\n\n2. 无法合并 proguard-rules.pro 文件，暂时生成 proguard-rules.pro.template 文件\n\n3. 由于 build.gradle 对 apply 命令合并会出错和无法合并 dependencies 中的 apt 命令，所以无法在 build.gradle 中集成 ht-universalrouter\n\n此外，除了网络请求的代码编写是机械性的，基于我们的 Activity 模板生成的初始工程，在其他方面也存在代码编写的机械性：初始页面代码生成、RecycleView 中的各个 ViewHolder 类、本地数据读取保存等，而这些工作将会是我们的后续工作。\n\n\n\n\n\n","source":"_posts/android/网易 Android 工程模板化实践.md","raw":"---\ntitle: 网易Android工程模板化实践\n\ndate: 2016-11-25\n\nauthor: 张丹\n\ncategories: android \n\ntags: \n- android工程模板\n\n---\n\n我们网易前端技术部 - 移动技术组作为公司的移动端基础技术部门，主要为其他部门提供解决方案、技术支持和产品孵化。在几年的积累过程中，我们拥有一些自己的框架和 SDK，如轻应用框架、热更新 SDK、网络请求库、本地存储库、页面管理等。服务过网易新闻、云音乐、考拉、易信等亿级产品，先后孵化过青果摄像头、二次元Gacha、严选等重要产品。<!-- more -->\n\n在多年的Android开发中，对于 Android 端产品开发，我们有如下几点体会：\n\n1. 产品孵化排期紧张\n\n2. 基础模块的需求具有相似性\n\n3. 基础模块的选型和工具类具有可重用性\n\n4. 网络请求的代码具有机械性\n\n对于各个基础模块，我们团队封装了自己的 SDK，如网络库、本地存储库、页面管理库、图片库等。使用我们的Activity模板生成的初始工程，就已经包含了我们提供的基础模块，产品团队的开发不需要再花费重复的时间做技术调研、选型、SDK封装集成等工作，而只需要关心自己的业务逻辑编写。我们期望产品团队只需 1 分钟就能得到自己的初始工程，并能马上投入业务逻辑开发，既能缩短开发周期，也能保证工程代码质量。\n\n# 1. Android 模板简介\n\n\nAndroid Studio 提供遵循 Android 设计和开发最佳实践的代码模板，以帮助我们快速并正确地创造出漂亮的、功能齐全的应用程序代码模板。Android Studio 中提供的模板列表在不断增加，按照它们添加的组件类型（如Activity或XML文件）可对模板进行如下分组：\n\n![template menu](http://i1.piimg.com/574381/beec462952f97623s.png)\n\n> 可通过文件->新建菜单或在项目窗口中右键单击调出上述模板菜单。\n\nAndroid Studio 模板位置：\n\nWindows 的路径在 `${android studio 安装路径}/plugins/android/lib/templates/`\n\nMacOS 的路径在 `${Android Studio.app 存放路径}/Contents/plugins/android/lib/templates/`\n\n该文件夹具体内容如下：\n\n- activities：Activity模板相关，如 EmptyActivity 文件夹用于创建一个空页面的模板，GoogleMapsActivity 文件夹对应创建一个地图页面的模板等\n\n- gradle：放置了 gradle 模板，用于在新建工程的根目录下生成 gradle 文件夹，支持用户不用安装 gradle 就能使用 gradlew 命令\n\n- gradle-project：工程模板相关，用于构建 module，Android Project，Java Library 等\n\n- other：构建文件模板等\n\n模板最常见的用途之一是向现有应用程序模块添加新的 Activity。 activities 文件夹正是 Android Studio 默认提供的 Activity 模板，涵盖了手机和平板电脑应用中常用的 Activiy 模板。用户也可以参照已有模板自定义符合特定需求的 Activity 模板。\n\n## 1.1 Activity 模板的文件结构\n\n下面我们分析最简单的一个模板 EmptyActivity，我们首先查看下 EmtpyActivity (空白页面模板) 里面的内容\n\n![EmptyActivity Structrue](http://p1.bpimg.com/574381/8d1ddec0941bfe72.png)\n\n> Android Studio 使用的是 FreeMarker 模板引擎，所以文件后缀都是 .ftl\n\n- globals.xml.ftl: 全局变量文件，保存一些全局变量，当中可以引用其他文件的全局变量\n\n- recipe.xml.ftl: 配置要引用的模板路径以及文件的生成规则\n\n- template.xml: 模板的配置信息，包括模板的显示图标，界面的表现，全局变量文件和执行文件的指定等\n\n- template_blank_activity.png: 显示的缩略图\n\n- SimpleActivity.java.ftl: Activity 模板文件\n\n\n## 1.2 代码生成流程\n\n目前我们已经基本了解了一个Activity模板的文件结构了，以及每个文件大致包含的东西，简单总结如下：\n\n- template 中parameter标签，主要用于提供参数\n\n- global.xml.ftl 主要用于提供参数\n\n- recipe.xml.ftl 主要用于生成我们实际需要的代码，资源文件等\n\n\t> 例如，利用参数 + MainActivity.java.ftl -> MainActivity.java，其实就是利用参数将ftl中的变量进行替换\n\n代码生成过程如下图所示：\n\n![13_code_generation_process.jpg](http://p1.bqimg.com/574381/c29d60650ace6c90.jpg)\n\n> 图片摘自 [Tutorial How To Create Custom Android Code Templates](http://robusttechhouse.com/tutorial-how-to-create-custom-android-code-templates/)\n\n# 2. HTTemplate Activity 模板实现\n\n我们编写一个Activity模板叫作：HTTemplate，内容如下：\n\n![HTTemplate Structrue](http://i1.piimg.com/574381/0fa65436eccbb6ce.png)\n\n## 2.1 template.xml\n\n指定模板名、描述、最低支持 sdk 版本、类别等，输入界面要求指定包名和 Application 类名\n\n## 2.2 globals.xml.ftl\n\n引用公共文件内容\n\n```\n<?xml version=\"1.0\"?>\n<globals>\n    <global id=\"hasNoActionBar\" type=\"boolean\" value=\"false\" />\n    <#include \"../common/common_globals.xml.ftl\" />\n</globals>\n```\n\n## 2.3 recipe.xml.ftl\n\n```\n<?xml version=\"1.0\"?>\n<recipe>\n\n    <!-- nei.json -->\n    <instantiate from=\"root/nei.json.ftl\"\n             to=\"${escapeXmlAttribute(topOut)}/nei.json\" />\n\n    <!-- manifest -->\n    <merge from=\"root/AndroidManifest.xml.ftl\"\n             to=\"${escapeXmlAttribute(manifestOut)}/AndroidManifest.xml\" />\n\n    <merge from=\"root/AndroidManifestPermissions.xml\"\n             to=\"${escapeXmlAttribute(manifestOut)}/AndroidManifest.xml\" />\n\n    <!-- 全部资源 -->\n    <copy from=\"root/res\"\n             to=\"${escapeXmlAttribute(resOut)}\" />\n\n    <!-- libs 库 -->\n    <copy from=\"root/libs\"\n             to=\"${escapeXmlAttribute(projectOut)}/libs\" />\n\n    <!-- gradle -->\n    <merge from=\"root/project_build.gradle.ftl\"\n             to=\"${escapeXmlAttribute(topOut)}/build.gradle\" />\n\n    <merge from=\"root/app_build.gradle.ftl\"\n             to=\"${escapeXmlAttribute(projectOut)}/build.gradle\" />\n\n    <!-- README -->\n    <instantiate from=\"root/README.md.ftl\"\n             to=\"${escapeXmlAttribute(topOut)}/README.md\" />\n\n    <!-- proguard-rules.pro.ftl -->\n    <copy from=\"root/proguard-rules.pro.ftl\"\n             to=\"${escapeXmlAttribute(projectOut)}/proguard-rules.pro.template\" />\n\n    <!-- java 代码 -->\n    <!-- application 文件夹 -->\n    <instantiate from=\"root/src/app_package/application/AppProfile.java.ftl\"\n                   to=\"${escapeXmlAttribute(srcOut)}/application/AppProfile.java\" />\n\n\n    ...\n\n    <!-- attrs.xml -->\n    <merge from=\"root/res/values/attrs.xml\"\n             to=\"${escapeXmlAttribute(resOut)}/values/attrs.xml\" />\n             \n    ...\n\n</recipe>\n\n```\n\n省略部分代码，主要的工作是\n\n- merge AndroidManifest.xml 文件\n\n- copy 或者 merge 资源文件\n\n- copy 或 instantiate java 代码\n\n- merge build.gradle 文件\n\n- merge settings.gradle 文件\n\n- copy lib 文件夹里面的全部内容\n\n- copy proguard-rules.pro 文件\n\n\n## 2.4 root 文件夹\n\n![root Structure](http://i1.piimg.com/574381/134add19853d8905.png)\n\n放置相关模板源文件，包括一些Activity、自定义View、通用工具类等。将其中以`.ftl`为后缀的源代码，按照 FreeMarker 语法进行替换。例如，使用了包名的地方，需要替换成 `${packageName}`：\n\n```\npackage ${packageName}.application;\nimport ${packageName}.R;\n```\n\n在gradle文件中配置私有maven库的地址、增加公用的依赖库、关闭lint的严格检查、配置APK多渠道打包等。\n\n## 2.5 模板图标\n\n添加 Activity 模板图标，并在 template.xml 中添加引用\n\n```\n<thumbs>\n    <thumb>template_thumb.png</thumb>\n</thumbs>\n```\n\n## 2.6 使用 Activity 模板生成初始工程\n\n将上述 HTTemplate 文件夹拷贝至 Android Studio 的 Activity 模板目录下：\n\nWindows 的路径在 \n\n```\n${android studio 安装路径}/plugins/android/lib/templates/activities\n```\n\nMacOS 的路径在 \n\n```\n${Android Studio.app 存放路径}/Contents/plugins/android/lib/templates/activities\n```\n\n重启 Android Studio，在新建工程过程中可以看到，出现了我们自定义的 Activity 模板项：\n\n![新建项目流程之选择Activity](http://p1.bpimg.com/574381/af37bc8f7a18c791s.png)\n\n直接运行生成的项目，效果如下：\n\n\n![工程运行效果图](http://p1.bpimg.com/574381/cbe2f56ec299f5ee.gif)\n\n\n到这里，使用我们的 Activity 模板生成的初始工程，就已经包含了我们提供的网络库、本地存储库、页面管理库、图片库等基础模块，开发人员接下来只需专注于业务逻辑的开发。\n\n# 3. 遇到的问题及解决方案\n\n为分析问题的原因，我们找到了 Android 模板相关源码：\n\nMac 平台：\n\n```\n${android studio安装路径}/Contents/plugins/android/lib/android.jar\n```\n\nWindows 平台：\n\n```\n${android studio安装路径}/plugins/android/lib/android.jar\n\n```\n\n以下问题的解答将涉及到部分源码。\n\n\n## 3.1 ${} 通配符冲突\n\n当工程模板实例化时，${} 会被 FreeMarker 语法处理，导致错误。\n\n解决办法：定义 FreeMarker 转义字符如下\n\n```\n$ ==> ${\"$\"}\n\n```\n\n## 3.2 Java 代码实例化问题\n\n模板中 java 代码较多，我们统一放在 root/src/ 文件夹下，里面有部分文件含有 FreeMarker 标签，有部分只是纯粹的 java 代码。而使用 instantiate 命令对整个文件夹进行实例化操作，并不会触发 FreeMarker 语法执行。\n\n解决办法：因 java 文件比较多，手写 recipe.xml 标签命令繁琐且容易出错。我们通过程序递归遍历 root/src/ 下的全部代码文件，并生成相应的 instantiate 或 copy 命令。\n\n## 3.3 copy 和 instantiate 问题\n\n### (1) gradle.properties 文件执行 copy 或者 instantiate 操作无效\n\n分析结果：查看 DefaultRecipeExecutor.copy 与 DefaultRecipeExecutor.instantiate 源码处理逻辑，得知执行 copy 和 instantiate 命令时，如果 from 指定一个非文件夹，且目标文件存在，则不执行拷贝。而在执行我们的 Activity 模板之前，已经执行了 gradle-projects/NewAndroidProject 工程模板，并生成了 gradle.properties 文件，因此执行 copy 或 instantiate 都因目标文件已经存在而不再执行。\n\n### (2) copy 和 instantiate 对文件夹操作的区别\n\n- 相同点：如果 from 指定一个文件夹，都是执行 copyTemplateResource 方法，二者没有区别；如果 from 指定一个非文件夹，且目标文件存在，则不执行文件操作。\n\n- 不同点：copy 命令不使用 FreemarkerUtils 对 FreeMarker 语法进行处理，而 instantiate 命令先执行 FreemarkerUtils 的静态方法 processFreemarkerTemplate 来处理 FreeMarker 语法，之后再执行文件拷贝操作。\n\n## 3.4 merge 问题\n\n### (1) proguard-rules.pro、gradle.properties 文件执行 merge 操作失败\n\n分析结果：根据 DefaultRecipeExecutor.merge 源码的逻辑，我们得知当 to 文件不存在，则执行 copy 或 instantiate 命令；如果 to 文件存在且可读，则仅对 xml 或 gradle 才能执行 merge 操作。\n\n解决办法：\n\n- 暂时生成 proguard-rules.pro.template 文件\n\n- 将定义在 gradle.properties 中的常量移动到 project_build.gradle.ftl 的 ext{ } 内\n\n### (2) settings.gradle 文件合并，指定 module 路径错误\n\n执行前：\n\n```\ninclude ':hteventbus', ':htrefreshrecyclerview', ':htrecycleview', ':hthttp'\n\nproject(':hteventbus').projectDir = new File('module/hteventbus')\nproject(':hthttp').projectDir = new File('module/hthttp')\nproject(':htrefreshrecyclerview').projectDir = new File('module/htrefreshrecyclerview')\nproject(':htrecycleview').projectDir = new File('module/htrecycleview')\n```\n\n执行后报错：\n\n```\nRuntimeException: java.lang.RuntimeException: When merging settings.gradle files, only include directives can be merged.\n```\n\n分析结果：查看 RecipeMergeUtils.mergeGradleSettingsFile 源码，得知当 settings.gradle 文件合并时，只允许每行开头是 include 命令，其他情况抛出异常。\n\n解决办法：去掉非 include 的操作代码，改用远程依赖引用这些 module，即在 dependencies{ } 中添加相应的依赖。\n\n### (3) build.gradle 文件合并，apply 语句合并错误\n\n执行前：\n\n```\napply plugin: 'com.neenbedankt.android-apt'\n```\n\n执行后：\n\n```\napply plugin: 'com.neenbedankt.android-apt' plugin: 'com.android.application'\n```\n\n分析结果：查看 GradleFileMerger 中的 mergeGradleFiles 方法，实际执行的是 mergePsi 方法，根据 mergePsi 合并逻辑，apply 不是 call 语句，且 apply 的第一个子元素不是 dependencies，因此添加 plugin: 'com.neenbedankt.android-apt' 到 toRoot 的 apply 子元素前面。\n\n解决办法：根据上面的分析，看起来 apply 的这个合成结果是 Android 模板的 bug，我们目前只能采用手工添加 apply 语句的方法。\n\n\n### (4) build.gradle 文件合并，dependencies{ } 内的 apt 语句消失\n\n执行前：\n\n```\ndependencies {\n    compile \"com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION\"\n    apt \"com.netease.hearttouch:ht-universalrouter-dispatch-process:$HEARTTOUCH_HTROUTER_DISPATCH_PROCESS_VERSION\"\n    ...\n}\n```\n\n执行后：\n\n```\ndependencies {\n    compile \"com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION\"\n    ...\n}\n```\n\n分析结果：查看 GradleFileMerger.mergeDependencies 源码，得知当 dependencies 合并时，仅处理 dependencies 中的 compile 子元素，其他如 apt、provided 命令都会被忽略掉。\n\n解决办法：由于源码并未提供非 compile 子元素的合并方案，我们目前只能采用手工添加 apt 语句的方法。\n\n\n\n# 4. 小结和后续工作\n\n到此，基本上完成了我们原先期望实现的初始工程：\n\n1. 提供 ht-template 支持生成我们的模板工程\n\n2. 提供 Android Studio 插件 (NEIPlugin)\n\n- 支持 ht-template 的下载安装\n\n- nei-toolkit 和 Node.js 的下载安装\n\n- nei-toolkit 和 Node.js 的使用，生成网络请求代码\n\n这里还是有一些因为 Android 模板自身的限制而无法完成的内容点：\n\n1. 无法在 settings.gradle 指定 module 路径\n\n2. 无法合并 proguard-rules.pro 文件，暂时生成 proguard-rules.pro.template 文件\n\n3. 由于 build.gradle 对 apply 命令合并会出错和无法合并 dependencies 中的 apt 命令，所以无法在 build.gradle 中集成 ht-universalrouter\n\n此外，除了网络请求的代码编写是机械性的，基于我们的 Activity 模板生成的初始工程，在其他方面也存在代码编写的机械性：初始页面代码生成、RecycleView 中的各个 ViewHolder 类、本地数据读取保存等，而这些工作将会是我们的后续工作。\n\n\n\n\n\n","slug":"android/网易 Android 工程模板化实践","published":1,"updated":"2017-01-05T06:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixk0c23m00017ekkpdfmd2pn","content":"<p>我们网易前端技术部 - 移动技术组作为公司的移动端基础技术部门，主要为其他部门提供解决方案、技术支持和产品孵化。在几年的积累过程中，我们拥有一些自己的框架和 SDK，如轻应用框架、热更新 SDK、网络请求库、本地存储库、页面管理等。服务过网易新闻、云音乐、考拉、易信等亿级产品，先后孵化过青果摄像头、二次元Gacha、严选等重要产品。<a id=\"more\"></a></p>\n<p>在多年的Android开发中，对于 Android 端产品开发，我们有如下几点体会：</p>\n<ol>\n<li><p>产品孵化排期紧张</p>\n</li>\n<li><p>基础模块的需求具有相似性</p>\n</li>\n<li><p>基础模块的选型和工具类具有可重用性</p>\n</li>\n<li><p>网络请求的代码具有机械性</p>\n</li>\n</ol>\n<p>对于各个基础模块，我们团队封装了自己的 SDK，如网络库、本地存储库、页面管理库、图片库等。使用我们的Activity模板生成的初始工程，就已经包含了我们提供的基础模块，产品团队的开发不需要再花费重复的时间做技术调研、选型、SDK封装集成等工作，而只需要关心自己的业务逻辑编写。我们期望产品团队只需 1 分钟就能得到自己的初始工程，并能马上投入业务逻辑开发，既能缩短开发周期，也能保证工程代码质量。</p>\n<h1 id=\"1-Android-模板简介\"><a href=\"#1-Android-模板简介\" class=\"headerlink\" title=\"1. Android 模板简介\"></a>1. Android 模板简介</h1><p>Android Studio 提供遵循 Android 设计和开发最佳实践的代码模板，以帮助我们快速并正确地创造出漂亮的、功能齐全的应用程序代码模板。Android Studio 中提供的模板列表在不断增加，按照它们添加的组件类型（如Activity或XML文件）可对模板进行如下分组：</p>\n<p><img src=\"http://i1.piimg.com/574381/beec462952f97623s.png\" alt=\"template menu\"></p>\n<blockquote>\n<p>可通过文件-&gt;新建菜单或在项目窗口中右键单击调出上述模板菜单。</p>\n</blockquote>\n<p>Android Studio 模板位置：</p>\n<p>Windows 的路径在 <code>${android studio 安装路径}/plugins/android/lib/templates/</code></p>\n<p>MacOS 的路径在 <code>${Android Studio.app 存放路径}/Contents/plugins/android/lib/templates/</code></p>\n<p>该文件夹具体内容如下：</p>\n<ul>\n<li><p>activities：Activity模板相关，如 EmptyActivity 文件夹用于创建一个空页面的模板，GoogleMapsActivity 文件夹对应创建一个地图页面的模板等</p>\n</li>\n<li><p>gradle：放置了 gradle 模板，用于在新建工程的根目录下生成 gradle 文件夹，支持用户不用安装 gradle 就能使用 gradlew 命令</p>\n</li>\n<li><p>gradle-project：工程模板相关，用于构建 module，Android Project，Java Library 等</p>\n</li>\n<li><p>other：构建文件模板等</p>\n</li>\n</ul>\n<p>模板最常见的用途之一是向现有应用程序模块添加新的 Activity。 activities 文件夹正是 Android Studio 默认提供的 Activity 模板，涵盖了手机和平板电脑应用中常用的 Activiy 模板。用户也可以参照已有模板自定义符合特定需求的 Activity 模板。</p>\n<h2 id=\"1-1-Activity-模板的文件结构\"><a href=\"#1-1-Activity-模板的文件结构\" class=\"headerlink\" title=\"1.1 Activity 模板的文件结构\"></a>1.1 Activity 模板的文件结构</h2><p>下面我们分析最简单的一个模板 EmptyActivity，我们首先查看下 EmtpyActivity (空白页面模板) 里面的内容</p>\n<p><img src=\"http://p1.bpimg.com/574381/8d1ddec0941bfe72.png\" alt=\"EmptyActivity Structrue\"></p>\n<blockquote>\n<p>Android Studio 使用的是 FreeMarker 模板引擎，所以文件后缀都是 .ftl</p>\n</blockquote>\n<ul>\n<li><p>globals.xml.ftl: 全局变量文件，保存一些全局变量，当中可以引用其他文件的全局变量</p>\n</li>\n<li><p>recipe.xml.ftl: 配置要引用的模板路径以及文件的生成规则</p>\n</li>\n<li><p>template.xml: 模板的配置信息，包括模板的显示图标，界面的表现，全局变量文件和执行文件的指定等</p>\n</li>\n<li><p>template_blank_activity.png: 显示的缩略图</p>\n</li>\n<li><p>SimpleActivity.java.ftl: Activity 模板文件</p>\n</li>\n</ul>\n<h2 id=\"1-2-代码生成流程\"><a href=\"#1-2-代码生成流程\" class=\"headerlink\" title=\"1.2 代码生成流程\"></a>1.2 代码生成流程</h2><p>目前我们已经基本了解了一个Activity模板的文件结构了，以及每个文件大致包含的东西，简单总结如下：</p>\n<ul>\n<li><p>template 中parameter标签，主要用于提供参数</p>\n</li>\n<li><p>global.xml.ftl 主要用于提供参数</p>\n</li>\n<li><p>recipe.xml.ftl 主要用于生成我们实际需要的代码，资源文件等</p>\n<blockquote>\n<p>例如，利用参数 + MainActivity.java.ftl -&gt; MainActivity.java，其实就是利用参数将ftl中的变量进行替换</p>\n</blockquote>\n</li>\n</ul>\n<p>代码生成过程如下图所示：</p>\n<p><img src=\"http://p1.bqimg.com/574381/c29d60650ace6c90.jpg\" alt=\"13_code_generation_process.jpg\"></p>\n<blockquote>\n<p>图片摘自 <a href=\"http://robusttechhouse.com/tutorial-how-to-create-custom-android-code-templates/\" target=\"_blank\" rel=\"external\">Tutorial How To Create Custom Android Code Templates</a></p>\n</blockquote>\n<h1 id=\"2-HTTemplate-Activity-模板实现\"><a href=\"#2-HTTemplate-Activity-模板实现\" class=\"headerlink\" title=\"2. HTTemplate Activity 模板实现\"></a>2. HTTemplate Activity 模板实现</h1><p>我们编写一个Activity模板叫作：HTTemplate，内容如下：</p>\n<p><img src=\"http://i1.piimg.com/574381/0fa65436eccbb6ce.png\" alt=\"HTTemplate Structrue\"></p>\n<h2 id=\"2-1-template-xml\"><a href=\"#2-1-template-xml\" class=\"headerlink\" title=\"2.1 template.xml\"></a>2.1 template.xml</h2><p>指定模板名、描述、最低支持 sdk 版本、类别等，输入界面要求指定包名和 Application 类名</p>\n<h2 id=\"2-2-globals-xml-ftl\"><a href=\"#2-2-globals-xml-ftl\" class=\"headerlink\" title=\"2.2 globals.xml.ftl\"></a>2.2 globals.xml.ftl</h2><p>引用公共文件内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class=\"line\">&lt;globals&gt;</div><div class=\"line\">    &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;</div><div class=\"line\">    &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;</div><div class=\"line\">&lt;/globals&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-recipe-xml-ftl\"><a href=\"#2-3-recipe-xml-ftl\" class=\"headerlink\" title=\"2.3 recipe.xml.ftl\"></a>2.3 recipe.xml.ftl</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class=\"line\">&lt;recipe&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- nei.json --&gt;</div><div class=\"line\">    &lt;instantiate from=&quot;root/nei.json.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(topOut)&#125;/nei.json&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- manifest --&gt;</div><div class=\"line\">    &lt;merge from=&quot;root/AndroidManifest.xml.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;merge from=&quot;root/AndroidManifestPermissions.xml&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- 全部资源 --&gt;</div><div class=\"line\">    &lt;copy from=&quot;root/res&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- libs 库 --&gt;</div><div class=\"line\">    &lt;copy from=&quot;root/libs&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(projectOut)&#125;/libs&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- gradle --&gt;</div><div class=\"line\">    &lt;merge from=&quot;root/project_build.gradle.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(topOut)&#125;/build.gradle&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;merge from=&quot;root/app_build.gradle.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(projectOut)&#125;/build.gradle&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- README --&gt;</div><div class=\"line\">    &lt;instantiate from=&quot;root/README.md.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(topOut)&#125;/README.md&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- proguard-rules.pro.ftl --&gt;</div><div class=\"line\">    &lt;copy from=&quot;root/proguard-rules.pro.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(projectOut)&#125;/proguard-rules.pro.template&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- java 代码 --&gt;</div><div class=\"line\">    &lt;!-- application 文件夹 --&gt;</div><div class=\"line\">    &lt;instantiate from=&quot;root/src/app_package/application/AppProfile.java.ftl&quot;</div><div class=\"line\">                   to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/application/AppProfile.java&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- attrs.xml --&gt;</div><div class=\"line\">    &lt;merge from=&quot;root/res/values/attrs.xml&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/values/attrs.xml&quot; /&gt;</div><div class=\"line\">             </div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">&lt;/recipe&gt;</div></pre></td></tr></table></figure>\n<p>省略部分代码，主要的工作是</p>\n<ul>\n<li><p>merge AndroidManifest.xml 文件</p>\n</li>\n<li><p>copy 或者 merge 资源文件</p>\n</li>\n<li><p>copy 或 instantiate java 代码</p>\n</li>\n<li><p>merge build.gradle 文件</p>\n</li>\n<li><p>merge settings.gradle 文件</p>\n</li>\n<li><p>copy lib 文件夹里面的全部内容</p>\n</li>\n<li><p>copy proguard-rules.pro 文件</p>\n</li>\n</ul>\n<h2 id=\"2-4-root-文件夹\"><a href=\"#2-4-root-文件夹\" class=\"headerlink\" title=\"2.4 root 文件夹\"></a>2.4 root 文件夹</h2><p><img src=\"http://i1.piimg.com/574381/134add19853d8905.png\" alt=\"root Structure\"></p>\n<p>放置相关模板源文件，包括一些Activity、自定义View、通用工具类等。将其中以<code>.ftl</code>为后缀的源代码，按照 FreeMarker 语法进行替换。例如，使用了包名的地方，需要替换成 <code>${packageName}</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">package $&#123;packageName&#125;.application;</div><div class=\"line\">import $&#123;packageName&#125;.R;</div></pre></td></tr></table></figure>\n<p>在gradle文件中配置私有maven库的地址、增加公用的依赖库、关闭lint的严格检查、配置APK多渠道打包等。</p>\n<h2 id=\"2-5-模板图标\"><a href=\"#2-5-模板图标\" class=\"headerlink\" title=\"2.5 模板图标\"></a>2.5 模板图标</h2><p>添加 Activity 模板图标，并在 template.xml 中添加引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;thumbs&gt;</div><div class=\"line\">    &lt;thumb&gt;template_thumb.png&lt;/thumb&gt;</div><div class=\"line\">&lt;/thumbs&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"2-6-使用-Activity-模板生成初始工程\"><a href=\"#2-6-使用-Activity-模板生成初始工程\" class=\"headerlink\" title=\"2.6 使用 Activity 模板生成初始工程\"></a>2.6 使用 Activity 模板生成初始工程</h2><p>将上述 HTTemplate 文件夹拷贝至 Android Studio 的 Activity 模板目录下：</p>\n<p>Windows 的路径在 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;android studio 安装路径&#125;/plugins/android/lib/templates/activities</div></pre></td></tr></table></figure>\n<p>MacOS 的路径在 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;Android Studio.app 存放路径&#125;/Contents/plugins/android/lib/templates/activities</div></pre></td></tr></table></figure>\n<p>重启 Android Studio，在新建工程过程中可以看到，出现了我们自定义的 Activity 模板项：</p>\n<p><img src=\"http://p1.bpimg.com/574381/af37bc8f7a18c791s.png\" alt=\"新建项目流程之选择Activity\"></p>\n<p>直接运行生成的项目，效果如下：</p>\n<p><img src=\"http://p1.bpimg.com/574381/cbe2f56ec299f5ee.gif\" alt=\"工程运行效果图\"></p>\n<p>到这里，使用我们的 Activity 模板生成的初始工程，就已经包含了我们提供的网络库、本地存储库、页面管理库、图片库等基础模块，开发人员接下来只需专注于业务逻辑的开发。</p>\n<h1 id=\"3-遇到的问题及解决方案\"><a href=\"#3-遇到的问题及解决方案\" class=\"headerlink\" title=\"3. 遇到的问题及解决方案\"></a>3. 遇到的问题及解决方案</h1><p>为分析问题的原因，我们找到了 Android 模板相关源码：</p>\n<p>Mac 平台：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;android studio安装路径&#125;/Contents/plugins/android/lib/android.jar</div></pre></td></tr></table></figure>\n<p>Windows 平台：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;android studio安装路径&#125;/plugins/android/lib/android.jar</div></pre></td></tr></table></figure>\n<p>以下问题的解答将涉及到部分源码。</p>\n<h2 id=\"3-1-通配符冲突\"><a href=\"#3-1-通配符冲突\" class=\"headerlink\" title=\"3.1 ${} 通配符冲突\"></a>3.1 ${} 通配符冲突</h2><p>当工程模板实例化时，${} 会被 FreeMarker 语法处理，导致错误。</p>\n<p>解决办法：定义 FreeMarker 转义字符如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ==&gt; $&#123;&quot;$&quot;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-Java-代码实例化问题\"><a href=\"#3-2-Java-代码实例化问题\" class=\"headerlink\" title=\"3.2 Java 代码实例化问题\"></a>3.2 Java 代码实例化问题</h2><p>模板中 java 代码较多，我们统一放在 root/src/ 文件夹下，里面有部分文件含有 FreeMarker 标签，有部分只是纯粹的 java 代码。而使用 instantiate 命令对整个文件夹进行实例化操作，并不会触发 FreeMarker 语法执行。</p>\n<p>解决办法：因 java 文件比较多，手写 recipe.xml 标签命令繁琐且容易出错。我们通过程序递归遍历 root/src/ 下的全部代码文件，并生成相应的 instantiate 或 copy 命令。</p>\n<h2 id=\"3-3-copy-和-instantiate-问题\"><a href=\"#3-3-copy-和-instantiate-问题\" class=\"headerlink\" title=\"3.3 copy 和 instantiate 问题\"></a>3.3 copy 和 instantiate 问题</h2><h3 id=\"1-gradle-properties-文件执行-copy-或者-instantiate-操作无效\"><a href=\"#1-gradle-properties-文件执行-copy-或者-instantiate-操作无效\" class=\"headerlink\" title=\"(1) gradle.properties 文件执行 copy 或者 instantiate 操作无效\"></a>(1) gradle.properties 文件执行 copy 或者 instantiate 操作无效</h3><p>分析结果：查看 DefaultRecipeExecutor.copy 与 DefaultRecipeExecutor.instantiate 源码处理逻辑，得知执行 copy 和 instantiate 命令时，如果 from 指定一个非文件夹，且目标文件存在，则不执行拷贝。而在执行我们的 Activity 模板之前，已经执行了 gradle-projects/NewAndroidProject 工程模板，并生成了 gradle.properties 文件，因此执行 copy 或 instantiate 都因目标文件已经存在而不再执行。</p>\n<h3 id=\"2-copy-和-instantiate-对文件夹操作的区别\"><a href=\"#2-copy-和-instantiate-对文件夹操作的区别\" class=\"headerlink\" title=\"(2) copy 和 instantiate 对文件夹操作的区别\"></a>(2) copy 和 instantiate 对文件夹操作的区别</h3><ul>\n<li><p>相同点：如果 from 指定一个文件夹，都是执行 copyTemplateResource 方法，二者没有区别；如果 from 指定一个非文件夹，且目标文件存在，则不执行文件操作。</p>\n</li>\n<li><p>不同点：copy 命令不使用 FreemarkerUtils 对 FreeMarker 语法进行处理，而 instantiate 命令先执行 FreemarkerUtils 的静态方法 processFreemarkerTemplate 来处理 FreeMarker 语法，之后再执行文件拷贝操作。</p>\n</li>\n</ul>\n<h2 id=\"3-4-merge-问题\"><a href=\"#3-4-merge-问题\" class=\"headerlink\" title=\"3.4 merge 问题\"></a>3.4 merge 问题</h2><h3 id=\"1-proguard-rules-pro、gradle-properties-文件执行-merge-操作失败\"><a href=\"#1-proguard-rules-pro、gradle-properties-文件执行-merge-操作失败\" class=\"headerlink\" title=\"(1) proguard-rules.pro、gradle.properties 文件执行 merge 操作失败\"></a>(1) proguard-rules.pro、gradle.properties 文件执行 merge 操作失败</h3><p>分析结果：根据 DefaultRecipeExecutor.merge 源码的逻辑，我们得知当 to 文件不存在，则执行 copy 或 instantiate 命令；如果 to 文件存在且可读，则仅对 xml 或 gradle 才能执行 merge 操作。</p>\n<p>解决办法：</p>\n<ul>\n<li><p>暂时生成 proguard-rules.pro.template 文件</p>\n</li>\n<li><p>将定义在 gradle.properties 中的常量移动到 project_build.gradle.ftl 的 ext{ } 内</p>\n</li>\n</ul>\n<h3 id=\"2-settings-gradle-文件合并，指定-module-路径错误\"><a href=\"#2-settings-gradle-文件合并，指定-module-路径错误\" class=\"headerlink\" title=\"(2) settings.gradle 文件合并，指定 module 路径错误\"></a>(2) settings.gradle 文件合并，指定 module 路径错误</h3><p>执行前：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">include &apos;:hteventbus&apos;, &apos;:htrefreshrecyclerview&apos;, &apos;:htrecycleview&apos;, &apos;:hthttp&apos;</div><div class=\"line\"></div><div class=\"line\">project(&apos;:hteventbus&apos;).projectDir = new File(&apos;module/hteventbus&apos;)</div><div class=\"line\">project(&apos;:hthttp&apos;).projectDir = new File(&apos;module/hthttp&apos;)</div><div class=\"line\">project(&apos;:htrefreshrecyclerview&apos;).projectDir = new File(&apos;module/htrefreshrecyclerview&apos;)</div><div class=\"line\">project(&apos;:htrecycleview&apos;).projectDir = new File(&apos;module/htrecycleview&apos;)</div></pre></td></tr></table></figure>\n<p>执行后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeException: java.lang.RuntimeException: When merging settings.gradle files, only include directives can be merged.</div></pre></td></tr></table></figure>\n<p>分析结果：查看 RecipeMergeUtils.mergeGradleSettingsFile 源码，得知当 settings.gradle 文件合并时，只允许每行开头是 include 命令，其他情况抛出异常。</p>\n<p>解决办法：去掉非 include 的操作代码，改用远程依赖引用这些 module，即在 dependencies{ } 中添加相应的依赖。</p>\n<h3 id=\"3-build-gradle-文件合并，apply-语句合并错误\"><a href=\"#3-build-gradle-文件合并，apply-语句合并错误\" class=\"headerlink\" title=\"(3) build.gradle 文件合并，apply 语句合并错误\"></a>(3) build.gradle 文件合并，apply 语句合并错误</h3><p>执行前：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;com.neenbedankt.android-apt&apos;</div></pre></td></tr></table></figure>\n<p>执行后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;com.neenbedankt.android-apt&apos; plugin: &apos;com.android.application&apos;</div></pre></td></tr></table></figure>\n<p>分析结果：查看 GradleFileMerger 中的 mergeGradleFiles 方法，实际执行的是 mergePsi 方法，根据 mergePsi 合并逻辑，apply 不是 call 语句，且 apply 的第一个子元素不是 dependencies，因此添加 plugin: ‘com.neenbedankt.android-apt’ 到 toRoot 的 apply 子元素前面。</p>\n<p>解决办法：根据上面的分析，看起来 apply 的这个合成结果是 Android 模板的 bug，我们目前只能采用手工添加 apply 语句的方法。</p>\n<h3 id=\"4-build-gradle-文件合并，dependencies-内的-apt-语句消失\"><a href=\"#4-build-gradle-文件合并，dependencies-内的-apt-语句消失\" class=\"headerlink\" title=\"(4) build.gradle 文件合并，dependencies{ } 内的 apt 语句消失\"></a>(4) build.gradle 文件合并，dependencies{ } 内的 apt 语句消失</h3><p>执行前：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile &quot;com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION&quot;</div><div class=\"line\">    apt &quot;com.netease.hearttouch:ht-universalrouter-dispatch-process:$HEARTTOUCH_HTROUTER_DISPATCH_PROCESS_VERSION&quot;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile &quot;com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION&quot;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>分析结果：查看 GradleFileMerger.mergeDependencies 源码，得知当 dependencies 合并时，仅处理 dependencies 中的 compile 子元素，其他如 apt、provided 命令都会被忽略掉。</p>\n<p>解决办法：由于源码并未提供非 compile 子元素的合并方案，我们目前只能采用手工添加 apt 语句的方法。</p>\n<h1 id=\"4-小结和后续工作\"><a href=\"#4-小结和后续工作\" class=\"headerlink\" title=\"4. 小结和后续工作\"></a>4. 小结和后续工作</h1><p>到此，基本上完成了我们原先期望实现的初始工程：</p>\n<ol>\n<li><p>提供 ht-template 支持生成我们的模板工程</p>\n</li>\n<li><p>提供 Android Studio 插件 (NEIPlugin)</p>\n</li>\n</ol>\n<ul>\n<li><p>支持 ht-template 的下载安装</p>\n</li>\n<li><p>nei-toolkit 和 Node.js 的下载安装</p>\n</li>\n<li><p>nei-toolkit 和 Node.js 的使用，生成网络请求代码</p>\n</li>\n</ul>\n<p>这里还是有一些因为 Android 模板自身的限制而无法完成的内容点：</p>\n<ol>\n<li><p>无法在 settings.gradle 指定 module 路径</p>\n</li>\n<li><p>无法合并 proguard-rules.pro 文件，暂时生成 proguard-rules.pro.template 文件</p>\n</li>\n<li><p>由于 build.gradle 对 apply 命令合并会出错和无法合并 dependencies 中的 apt 命令，所以无法在 build.gradle 中集成 ht-universalrouter</p>\n</li>\n</ol>\n<p>此外，除了网络请求的代码编写是机械性的，基于我们的 Activity 模板生成的初始工程，在其他方面也存在代码编写的机械性：初始页面代码生成、RecycleView 中的各个 ViewHolder 类、本地数据读取保存等，而这些工作将会是我们的后续工作。</p>\n","excerpt":"<p>我们网易前端技术部 - 移动技术组作为公司的移动端基础技术部门，主要为其他部门提供解决方案、技术支持和产品孵化。在几年的积累过程中，我们拥有一些自己的框架和 SDK，如轻应用框架、热更新 SDK、网络请求库、本地存储库、页面管理等。服务过网易新闻、云音乐、考拉、易信等亿级产品，先后孵化过青果摄像头、二次元Gacha、严选等重要产品。","more":"</p>\n<p>在多年的Android开发中，对于 Android 端产品开发，我们有如下几点体会：</p>\n<ol>\n<li><p>产品孵化排期紧张</p>\n</li>\n<li><p>基础模块的需求具有相似性</p>\n</li>\n<li><p>基础模块的选型和工具类具有可重用性</p>\n</li>\n<li><p>网络请求的代码具有机械性</p>\n</li>\n</ol>\n<p>对于各个基础模块，我们团队封装了自己的 SDK，如网络库、本地存储库、页面管理库、图片库等。使用我们的Activity模板生成的初始工程，就已经包含了我们提供的基础模块，产品团队的开发不需要再花费重复的时间做技术调研、选型、SDK封装集成等工作，而只需要关心自己的业务逻辑编写。我们期望产品团队只需 1 分钟就能得到自己的初始工程，并能马上投入业务逻辑开发，既能缩短开发周期，也能保证工程代码质量。</p>\n<h1 id=\"1-Android-模板简介\"><a href=\"#1-Android-模板简介\" class=\"headerlink\" title=\"1. Android 模板简介\"></a>1. Android 模板简介</h1><p>Android Studio 提供遵循 Android 设计和开发最佳实践的代码模板，以帮助我们快速并正确地创造出漂亮的、功能齐全的应用程序代码模板。Android Studio 中提供的模板列表在不断增加，按照它们添加的组件类型（如Activity或XML文件）可对模板进行如下分组：</p>\n<p><img src=\"http://i1.piimg.com/574381/beec462952f97623s.png\" alt=\"template menu\"></p>\n<blockquote>\n<p>可通过文件-&gt;新建菜单或在项目窗口中右键单击调出上述模板菜单。</p>\n</blockquote>\n<p>Android Studio 模板位置：</p>\n<p>Windows 的路径在 <code>${android studio 安装路径}/plugins/android/lib/templates/</code></p>\n<p>MacOS 的路径在 <code>${Android Studio.app 存放路径}/Contents/plugins/android/lib/templates/</code></p>\n<p>该文件夹具体内容如下：</p>\n<ul>\n<li><p>activities：Activity模板相关，如 EmptyActivity 文件夹用于创建一个空页面的模板，GoogleMapsActivity 文件夹对应创建一个地图页面的模板等</p>\n</li>\n<li><p>gradle：放置了 gradle 模板，用于在新建工程的根目录下生成 gradle 文件夹，支持用户不用安装 gradle 就能使用 gradlew 命令</p>\n</li>\n<li><p>gradle-project：工程模板相关，用于构建 module，Android Project，Java Library 等</p>\n</li>\n<li><p>other：构建文件模板等</p>\n</li>\n</ul>\n<p>模板最常见的用途之一是向现有应用程序模块添加新的 Activity。 activities 文件夹正是 Android Studio 默认提供的 Activity 模板，涵盖了手机和平板电脑应用中常用的 Activiy 模板。用户也可以参照已有模板自定义符合特定需求的 Activity 模板。</p>\n<h2 id=\"1-1-Activity-模板的文件结构\"><a href=\"#1-1-Activity-模板的文件结构\" class=\"headerlink\" title=\"1.1 Activity 模板的文件结构\"></a>1.1 Activity 模板的文件结构</h2><p>下面我们分析最简单的一个模板 EmptyActivity，我们首先查看下 EmtpyActivity (空白页面模板) 里面的内容</p>\n<p><img src=\"http://p1.bpimg.com/574381/8d1ddec0941bfe72.png\" alt=\"EmptyActivity Structrue\"></p>\n<blockquote>\n<p>Android Studio 使用的是 FreeMarker 模板引擎，所以文件后缀都是 .ftl</p>\n</blockquote>\n<ul>\n<li><p>globals.xml.ftl: 全局变量文件，保存一些全局变量，当中可以引用其他文件的全局变量</p>\n</li>\n<li><p>recipe.xml.ftl: 配置要引用的模板路径以及文件的生成规则</p>\n</li>\n<li><p>template.xml: 模板的配置信息，包括模板的显示图标，界面的表现，全局变量文件和执行文件的指定等</p>\n</li>\n<li><p>template_blank_activity.png: 显示的缩略图</p>\n</li>\n<li><p>SimpleActivity.java.ftl: Activity 模板文件</p>\n</li>\n</ul>\n<h2 id=\"1-2-代码生成流程\"><a href=\"#1-2-代码生成流程\" class=\"headerlink\" title=\"1.2 代码生成流程\"></a>1.2 代码生成流程</h2><p>目前我们已经基本了解了一个Activity模板的文件结构了，以及每个文件大致包含的东西，简单总结如下：</p>\n<ul>\n<li><p>template 中parameter标签，主要用于提供参数</p>\n</li>\n<li><p>global.xml.ftl 主要用于提供参数</p>\n</li>\n<li><p>recipe.xml.ftl 主要用于生成我们实际需要的代码，资源文件等</p>\n<blockquote>\n<p>例如，利用参数 + MainActivity.java.ftl -&gt; MainActivity.java，其实就是利用参数将ftl中的变量进行替换</p>\n</blockquote>\n</li>\n</ul>\n<p>代码生成过程如下图所示：</p>\n<p><img src=\"http://p1.bqimg.com/574381/c29d60650ace6c90.jpg\" alt=\"13_code_generation_process.jpg\"></p>\n<blockquote>\n<p>图片摘自 <a href=\"http://robusttechhouse.com/tutorial-how-to-create-custom-android-code-templates/\">Tutorial How To Create Custom Android Code Templates</a></p>\n</blockquote>\n<h1 id=\"2-HTTemplate-Activity-模板实现\"><a href=\"#2-HTTemplate-Activity-模板实现\" class=\"headerlink\" title=\"2. HTTemplate Activity 模板实现\"></a>2. HTTemplate Activity 模板实现</h1><p>我们编写一个Activity模板叫作：HTTemplate，内容如下：</p>\n<p><img src=\"http://i1.piimg.com/574381/0fa65436eccbb6ce.png\" alt=\"HTTemplate Structrue\"></p>\n<h2 id=\"2-1-template-xml\"><a href=\"#2-1-template-xml\" class=\"headerlink\" title=\"2.1 template.xml\"></a>2.1 template.xml</h2><p>指定模板名、描述、最低支持 sdk 版本、类别等，输入界面要求指定包名和 Application 类名</p>\n<h2 id=\"2-2-globals-xml-ftl\"><a href=\"#2-2-globals-xml-ftl\" class=\"headerlink\" title=\"2.2 globals.xml.ftl\"></a>2.2 globals.xml.ftl</h2><p>引用公共文件内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class=\"line\">&lt;globals&gt;</div><div class=\"line\">    &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;</div><div class=\"line\">    &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;</div><div class=\"line\">&lt;/globals&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-recipe-xml-ftl\"><a href=\"#2-3-recipe-xml-ftl\" class=\"headerlink\" title=\"2.3 recipe.xml.ftl\"></a>2.3 recipe.xml.ftl</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class=\"line\">&lt;recipe&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- nei.json --&gt;</div><div class=\"line\">    &lt;instantiate from=&quot;root/nei.json.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(topOut)&#125;/nei.json&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- manifest --&gt;</div><div class=\"line\">    &lt;merge from=&quot;root/AndroidManifest.xml.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;merge from=&quot;root/AndroidManifestPermissions.xml&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- 全部资源 --&gt;</div><div class=\"line\">    &lt;copy from=&quot;root/res&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- libs 库 --&gt;</div><div class=\"line\">    &lt;copy from=&quot;root/libs&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(projectOut)&#125;/libs&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- gradle --&gt;</div><div class=\"line\">    &lt;merge from=&quot;root/project_build.gradle.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(topOut)&#125;/build.gradle&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;merge from=&quot;root/app_build.gradle.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(projectOut)&#125;/build.gradle&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- README --&gt;</div><div class=\"line\">    &lt;instantiate from=&quot;root/README.md.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(topOut)&#125;/README.md&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- proguard-rules.pro.ftl --&gt;</div><div class=\"line\">    &lt;copy from=&quot;root/proguard-rules.pro.ftl&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(projectOut)&#125;/proguard-rules.pro.template&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- java 代码 --&gt;</div><div class=\"line\">    &lt;!-- application 文件夹 --&gt;</div><div class=\"line\">    &lt;instantiate from=&quot;root/src/app_package/application/AppProfile.java.ftl&quot;</div><div class=\"line\">                   to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/application/AppProfile.java&quot; /&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- attrs.xml --&gt;</div><div class=\"line\">    &lt;merge from=&quot;root/res/values/attrs.xml&quot;</div><div class=\"line\">             to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/values/attrs.xml&quot; /&gt;</div><div class=\"line\">             </div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">&lt;/recipe&gt;</div></pre></td></tr></table></figure>\n<p>省略部分代码，主要的工作是</p>\n<ul>\n<li><p>merge AndroidManifest.xml 文件</p>\n</li>\n<li><p>copy 或者 merge 资源文件</p>\n</li>\n<li><p>copy 或 instantiate java 代码</p>\n</li>\n<li><p>merge build.gradle 文件</p>\n</li>\n<li><p>merge settings.gradle 文件</p>\n</li>\n<li><p>copy lib 文件夹里面的全部内容</p>\n</li>\n<li><p>copy proguard-rules.pro 文件</p>\n</li>\n</ul>\n<h2 id=\"2-4-root-文件夹\"><a href=\"#2-4-root-文件夹\" class=\"headerlink\" title=\"2.4 root 文件夹\"></a>2.4 root 文件夹</h2><p><img src=\"http://i1.piimg.com/574381/134add19853d8905.png\" alt=\"root Structure\"></p>\n<p>放置相关模板源文件，包括一些Activity、自定义View、通用工具类等。将其中以<code>.ftl</code>为后缀的源代码，按照 FreeMarker 语法进行替换。例如，使用了包名的地方，需要替换成 <code>${packageName}</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">package $&#123;packageName&#125;.application;</div><div class=\"line\">import $&#123;packageName&#125;.R;</div></pre></td></tr></table></figure>\n<p>在gradle文件中配置私有maven库的地址、增加公用的依赖库、关闭lint的严格检查、配置APK多渠道打包等。</p>\n<h2 id=\"2-5-模板图标\"><a href=\"#2-5-模板图标\" class=\"headerlink\" title=\"2.5 模板图标\"></a>2.5 模板图标</h2><p>添加 Activity 模板图标，并在 template.xml 中添加引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;thumbs&gt;</div><div class=\"line\">    &lt;thumb&gt;template_thumb.png&lt;/thumb&gt;</div><div class=\"line\">&lt;/thumbs&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"2-6-使用-Activity-模板生成初始工程\"><a href=\"#2-6-使用-Activity-模板生成初始工程\" class=\"headerlink\" title=\"2.6 使用 Activity 模板生成初始工程\"></a>2.6 使用 Activity 模板生成初始工程</h2><p>将上述 HTTemplate 文件夹拷贝至 Android Studio 的 Activity 模板目录下：</p>\n<p>Windows 的路径在 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;android studio 安装路径&#125;/plugins/android/lib/templates/activities</div></pre></td></tr></table></figure>\n<p>MacOS 的路径在 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;Android Studio.app 存放路径&#125;/Contents/plugins/android/lib/templates/activities</div></pre></td></tr></table></figure>\n<p>重启 Android Studio，在新建工程过程中可以看到，出现了我们自定义的 Activity 模板项：</p>\n<p><img src=\"http://p1.bpimg.com/574381/af37bc8f7a18c791s.png\" alt=\"新建项目流程之选择Activity\"></p>\n<p>直接运行生成的项目，效果如下：</p>\n<p><img src=\"http://p1.bpimg.com/574381/cbe2f56ec299f5ee.gif\" alt=\"工程运行效果图\"></p>\n<p>到这里，使用我们的 Activity 模板生成的初始工程，就已经包含了我们提供的网络库、本地存储库、页面管理库、图片库等基础模块，开发人员接下来只需专注于业务逻辑的开发。</p>\n<h1 id=\"3-遇到的问题及解决方案\"><a href=\"#3-遇到的问题及解决方案\" class=\"headerlink\" title=\"3. 遇到的问题及解决方案\"></a>3. 遇到的问题及解决方案</h1><p>为分析问题的原因，我们找到了 Android 模板相关源码：</p>\n<p>Mac 平台：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;android studio安装路径&#125;/Contents/plugins/android/lib/android.jar</div></pre></td></tr></table></figure>\n<p>Windows 平台：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$&#123;android studio安装路径&#125;/plugins/android/lib/android.jar</div></pre></td></tr></table></figure>\n<p>以下问题的解答将涉及到部分源码。</p>\n<h2 id=\"3-1-通配符冲突\"><a href=\"#3-1-通配符冲突\" class=\"headerlink\" title=\"3.1 ${} 通配符冲突\"></a>3.1 ${} 通配符冲突</h2><p>当工程模板实例化时，${} 会被 FreeMarker 语法处理，导致错误。</p>\n<p>解决办法：定义 FreeMarker 转义字符如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ==&gt; $&#123;&quot;$&quot;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-Java-代码实例化问题\"><a href=\"#3-2-Java-代码实例化问题\" class=\"headerlink\" title=\"3.2 Java 代码实例化问题\"></a>3.2 Java 代码实例化问题</h2><p>模板中 java 代码较多，我们统一放在 root/src/ 文件夹下，里面有部分文件含有 FreeMarker 标签，有部分只是纯粹的 java 代码。而使用 instantiate 命令对整个文件夹进行实例化操作，并不会触发 FreeMarker 语法执行。</p>\n<p>解决办法：因 java 文件比较多，手写 recipe.xml 标签命令繁琐且容易出错。我们通过程序递归遍历 root/src/ 下的全部代码文件，并生成相应的 instantiate 或 copy 命令。</p>\n<h2 id=\"3-3-copy-和-instantiate-问题\"><a href=\"#3-3-copy-和-instantiate-问题\" class=\"headerlink\" title=\"3.3 copy 和 instantiate 问题\"></a>3.3 copy 和 instantiate 问题</h2><h3 id=\"1-gradle-properties-文件执行-copy-或者-instantiate-操作无效\"><a href=\"#1-gradle-properties-文件执行-copy-或者-instantiate-操作无效\" class=\"headerlink\" title=\"(1) gradle.properties 文件执行 copy 或者 instantiate 操作无效\"></a>(1) gradle.properties 文件执行 copy 或者 instantiate 操作无效</h3><p>分析结果：查看 DefaultRecipeExecutor.copy 与 DefaultRecipeExecutor.instantiate 源码处理逻辑，得知执行 copy 和 instantiate 命令时，如果 from 指定一个非文件夹，且目标文件存在，则不执行拷贝。而在执行我们的 Activity 模板之前，已经执行了 gradle-projects/NewAndroidProject 工程模板，并生成了 gradle.properties 文件，因此执行 copy 或 instantiate 都因目标文件已经存在而不再执行。</p>\n<h3 id=\"2-copy-和-instantiate-对文件夹操作的区别\"><a href=\"#2-copy-和-instantiate-对文件夹操作的区别\" class=\"headerlink\" title=\"(2) copy 和 instantiate 对文件夹操作的区别\"></a>(2) copy 和 instantiate 对文件夹操作的区别</h3><ul>\n<li><p>相同点：如果 from 指定一个文件夹，都是执行 copyTemplateResource 方法，二者没有区别；如果 from 指定一个非文件夹，且目标文件存在，则不执行文件操作。</p>\n</li>\n<li><p>不同点：copy 命令不使用 FreemarkerUtils 对 FreeMarker 语法进行处理，而 instantiate 命令先执行 FreemarkerUtils 的静态方法 processFreemarkerTemplate 来处理 FreeMarker 语法，之后再执行文件拷贝操作。</p>\n</li>\n</ul>\n<h2 id=\"3-4-merge-问题\"><a href=\"#3-4-merge-问题\" class=\"headerlink\" title=\"3.4 merge 问题\"></a>3.4 merge 问题</h2><h3 id=\"1-proguard-rules-pro、gradle-properties-文件执行-merge-操作失败\"><a href=\"#1-proguard-rules-pro、gradle-properties-文件执行-merge-操作失败\" class=\"headerlink\" title=\"(1) proguard-rules.pro、gradle.properties 文件执行 merge 操作失败\"></a>(1) proguard-rules.pro、gradle.properties 文件执行 merge 操作失败</h3><p>分析结果：根据 DefaultRecipeExecutor.merge 源码的逻辑，我们得知当 to 文件不存在，则执行 copy 或 instantiate 命令；如果 to 文件存在且可读，则仅对 xml 或 gradle 才能执行 merge 操作。</p>\n<p>解决办法：</p>\n<ul>\n<li><p>暂时生成 proguard-rules.pro.template 文件</p>\n</li>\n<li><p>将定义在 gradle.properties 中的常量移动到 project_build.gradle.ftl 的 ext{ } 内</p>\n</li>\n</ul>\n<h3 id=\"2-settings-gradle-文件合并，指定-module-路径错误\"><a href=\"#2-settings-gradle-文件合并，指定-module-路径错误\" class=\"headerlink\" title=\"(2) settings.gradle 文件合并，指定 module 路径错误\"></a>(2) settings.gradle 文件合并，指定 module 路径错误</h3><p>执行前：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">include &apos;:hteventbus&apos;, &apos;:htrefreshrecyclerview&apos;, &apos;:htrecycleview&apos;, &apos;:hthttp&apos;</div><div class=\"line\"></div><div class=\"line\">project(&apos;:hteventbus&apos;).projectDir = new File(&apos;module/hteventbus&apos;)</div><div class=\"line\">project(&apos;:hthttp&apos;).projectDir = new File(&apos;module/hthttp&apos;)</div><div class=\"line\">project(&apos;:htrefreshrecyclerview&apos;).projectDir = new File(&apos;module/htrefreshrecyclerview&apos;)</div><div class=\"line\">project(&apos;:htrecycleview&apos;).projectDir = new File(&apos;module/htrecycleview&apos;)</div></pre></td></tr></table></figure>\n<p>执行后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeException: java.lang.RuntimeException: When merging settings.gradle files, only include directives can be merged.</div></pre></td></tr></table></figure>\n<p>分析结果：查看 RecipeMergeUtils.mergeGradleSettingsFile 源码，得知当 settings.gradle 文件合并时，只允许每行开头是 include 命令，其他情况抛出异常。</p>\n<p>解决办法：去掉非 include 的操作代码，改用远程依赖引用这些 module，即在 dependencies{ } 中添加相应的依赖。</p>\n<h3 id=\"3-build-gradle-文件合并，apply-语句合并错误\"><a href=\"#3-build-gradle-文件合并，apply-语句合并错误\" class=\"headerlink\" title=\"(3) build.gradle 文件合并，apply 语句合并错误\"></a>(3) build.gradle 文件合并，apply 语句合并错误</h3><p>执行前：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;com.neenbedankt.android-apt&apos;</div></pre></td></tr></table></figure>\n<p>执行后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;com.neenbedankt.android-apt&apos; plugin: &apos;com.android.application&apos;</div></pre></td></tr></table></figure>\n<p>分析结果：查看 GradleFileMerger 中的 mergeGradleFiles 方法，实际执行的是 mergePsi 方法，根据 mergePsi 合并逻辑，apply 不是 call 语句，且 apply 的第一个子元素不是 dependencies，因此添加 plugin: ‘com.neenbedankt.android-apt’ 到 toRoot 的 apply 子元素前面。</p>\n<p>解决办法：根据上面的分析，看起来 apply 的这个合成结果是 Android 模板的 bug，我们目前只能采用手工添加 apply 语句的方法。</p>\n<h3 id=\"4-build-gradle-文件合并，dependencies-内的-apt-语句消失\"><a href=\"#4-build-gradle-文件合并，dependencies-内的-apt-语句消失\" class=\"headerlink\" title=\"(4) build.gradle 文件合并，dependencies{ } 内的 apt 语句消失\"></a>(4) build.gradle 文件合并，dependencies{ } 内的 apt 语句消失</h3><p>执行前：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile &quot;com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION&quot;</div><div class=\"line\">    apt &quot;com.netease.hearttouch:ht-universalrouter-dispatch-process:$HEARTTOUCH_HTROUTER_DISPATCH_PROCESS_VERSION&quot;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile &quot;com.netease.hearttouch:ht-universalrouter-dispatch:$HEARTTOUCH_HTROUTER_DISPATCH_VERSION&quot;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>分析结果：查看 GradleFileMerger.mergeDependencies 源码，得知当 dependencies 合并时，仅处理 dependencies 中的 compile 子元素，其他如 apt、provided 命令都会被忽略掉。</p>\n<p>解决办法：由于源码并未提供非 compile 子元素的合并方案，我们目前只能采用手工添加 apt 语句的方法。</p>\n<h1 id=\"4-小结和后续工作\"><a href=\"#4-小结和后续工作\" class=\"headerlink\" title=\"4. 小结和后续工作\"></a>4. 小结和后续工作</h1><p>到此，基本上完成了我们原先期望实现的初始工程：</p>\n<ol>\n<li><p>提供 ht-template 支持生成我们的模板工程</p>\n</li>\n<li><p>提供 Android Studio 插件 (NEIPlugin)</p>\n</li>\n</ol>\n<ul>\n<li><p>支持 ht-template 的下载安装</p>\n</li>\n<li><p>nei-toolkit 和 Node.js 的下载安装</p>\n</li>\n<li><p>nei-toolkit 和 Node.js 的使用，生成网络请求代码</p>\n</li>\n</ul>\n<p>这里还是有一些因为 Android 模板自身的限制而无法完成的内容点：</p>\n<ol>\n<li><p>无法在 settings.gradle 指定 module 路径</p>\n</li>\n<li><p>无法合并 proguard-rules.pro 文件，暂时生成 proguard-rules.pro.template 文件</p>\n</li>\n<li><p>由于 build.gradle 对 apply 命令合并会出错和无法合并 dependencies 中的 apt 命令，所以无法在 build.gradle 中集成 ht-universalrouter</p>\n</li>\n</ol>\n<p>此外，除了网络请求的代码编写是机械性的，基于我们的 Activity 模板生成的初始工程，在其他方面也存在代码编写的机械性：初始页面代码生成、RecycleView 中的各个 ViewHolder 类、本地数据读取保存等，而这些工作将会是我们的后续工作。</p>"},{"title":"关于LLVM，这些东西你必须要知道","date":"2016-12-28T16:00:00.000Z","author":"刘培庆","_content":"只要你和代码打交道，了解编译器的工作流程和原理定会让你受益无穷，无论是分析程序，还是基于它写自己的插件，甚至学习一门全新的语音。通过本文，将带你了解LLVM，并使用LLVM来完成一些有意思的事情。<!-- more -->\n\n## 1. 什么是LLVM？\n\n>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.\n\n简单来说，LLVM项目是一系列分模块、可重用的编译工具链。它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。\n\n先来看下LLVM架构的主要组成部分：\n\n* 前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。\n* Pass(通常翻译为“流程”)：Pass用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。\n* 后端：后端用来生成实际的机器码。\n\n虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。传统的编译器的架构如下:\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136450962.png\"/></center>\n\nLLVM的架构如下：\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136601642.png\"/></center>\n\n当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端就行了。其它部分完成可以复用，就不用再重新设计一次了。\n\n## 2. 安装编译LLVM\n\n这里使用clang作为前端:\n\n1. 直接从官网下载:[http://releases.llvm.org/download.html\n](http://releases.llvm.org/download.html)\n\n2. svn获取\n\n```\nsvn co http://llvm.org/svn/llvm-project/llvm/trunk llvm\ncd llvm/tools\nsvn co http://llvm.org/svn/llvm-project/cfe/trunk clang\ncd ../projects\nsvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt\ncd ../tools/clang/tools\nsvn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra\n```\n\n3. git获取\n\n```\ngit clone http://llvm.org/git/llvm.git\ncd llvm/tools\ngit clone http://llvm.org/git/clang.git\ncd ../projects\ngit clone http://llvm.org/git/compiler-rt.git\ncd ../tools/clang/tools\ngit clone http://llvm.org/git/clang-tools-extra.git\n```\n\n最新的LLVM只支持cmake来编译了，首先安装cmake。\n\n```\nbrew install cmake\n```\n\n编译：\n\n```\nmkdir build\ncmake /path/to/llvm/source\ncmake --build .\n```\n\n编译时间比较长，而且编译结果会生成20G左右的文件。\n\n编译完成后，就能在`build/bin/`目录下面找到生成的工具了。\n\n## 3. 从源码到可执行文件\n\n我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？\n\n我们先来一个例子：\n\n```\n#import <Foundation/Foundation.h>\n\n#define TEN 10\n\nint main(){\n    @autoreleasepool {\n        int numberOne = TEN;\n        int numberTwo = 8;\n        NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"];\n        int age = numberOne + numberTwo;\n        NSLog(@\"Hello, %@, Age: %d\", name, age);\n    }\n    return 0;\n}\n```\n\n上面这个文件，我们可以通过命令行直接编译，然后链接：\n\n```\nxcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o\nxcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main\n```\n\n拷贝到手机运行：\n\n```\nmonkeyde-iPhone:/tmp root# ./main\n2016-12-19 17:16:34.654 main[2164:213100] Hello, AloneMonkey, Age: 18\n```\n\n大家不会以为就这样就完了吧，当然不是，我们要继续深入剖析。\n\n### 3.1 预处理（Preprocess）\n\n这部分包括macro宏的展开，import/include头文件的导入，以及#if等处理。\n\n\n可以通过执行以下命令，来告诉clang只执行到预处理这一步：\n\n```\nclang -E main.m\n```\n\n执行完这个命令之后，我们会发现导入了很多的头文件内容。\n\n```\n......\n# 1 \"/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h\" 1 3\n# 185 \"/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h\" 2 3\n# 2 \"main.m\" 2\n\nint main(){\n    @autoreleasepool {\n        int numberOne = 10;\n        int numberTwo = 8;\n        NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"];\n        int age = numberOne + numberTwo;\n        NSLog(@\"Hello, %@, Age: %d\", name, age);\n    }\n    return 0;\n}\n```\n\n可以看到上面的预处理已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation，所以有了pch预处理文件，可以在这里去引入一些通用的头文件。\n\n后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入，默认会加上-fmodules参数。\n\n```\nclang -E -fmodules main.m\n```\n\n这样的话，只需要@import一下就能导入对应库的modules模块了。\n\n```\n@import Foundation; \nint main(){\n    @autoreleasepool {\n        int numberOne = 10;\n        int numberTwo = 8;\n        NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"];\n        int age = numberOne + numberTwo;\n        NSLog(@\"Hello, %@, Age: %d\", name, age);\n    }\n    return 0;\n}\n```\n\n### 3.2 词法分析 (Lexical Analysis)\n\n在预处理之后，就要进行词法分析了，将预处理过的代码转化成一个个Token，比如左括号、右括号、等于、字符串等等。\n\n\n```\nclang -fmodules -fsyntax-only -Xclang -dump-tokens main.m\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994028068.png)\n\n### 3.3 语法分析 (Semantic Analysis)\n\n根据当前语言的语法，验证语法是否正确，并将所有节点组合成抽象语法树(AST)\n\n```\nclang -fmodules -fsyntax-only -Xclang -ast-dump main.m\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994071651.png)\n\n语法树直观图:\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482150626825.png)\n\n\n### 3.4 IR代码生成 (CodeGen)\n\nCodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。\n\n可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别`-O1`,`-O3`,`-Os`。 还可以去写一些自己的Pass，这里需要解释一下什么是Pass。\n\nPass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。\n\n```\nclang -S -fobjc-arc -emit-llvm main.m -o main.ll\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994093995.png)\n\n\n### 3.5 生成字节码 (LLVM Bitcode)\n\n我们在Xcode7中默认生成bitcode就是这种的中间形式存在， 开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。\n\n```\nclang -emit-llvm -c main.m -o main.bc\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218230417.png)\n\n### 3.6 生成相关汇编\n\n```\nclang -S -fobjc-arc main.m -o main.s\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994171109.png)\n\n\n### 3.7 生成目标文件\n\n```\nclang -fmodules -c main.m -o main.o\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218636504.png)\n\n### 3.8 生成可执行文件\n\n```\nclang main.o -o main\n./main\n```\n\n```\n2016-12-20 15:25:42.299 main[8941:327306] Hello, AloneMonkey, Age: 18\n```\n\n### 3.9 整体流程\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482219005958.png)\n\n## 4. 可以用Clang做什么？\n\n### 4.1 libclang进行语法分析\n\n可以使用libclang里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。\n\n来看一段代码的使用：\n\n```\nvoid *hand = dlopen(\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib\",RTLD_LAZY);\n        \n//初始化函数指针\ninitlibfunclist(hand);\n\nCXIndex cxindex = myclang_createIndex(1, 1);\n\nconst char *filename = \"/path/to/filename\";\n\nint index = 0;\n\nconst char ** new_command = malloc(10240);\n\nNSMutableString *mus = [NSMutableString stringWithString:@\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch armv7 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk\"]; \n\nNSArray *arr = [mus componentsSeparatedByString:@\" \"];\n\nfor (NSString *tmp in arr) {\n    new_command[index++] = [tmp UTF8String];\n}\n\nnameArr = [[NSMutableArray alloc] initWithCapacity:10];\n\nTU = myclang_parseTranslationUnit(cxindex, filename, new_command, index, NULL, 0, myclang_defaultEditingTranslationUnitOptions());\n\nCXCursor rootCursor = myclang_getTranslationUnitCursor(TU);\n\nmyclang_visitChildren(rootCursor, printVisitor, NULL);\n\nmyclang_disposeTranslationUnit(TU);\nmyclang_disposeIndex(cxindex);\nfree(new_command);\n\ndlclose(hand);\n```\n\n然后我们就可以在`printVisitor`这个函数里面去遍历输入文件的语法树了。\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994195691.png)\n\n\n我们也通过通过python去调用用clang：\n\n```\npip install clang\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994863704.png)\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994879267.png)\n\n那么基于语法树的分析，我们可以针对字符串做加密：\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320827975.png\"/></center>\n\n从左上角的明文字符串，处理成右下角的介个样子~\n\n### 4.2 LibTooling\n\n对语法树有完全的控制权，可以作为一个单独的命令使用，如：`clang-format`\n\n```\nclang-format main.m\n```\n\n我们也可以自己写一个这样的工具去遍历、访问、甚至修改语法树。 目录:`llvm/tools/clang/tools`\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994222169.png)\n\n上面的代码通过遍历语法树，去修改里面的方法名和返回变量名：\n\n```\nbefore:\nvoid do_math(int *x) {\n    *x += 5;\n}\n\nint main(void) {\n    int result = -1, val = 4;\n    do_math(&val);\n    return result;\n}\n\nafter:\n** Rewrote function def: do_math\n** Rewrote function call\n** Rewrote ReturnStmt\n\nFound 2 functions.\n\nvoid add5(int *x) {\n    *x += 5;\n}\n\nint main(void) {\n    int result = -1, val = 4;\n    add5(&val);\n    return val;\n}\n```\n\n那么，我们看到`LibTooling`对代码的语法树有完全的控制，那么我们可以基于它去检查命名的规范，甚至做一个代码的转换，比如实现OC转Swift。\n\n### 4.3 ClangPlugin\n\n对语法树有完全的控制权，作为插件注入到编译流程中，可以影响build和决定编译过程。目录:`llvm/tools/clang/examples`\n\n```\n#include \"clang/Driver/Options.h\"\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/Frontend/ASTConsumers.h\"\n#include \"clang/Frontend/FrontendActions.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n#include \"clang/Rewrite/Core/Rewriter.h\"\n\nusing namespace std;\nusing namespace clang;\nusing namespace llvm;\n\nRewriter rewriter;\nint numFunctions = 0;\n\n\nclass ExampleVisitor : public RecursiveASTVisitor<ExampleVisitor> {\nprivate:\n    ASTContext *astContext; // used for getting additional AST info\n\npublic:\n    explicit ExampleVisitor(CompilerInstance *CI) \n      : astContext(&(CI->getASTContext())) // initialize private members\n    {\n        rewriter.setSourceMgr(astContext->getSourceManager(), astContext->getLangOpts());\n    }\n\n    virtual bool VisitFunctionDecl(FunctionDecl *func) {\n        numFunctions++;\n        string funcName = func->getNameInfo().getName().getAsString();\n        if (funcName == \"do_math\") {\n            rewriter.ReplaceText(func->getLocation(), funcName.length(), \"add5\");\n            errs() << \"** Rewrote function def: \" << funcName << \"\\n\";\n        }    \n        return true;\n    }\n\n    virtual bool VisitStmt(Stmt *st) {\n        if (ReturnStmt *ret = dyn_cast<ReturnStmt>(st)) {\n            rewriter.ReplaceText(ret->getRetValue()->getLocStart(), 6, \"val\");\n            errs() << \"** Rewrote ReturnStmt\\n\";\n        }        \n        if (CallExpr *call = dyn_cast<CallExpr>(st)) {\n            rewriter.ReplaceText(call->getLocStart(), 7, \"add5\");\n            errs() << \"** Rewrote function call\\n\";\n        }\n        return true;\n    }\n};\n\n\n\nclass ExampleASTConsumer : public ASTConsumer {\nprivate:\n    ExampleVisitor *visitor; // doesn't have to be private\n\npublic:\n    // override the constructor in order to pass CI\n    explicit ExampleASTConsumer(CompilerInstance *CI):\n        visitor(new ExampleVisitor(CI)) { } // initialize the visitor\n\n    // override this to call our ExampleVisitor on the entire source file\n    virtual void HandleTranslationUnit(ASTContext &Context) {\n        /* we can use ASTContext to get the TranslationUnitDecl, which is\n             a single Decl that collectively represents the entire source file */\n        visitor->TraverseDecl(Context.getTranslationUnitDecl());\n    }\n};\n\nclass PluginExampleAction : public PluginASTAction {\nprotected:\n    // this gets called by Clang when it invokes our Plugin\n    // Note that unique pointer is used here.\n    std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI, StringRef file) {\n        return llvm::make_unique<ExampleASTConsumer>(&CI);\n    }\n\n    // implement this function if you want to parse custom cmd-line args\n    bool ParseArgs(const CompilerInstance &CI, const vector<string> &args) {\n        return true;\n    }\n};\n\n\nstatic FrontendPluginRegistry::Add<PluginExampleAction> X(\"-example-plugin\", \"simple Plugin example\");\n```\n\n```\nclang -Xclang -load -Xclang ../build/lib/PluginExample.dylib -Xclang -plugin -Xclang -example-plugin -c testPlugin.c\n\n** Rewrote function def: do_math\n** Rewrote function call\n** Rewrote ReturnStmt\n```\n\n我们可以基于ClangPlugin做些什么事情呢？我们可以用来定义一些编码规范，比如代码风格检查，命名检查等等。下面是我写的判断类名前两个字母是不是大写的例子，如果不是报错。(当然这只是一个例子而已。。。)\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482318703701.png)\n\n## 5. 动手写Pass\n\n### 5.1 一个简单的Pass\n\n前面我们说到，Pass就是LLVM系统转化和优化的工作的一个节点，当然我们也可以写一个这样的节点去做一些自己的优化工作或者其它的操作。下面我们来看一下一个简单Pass的编写流程：\n\n1.创建头文件  \n\n```\ncd llvm/include/llvm/Transforms/\nmkdir Obfuscation\ncd Obfuscation\ntouch SimplePass.h\n```\n\n写入内容：\n\n```\n#include \"llvm/IR/Function.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/LegacyPassManager.h\"\n#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n\n// Namespace\nusing namespace std;\n\nnamespace llvm {\n\tPass *createSimplePass(bool flag);\n}\n```\n\n2.创建源文件\n\n```\ncd llvm/lib/Transforms/\nmkdir Obfuscation\ncd Obfuscation\n\ntouch CMakeLists.txt\ntouch LLVMBuild.txt\ntouch SimplePass.cpp\n```\n\nCMakeLists.txt:\n\n```\nadd_llvm_loadable_module(LLVMObfuscation\n  SimplePass.cpp\n  \n  )\n\n  add_dependencies(LLVMObfuscation intrinsics_gen)\n```\n\nLLVMBuild.txt:\n\n```\n[component_0]\ntype = Library\nname = Obfuscation\nparent = Transforms\nlibrary_name = Obfuscation\n```\n\nSimplePass.cpp:\n\n```\n#include \"llvm/Transforms/Obfuscation/SimplePass.h\"\n\nusing namespace llvm;\n\nnamespace {\n    struct SimplePass : public FunctionPass {\n        static char ID; // Pass identification, replacement for typeid\n        bool flag;\n         \n        SimplePass() : FunctionPass(ID) {}\n        SimplePass(bool flag) : FunctionPass(ID) {\n        \tthis->flag = flag;\n        }\n         \n        bool runOnFunction(Function &F) override {\n        \tif(this->flag){\n                Function *tmp = &F;\n                // 遍历函数中的所有基本块\n                for (Function::iterator bb = tmp->begin(); bb != tmp->end(); ++bb) {\n                    // 遍历基本块中的每条指令\n                    for (BasicBlock::iterator inst = bb->begin(); inst != bb->end(); ++inst) {\n                        // 是否是add指令\n                        if (inst->isBinaryOp()) {\n                            if (inst->getOpcode() == Instruction::Add) {\n                                ob_add(cast<BinaryOperator>(inst));\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n         \n        // a+b === a-(-b)\n        void ob_add(BinaryOperator *bo) {\n            BinaryOperator *op = NULL;\n             \n            if (bo->getOpcode() == Instruction::Add) {\n                // 生成 (－b)\n                op = BinaryOperator::CreateNeg(bo->getOperand(1), \"\", bo);\n                // 生成 a-(-b)\n                op = BinaryOperator::Create(Instruction::Sub, bo->getOperand(0), op, \"\", bo);\n                 \n                op->setHasNoSignedWrap(bo->hasNoSignedWrap());\n                op->setHasNoUnsignedWrap(bo->hasNoUnsignedWrap());\n            }\n             \n            // 替换所有出现该指令的地方\n            bo->replaceAllUsesWith(op);\n        }\n    };\n}\n \nchar SimplePass::ID = 0;\n \n// 注册pass 命令行选项显示为simplepass\nstatic RegisterPass<SimplePass> X(\"simplepass\", \"this is a Simple Pass\");\nPass *llvm::createSimplePass() { return new SimplePass(); }\n```\n\n修改`.../Transforms/LLVMBuild.txt`, 加上刚刚写的模块`Obfuscation`\n\n```\nsubdirectories = Coroutines IPO InstCombine Instrumentation Scalar Utils Vectorize ObjCARC Obfuscation\n```\n修改`.../Transforms/CMakeLists.txt`,  加上刚刚写的模块`Obfuscation`\n\n```\nadd_subdirectory(Obfuscation)\n```\n\n编译生成：`LLVMSimplePass.dylib`\n\n因为Pass是作用于中间代码，所以我们首先要生成一份中间代码：\n\n```\nclang -emit-llvm -c test.c -o test.bc\n```\n\n然后加载Pass优化：\n\n```\n../build/bin/opt -load ../build/lib/LLVMSimplePass.dylib -test < test.bc > after_test.bc\n```\n\n对比中间代码：\n\n```\nllvm-dis test.bc -o test.ll\nllvm-dis after_test.bc -o after_test.ll\n```\n\n```\ntest.ll\n......\nentry:\n  %retval = alloca i32, align 4\n  %a = alloca i32, align 4\n  %b = alloca i32, align 4\n  %c = alloca i32, align 4\n  store i32 0, i32* %retval, align 4\n  store i32 3, i32* %a, align 4\n  store i32 4, i32* %b, align 4\n  %0 = load i32, i32* %a, align 4\n  %1 = load i32, i32* %b, align 4\n  %add = add nsw i32 %0, %1\n  store i32 %add, i32* %c, align 4\n  %2 = load i32, i32* %c, align 4\n  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %2)\n  ret i32 0\n}\n......\n```\n\n```\nafter_test.ll\n......\nentry:\n  %retval = alloca i32, align 4\n  %a = alloca i32, align 4\n  %b = alloca i32, align 4\n  %c = alloca i32, align 4\n  store i32 0, i32* %retval, align 4\n  store i32 3, i32* %a, align 4\n  store i32 4, i32* %b, align 4\n  %0 = load i32, i32* %a, align 4\n  %1 = load i32, i32* %b, align 4\n  %2 = sub i32 0, %1\n  %3 = sub nsw i32 %0, %2\n  %add = add nsw i32 %0, %1\n  store i32 %3, i32* %c, align 4\n  %4 = load i32, i32* %c, align 4\n  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %4)\n  ret i32 0\n}\n......\n```\n\n这里写的Pass只是把a+b简单的替换成了a-(-b),只是一个演示，怎么去写自己的Pass，并且作用于代码。\n\n### 5.2 将Pass加入PassManager管理\n\n上面我们是单独去加载Pass动态库，这里我们将Pass加入PassManager，这样我们就可以直接通过clang的参数去加载我们的Pass了。\n\n首先在`llvm/lib/Transforms/IPO/PassManagerBuilder.cpp`添加头文件。\n\n```\n#include \"llvm/Transforms/Obfuscation/SimplePass.h\"\n```\n\n然后添加如下语句：\n\n```\nstatic cl::opt<bool> SimplePass(\"simplepass\", cl::init(false),\n                           cl::desc(\"Enable simple pass\"));\n```\n\n然后在`populateModulePassManager`这个函数中添加如下代码：\n\n```\nMPM.add(createSimplePass(SimplePass));\n```\n\n最后在IPO这个目录的`LLVMBuild.txt`中添加库的支持，否则在编译的时候会提示链接错误。具体内容如下：\n\n```\nrequired_libraries = Analysis Core InstCombine IRReader Linker Object ProfileData Scalar Support TransformUtils Vectorize Obfuscation\n```\n\n修改Pass的CMakeLists.txt为静态库形式：\n\n```\nadd_llvm_library(LLVMObfuscation\n  SimplePass.cpp\n  )\n\nadd_dependencies(LLVMObfuscation intrinsics_gen)\n```\n\n最后再编译一次。\n\n那么我们可以这么去调用：\n\n```\n../build/bin/clang -mllvm -simplepass test.c -o after_test\n```\n\n基于Pass，我们可以做什么？ 我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320959711.png\"/></center>\n\n我们可以把代码左上角的样子，变成右下角的样子，甚至更加复杂~ \n\n## 6. 总结\n\n上面说了那么说，来总结一下：\n\n1.LLVM编译一个源文件的过程：\n\n预处理 -> 词法分析 -> Token -> 语法分析 -> AST -> 代码生成 -> LLVM IR -> 优化 -> 生成汇编代码 -> Link -> 目标文件\n\n2.基于LLVM，我们可以做什么？\n\n1. 做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。\n2. 编写ClangPlugin，命名规范，代码规范，扩展功能。\n3. 编写Pass，代码混淆优化。\n\n这篇只是一个简单的入门介绍，个人还需要深入去学习LLVM，再给大家分享，如有问题，欢迎拍砖~  \n\n","source":"_posts/ios/关于LLVM这些东西你必须要知道 .md","raw":"---\ntitle: 关于LLVM，这些东西你必须要知道\n\ndate: 2016-12-29\n\nauthor: 刘培庆\n\ncategory: ios\n\ntags: \n- LLVM\n\n---\n只要你和代码打交道，了解编译器的工作流程和原理定会让你受益无穷，无论是分析程序，还是基于它写自己的插件，甚至学习一门全新的语音。通过本文，将带你了解LLVM，并使用LLVM来完成一些有意思的事情。<!-- more -->\n\n## 1. 什么是LLVM？\n\n>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.\n\n简单来说，LLVM项目是一系列分模块、可重用的编译工具链。它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。\n\n先来看下LLVM架构的主要组成部分：\n\n* 前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。\n* Pass(通常翻译为“流程”)：Pass用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。\n* 后端：后端用来生成实际的机器码。\n\n虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。传统的编译器的架构如下:\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136450962.png\"/></center>\n\nLLVM的架构如下：\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136601642.png\"/></center>\n\n当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端就行了。其它部分完成可以复用，就不用再重新设计一次了。\n\n## 2. 安装编译LLVM\n\n这里使用clang作为前端:\n\n1. 直接从官网下载:[http://releases.llvm.org/download.html\n](http://releases.llvm.org/download.html)\n\n2. svn获取\n\n```\nsvn co http://llvm.org/svn/llvm-project/llvm/trunk llvm\ncd llvm/tools\nsvn co http://llvm.org/svn/llvm-project/cfe/trunk clang\ncd ../projects\nsvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt\ncd ../tools/clang/tools\nsvn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra\n```\n\n3. git获取\n\n```\ngit clone http://llvm.org/git/llvm.git\ncd llvm/tools\ngit clone http://llvm.org/git/clang.git\ncd ../projects\ngit clone http://llvm.org/git/compiler-rt.git\ncd ../tools/clang/tools\ngit clone http://llvm.org/git/clang-tools-extra.git\n```\n\n最新的LLVM只支持cmake来编译了，首先安装cmake。\n\n```\nbrew install cmake\n```\n\n编译：\n\n```\nmkdir build\ncmake /path/to/llvm/source\ncmake --build .\n```\n\n编译时间比较长，而且编译结果会生成20G左右的文件。\n\n编译完成后，就能在`build/bin/`目录下面找到生成的工具了。\n\n## 3. 从源码到可执行文件\n\n我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？\n\n我们先来一个例子：\n\n```\n#import <Foundation/Foundation.h>\n\n#define TEN 10\n\nint main(){\n    @autoreleasepool {\n        int numberOne = TEN;\n        int numberTwo = 8;\n        NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"];\n        int age = numberOne + numberTwo;\n        NSLog(@\"Hello, %@, Age: %d\", name, age);\n    }\n    return 0;\n}\n```\n\n上面这个文件，我们可以通过命令行直接编译，然后链接：\n\n```\nxcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o\nxcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main\n```\n\n拷贝到手机运行：\n\n```\nmonkeyde-iPhone:/tmp root# ./main\n2016-12-19 17:16:34.654 main[2164:213100] Hello, AloneMonkey, Age: 18\n```\n\n大家不会以为就这样就完了吧，当然不是，我们要继续深入剖析。\n\n### 3.1 预处理（Preprocess）\n\n这部分包括macro宏的展开，import/include头文件的导入，以及#if等处理。\n\n\n可以通过执行以下命令，来告诉clang只执行到预处理这一步：\n\n```\nclang -E main.m\n```\n\n执行完这个命令之后，我们会发现导入了很多的头文件内容。\n\n```\n......\n# 1 \"/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h\" 1 3\n# 185 \"/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h\" 2 3\n# 2 \"main.m\" 2\n\nint main(){\n    @autoreleasepool {\n        int numberOne = 10;\n        int numberTwo = 8;\n        NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"];\n        int age = numberOne + numberTwo;\n        NSLog(@\"Hello, %@, Age: %d\", name, age);\n    }\n    return 0;\n}\n```\n\n可以看到上面的预处理已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation，所以有了pch预处理文件，可以在这里去引入一些通用的头文件。\n\n后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入，默认会加上-fmodules参数。\n\n```\nclang -E -fmodules main.m\n```\n\n这样的话，只需要@import一下就能导入对应库的modules模块了。\n\n```\n@import Foundation; \nint main(){\n    @autoreleasepool {\n        int numberOne = 10;\n        int numberTwo = 8;\n        NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"];\n        int age = numberOne + numberTwo;\n        NSLog(@\"Hello, %@, Age: %d\", name, age);\n    }\n    return 0;\n}\n```\n\n### 3.2 词法分析 (Lexical Analysis)\n\n在预处理之后，就要进行词法分析了，将预处理过的代码转化成一个个Token，比如左括号、右括号、等于、字符串等等。\n\n\n```\nclang -fmodules -fsyntax-only -Xclang -dump-tokens main.m\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994028068.png)\n\n### 3.3 语法分析 (Semantic Analysis)\n\n根据当前语言的语法，验证语法是否正确，并将所有节点组合成抽象语法树(AST)\n\n```\nclang -fmodules -fsyntax-only -Xclang -ast-dump main.m\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994071651.png)\n\n语法树直观图:\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482150626825.png)\n\n\n### 3.4 IR代码生成 (CodeGen)\n\nCodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。\n\n可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别`-O1`,`-O3`,`-Os`。 还可以去写一些自己的Pass，这里需要解释一下什么是Pass。\n\nPass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。\n\n```\nclang -S -fobjc-arc -emit-llvm main.m -o main.ll\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994093995.png)\n\n\n### 3.5 生成字节码 (LLVM Bitcode)\n\n我们在Xcode7中默认生成bitcode就是这种的中间形式存在， 开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。\n\n```\nclang -emit-llvm -c main.m -o main.bc\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218230417.png)\n\n### 3.6 生成相关汇编\n\n```\nclang -S -fobjc-arc main.m -o main.s\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994171109.png)\n\n\n### 3.7 生成目标文件\n\n```\nclang -fmodules -c main.m -o main.o\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218636504.png)\n\n### 3.8 生成可执行文件\n\n```\nclang main.o -o main\n./main\n```\n\n```\n2016-12-20 15:25:42.299 main[8941:327306] Hello, AloneMonkey, Age: 18\n```\n\n### 3.9 整体流程\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482219005958.png)\n\n## 4. 可以用Clang做什么？\n\n### 4.1 libclang进行语法分析\n\n可以使用libclang里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。\n\n来看一段代码的使用：\n\n```\nvoid *hand = dlopen(\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib\",RTLD_LAZY);\n        \n//初始化函数指针\ninitlibfunclist(hand);\n\nCXIndex cxindex = myclang_createIndex(1, 1);\n\nconst char *filename = \"/path/to/filename\";\n\nint index = 0;\n\nconst char ** new_command = malloc(10240);\n\nNSMutableString *mus = [NSMutableString stringWithString:@\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch armv7 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk\"]; \n\nNSArray *arr = [mus componentsSeparatedByString:@\" \"];\n\nfor (NSString *tmp in arr) {\n    new_command[index++] = [tmp UTF8String];\n}\n\nnameArr = [[NSMutableArray alloc] initWithCapacity:10];\n\nTU = myclang_parseTranslationUnit(cxindex, filename, new_command, index, NULL, 0, myclang_defaultEditingTranslationUnitOptions());\n\nCXCursor rootCursor = myclang_getTranslationUnitCursor(TU);\n\nmyclang_visitChildren(rootCursor, printVisitor, NULL);\n\nmyclang_disposeTranslationUnit(TU);\nmyclang_disposeIndex(cxindex);\nfree(new_command);\n\ndlclose(hand);\n```\n\n然后我们就可以在`printVisitor`这个函数里面去遍历输入文件的语法树了。\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994195691.png)\n\n\n我们也通过通过python去调用用clang：\n\n```\npip install clang\n```\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994863704.png)\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994879267.png)\n\n那么基于语法树的分析，我们可以针对字符串做加密：\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320827975.png\"/></center>\n\n从左上角的明文字符串，处理成右下角的介个样子~\n\n### 4.2 LibTooling\n\n对语法树有完全的控制权，可以作为一个单独的命令使用，如：`clang-format`\n\n```\nclang-format main.m\n```\n\n我们也可以自己写一个这样的工具去遍历、访问、甚至修改语法树。 目录:`llvm/tools/clang/tools`\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994222169.png)\n\n上面的代码通过遍历语法树，去修改里面的方法名和返回变量名：\n\n```\nbefore:\nvoid do_math(int *x) {\n    *x += 5;\n}\n\nint main(void) {\n    int result = -1, val = 4;\n    do_math(&val);\n    return result;\n}\n\nafter:\n** Rewrote function def: do_math\n** Rewrote function call\n** Rewrote ReturnStmt\n\nFound 2 functions.\n\nvoid add5(int *x) {\n    *x += 5;\n}\n\nint main(void) {\n    int result = -1, val = 4;\n    add5(&val);\n    return val;\n}\n```\n\n那么，我们看到`LibTooling`对代码的语法树有完全的控制，那么我们可以基于它去检查命名的规范，甚至做一个代码的转换，比如实现OC转Swift。\n\n### 4.3 ClangPlugin\n\n对语法树有完全的控制权，作为插件注入到编译流程中，可以影响build和决定编译过程。目录:`llvm/tools/clang/examples`\n\n```\n#include \"clang/Driver/Options.h\"\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/Frontend/ASTConsumers.h\"\n#include \"clang/Frontend/FrontendActions.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n#include \"clang/Rewrite/Core/Rewriter.h\"\n\nusing namespace std;\nusing namespace clang;\nusing namespace llvm;\n\nRewriter rewriter;\nint numFunctions = 0;\n\n\nclass ExampleVisitor : public RecursiveASTVisitor<ExampleVisitor> {\nprivate:\n    ASTContext *astContext; // used for getting additional AST info\n\npublic:\n    explicit ExampleVisitor(CompilerInstance *CI) \n      : astContext(&(CI->getASTContext())) // initialize private members\n    {\n        rewriter.setSourceMgr(astContext->getSourceManager(), astContext->getLangOpts());\n    }\n\n    virtual bool VisitFunctionDecl(FunctionDecl *func) {\n        numFunctions++;\n        string funcName = func->getNameInfo().getName().getAsString();\n        if (funcName == \"do_math\") {\n            rewriter.ReplaceText(func->getLocation(), funcName.length(), \"add5\");\n            errs() << \"** Rewrote function def: \" << funcName << \"\\n\";\n        }    \n        return true;\n    }\n\n    virtual bool VisitStmt(Stmt *st) {\n        if (ReturnStmt *ret = dyn_cast<ReturnStmt>(st)) {\n            rewriter.ReplaceText(ret->getRetValue()->getLocStart(), 6, \"val\");\n            errs() << \"** Rewrote ReturnStmt\\n\";\n        }        \n        if (CallExpr *call = dyn_cast<CallExpr>(st)) {\n            rewriter.ReplaceText(call->getLocStart(), 7, \"add5\");\n            errs() << \"** Rewrote function call\\n\";\n        }\n        return true;\n    }\n};\n\n\n\nclass ExampleASTConsumer : public ASTConsumer {\nprivate:\n    ExampleVisitor *visitor; // doesn't have to be private\n\npublic:\n    // override the constructor in order to pass CI\n    explicit ExampleASTConsumer(CompilerInstance *CI):\n        visitor(new ExampleVisitor(CI)) { } // initialize the visitor\n\n    // override this to call our ExampleVisitor on the entire source file\n    virtual void HandleTranslationUnit(ASTContext &Context) {\n        /* we can use ASTContext to get the TranslationUnitDecl, which is\n             a single Decl that collectively represents the entire source file */\n        visitor->TraverseDecl(Context.getTranslationUnitDecl());\n    }\n};\n\nclass PluginExampleAction : public PluginASTAction {\nprotected:\n    // this gets called by Clang when it invokes our Plugin\n    // Note that unique pointer is used here.\n    std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI, StringRef file) {\n        return llvm::make_unique<ExampleASTConsumer>(&CI);\n    }\n\n    // implement this function if you want to parse custom cmd-line args\n    bool ParseArgs(const CompilerInstance &CI, const vector<string> &args) {\n        return true;\n    }\n};\n\n\nstatic FrontendPluginRegistry::Add<PluginExampleAction> X(\"-example-plugin\", \"simple Plugin example\");\n```\n\n```\nclang -Xclang -load -Xclang ../build/lib/PluginExample.dylib -Xclang -plugin -Xclang -example-plugin -c testPlugin.c\n\n** Rewrote function def: do_math\n** Rewrote function call\n** Rewrote ReturnStmt\n```\n\n我们可以基于ClangPlugin做些什么事情呢？我们可以用来定义一些编码规范，比如代码风格检查，命名检查等等。下面是我写的判断类名前两个字母是不是大写的例子，如果不是报错。(当然这只是一个例子而已。。。)\n\n![image](http://7xtdl4.com1.z0.glb.clouddn.com/script_1482318703701.png)\n\n## 5. 动手写Pass\n\n### 5.1 一个简单的Pass\n\n前面我们说到，Pass就是LLVM系统转化和优化的工作的一个节点，当然我们也可以写一个这样的节点去做一些自己的优化工作或者其它的操作。下面我们来看一下一个简单Pass的编写流程：\n\n1.创建头文件  \n\n```\ncd llvm/include/llvm/Transforms/\nmkdir Obfuscation\ncd Obfuscation\ntouch SimplePass.h\n```\n\n写入内容：\n\n```\n#include \"llvm/IR/Function.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/LegacyPassManager.h\"\n#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n\n// Namespace\nusing namespace std;\n\nnamespace llvm {\n\tPass *createSimplePass(bool flag);\n}\n```\n\n2.创建源文件\n\n```\ncd llvm/lib/Transforms/\nmkdir Obfuscation\ncd Obfuscation\n\ntouch CMakeLists.txt\ntouch LLVMBuild.txt\ntouch SimplePass.cpp\n```\n\nCMakeLists.txt:\n\n```\nadd_llvm_loadable_module(LLVMObfuscation\n  SimplePass.cpp\n  \n  )\n\n  add_dependencies(LLVMObfuscation intrinsics_gen)\n```\n\nLLVMBuild.txt:\n\n```\n[component_0]\ntype = Library\nname = Obfuscation\nparent = Transforms\nlibrary_name = Obfuscation\n```\n\nSimplePass.cpp:\n\n```\n#include \"llvm/Transforms/Obfuscation/SimplePass.h\"\n\nusing namespace llvm;\n\nnamespace {\n    struct SimplePass : public FunctionPass {\n        static char ID; // Pass identification, replacement for typeid\n        bool flag;\n         \n        SimplePass() : FunctionPass(ID) {}\n        SimplePass(bool flag) : FunctionPass(ID) {\n        \tthis->flag = flag;\n        }\n         \n        bool runOnFunction(Function &F) override {\n        \tif(this->flag){\n                Function *tmp = &F;\n                // 遍历函数中的所有基本块\n                for (Function::iterator bb = tmp->begin(); bb != tmp->end(); ++bb) {\n                    // 遍历基本块中的每条指令\n                    for (BasicBlock::iterator inst = bb->begin(); inst != bb->end(); ++inst) {\n                        // 是否是add指令\n                        if (inst->isBinaryOp()) {\n                            if (inst->getOpcode() == Instruction::Add) {\n                                ob_add(cast<BinaryOperator>(inst));\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n         \n        // a+b === a-(-b)\n        void ob_add(BinaryOperator *bo) {\n            BinaryOperator *op = NULL;\n             \n            if (bo->getOpcode() == Instruction::Add) {\n                // 生成 (－b)\n                op = BinaryOperator::CreateNeg(bo->getOperand(1), \"\", bo);\n                // 生成 a-(-b)\n                op = BinaryOperator::Create(Instruction::Sub, bo->getOperand(0), op, \"\", bo);\n                 \n                op->setHasNoSignedWrap(bo->hasNoSignedWrap());\n                op->setHasNoUnsignedWrap(bo->hasNoUnsignedWrap());\n            }\n             \n            // 替换所有出现该指令的地方\n            bo->replaceAllUsesWith(op);\n        }\n    };\n}\n \nchar SimplePass::ID = 0;\n \n// 注册pass 命令行选项显示为simplepass\nstatic RegisterPass<SimplePass> X(\"simplepass\", \"this is a Simple Pass\");\nPass *llvm::createSimplePass() { return new SimplePass(); }\n```\n\n修改`.../Transforms/LLVMBuild.txt`, 加上刚刚写的模块`Obfuscation`\n\n```\nsubdirectories = Coroutines IPO InstCombine Instrumentation Scalar Utils Vectorize ObjCARC Obfuscation\n```\n修改`.../Transforms/CMakeLists.txt`,  加上刚刚写的模块`Obfuscation`\n\n```\nadd_subdirectory(Obfuscation)\n```\n\n编译生成：`LLVMSimplePass.dylib`\n\n因为Pass是作用于中间代码，所以我们首先要生成一份中间代码：\n\n```\nclang -emit-llvm -c test.c -o test.bc\n```\n\n然后加载Pass优化：\n\n```\n../build/bin/opt -load ../build/lib/LLVMSimplePass.dylib -test < test.bc > after_test.bc\n```\n\n对比中间代码：\n\n```\nllvm-dis test.bc -o test.ll\nllvm-dis after_test.bc -o after_test.ll\n```\n\n```\ntest.ll\n......\nentry:\n  %retval = alloca i32, align 4\n  %a = alloca i32, align 4\n  %b = alloca i32, align 4\n  %c = alloca i32, align 4\n  store i32 0, i32* %retval, align 4\n  store i32 3, i32* %a, align 4\n  store i32 4, i32* %b, align 4\n  %0 = load i32, i32* %a, align 4\n  %1 = load i32, i32* %b, align 4\n  %add = add nsw i32 %0, %1\n  store i32 %add, i32* %c, align 4\n  %2 = load i32, i32* %c, align 4\n  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %2)\n  ret i32 0\n}\n......\n```\n\n```\nafter_test.ll\n......\nentry:\n  %retval = alloca i32, align 4\n  %a = alloca i32, align 4\n  %b = alloca i32, align 4\n  %c = alloca i32, align 4\n  store i32 0, i32* %retval, align 4\n  store i32 3, i32* %a, align 4\n  store i32 4, i32* %b, align 4\n  %0 = load i32, i32* %a, align 4\n  %1 = load i32, i32* %b, align 4\n  %2 = sub i32 0, %1\n  %3 = sub nsw i32 %0, %2\n  %add = add nsw i32 %0, %1\n  store i32 %3, i32* %c, align 4\n  %4 = load i32, i32* %c, align 4\n  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %4)\n  ret i32 0\n}\n......\n```\n\n这里写的Pass只是把a+b简单的替换成了a-(-b),只是一个演示，怎么去写自己的Pass，并且作用于代码。\n\n### 5.2 将Pass加入PassManager管理\n\n上面我们是单独去加载Pass动态库，这里我们将Pass加入PassManager，这样我们就可以直接通过clang的参数去加载我们的Pass了。\n\n首先在`llvm/lib/Transforms/IPO/PassManagerBuilder.cpp`添加头文件。\n\n```\n#include \"llvm/Transforms/Obfuscation/SimplePass.h\"\n```\n\n然后添加如下语句：\n\n```\nstatic cl::opt<bool> SimplePass(\"simplepass\", cl::init(false),\n                           cl::desc(\"Enable simple pass\"));\n```\n\n然后在`populateModulePassManager`这个函数中添加如下代码：\n\n```\nMPM.add(createSimplePass(SimplePass));\n```\n\n最后在IPO这个目录的`LLVMBuild.txt`中添加库的支持，否则在编译的时候会提示链接错误。具体内容如下：\n\n```\nrequired_libraries = Analysis Core InstCombine IRReader Linker Object ProfileData Scalar Support TransformUtils Vectorize Obfuscation\n```\n\n修改Pass的CMakeLists.txt为静态库形式：\n\n```\nadd_llvm_library(LLVMObfuscation\n  SimplePass.cpp\n  )\n\nadd_dependencies(LLVMObfuscation intrinsics_gen)\n```\n\n最后再编译一次。\n\n那么我们可以这么去调用：\n\n```\n../build/bin/clang -mllvm -simplepass test.c -o after_test\n```\n\n基于Pass，我们可以做什么？ 我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。\n\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320959711.png\"/></center>\n\n我们可以把代码左上角的样子，变成右下角的样子，甚至更加复杂~ \n\n## 6. 总结\n\n上面说了那么说，来总结一下：\n\n1.LLVM编译一个源文件的过程：\n\n预处理 -> 词法分析 -> Token -> 语法分析 -> AST -> 代码生成 -> LLVM IR -> 优化 -> 生成汇编代码 -> Link -> 目标文件\n\n2.基于LLVM，我们可以做什么？\n\n1. 做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。\n2. 编写ClangPlugin，命名规范，代码规范，扩展功能。\n3. 编写Pass，代码混淆优化。\n\n这篇只是一个简单的入门介绍，个人还需要深入去学习LLVM，再给大家分享，如有问题，欢迎拍砖~  \n\n","slug":"ios/关于LLVM这些东西你必须要知道 ","published":1,"updated":"2017-01-05T06:15:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixk0c23x00047ekk4zbz5w17","content":"<p>只要你和代码打交道，了解编译器的工作流程和原理定会让你受益无穷，无论是分析程序，还是基于它写自己的插件，甚至学习一门全新的语音。通过本文，将带你了解LLVM，并使用LLVM来完成一些有意思的事情。<a id=\"more\"></a></p>\n<h2 id=\"1-什么是LLVM？\"><a href=\"#1-什么是LLVM？\" class=\"headerlink\" title=\"1. 什么是LLVM？\"></a>1. 什么是LLVM？</h2><blockquote>\n<p>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.</p>\n</blockquote>\n<p>简单来说，LLVM项目是一系列分模块、可重用的编译工具链。它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。</p>\n<p>先来看下LLVM架构的主要组成部分：</p>\n<ul>\n<li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li>\n<li>Pass(通常翻译为“流程”)：Pass用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。</li>\n<li>后端：后端用来生成实际的机器码。</li>\n</ul>\n<p>虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。传统的编译器的架构如下:</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136450962.png\"></center>\n\n<p>LLVM的架构如下：</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136601642.png\"></center>\n\n<p>当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端就行了。其它部分完成可以复用，就不用再重新设计一次了。</p>\n<h2 id=\"2-安装编译LLVM\"><a href=\"#2-安装编译LLVM\" class=\"headerlink\" title=\"2. 安装编译LLVM\"></a>2. 安装编译LLVM</h2><p>这里使用clang作为前端:</p>\n<ol>\n<li><p>直接从官网下载:<a href=\"http://releases.llvm.org/download.html\" target=\"_blank\" rel=\"external\">http://releases.llvm.org/download.html\n</a></p>\n</li>\n<li><p>svn获取</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div><div class=\"line\">cd llvm/tools</div><div class=\"line\">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div><div class=\"line\">cd ../projects</div><div class=\"line\">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div><div class=\"line\">cd ../tools/clang/tools</div><div class=\"line\">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</div></pre></td></tr></table></figure>\n<ol>\n<li>git获取</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone http://llvm.org/git/llvm.git</div><div class=\"line\">cd llvm/tools</div><div class=\"line\">git clone http://llvm.org/git/clang.git</div><div class=\"line\">cd ../projects</div><div class=\"line\">git clone http://llvm.org/git/compiler-rt.git</div><div class=\"line\">cd ../tools/clang/tools</div><div class=\"line\">git clone http://llvm.org/git/clang-tools-extra.git</div></pre></td></tr></table></figure>\n<p>最新的LLVM只支持cmake来编译了，首先安装cmake。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install cmake</div></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir build</div><div class=\"line\">cmake /path/to/llvm/source</div><div class=\"line\">cmake --build .</div></pre></td></tr></table></figure>\n<p>编译时间比较长，而且编译结果会生成20G左右的文件。</p>\n<p>编译完成后，就能在<code>build/bin/</code>目录下面找到生成的工具了。</p>\n<h2 id=\"3-从源码到可执行文件\"><a href=\"#3-从源码到可执行文件\" class=\"headerlink\" title=\"3. 从源码到可执行文件\"></a>3. 从源码到可执行文件</h2><p>我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？</p>\n<p>我们先来一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define TEN 10</div><div class=\"line\"></div><div class=\"line\">int main()&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        int numberOne = TEN;</div><div class=\"line\">        int numberTwo = 8;</div><div class=\"line\">        NSString* name = [[NSString alloc] initWithUTF8String:&quot;AloneMonkey&quot;];</div><div class=\"line\">        int age = numberOne + numberTwo;</div><div class=\"line\">        NSLog(@&quot;Hello, %@, Age: %d&quot;, name, age);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这个文件，我们可以通过命令行直接编译，然后链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o</div><div class=\"line\">xcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main</div></pre></td></tr></table></figure>\n<p>拷贝到手机运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">monkeyde-iPhone:/tmp root# ./main</div><div class=\"line\">2016-12-19 17:16:34.654 main[2164:213100] Hello, AloneMonkey, Age: 18</div></pre></td></tr></table></figure>\n<p>大家不会以为就这样就完了吧，当然不是，我们要继续深入剖析。</p>\n<h3 id=\"3-1-预处理（Preprocess）\"><a href=\"#3-1-预处理（Preprocess）\" class=\"headerlink\" title=\"3.1 预处理（Preprocess）\"></a>3.1 预处理（Preprocess）</h3><p>这部分包括macro宏的展开，import/include头文件的导入，以及#if等处理。</p>\n<p>可以通过执行以下命令，来告诉clang只执行到预处理这一步：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -E main.m</div></pre></td></tr></table></figure>\n<p>执行完这个命令之后，我们会发现导入了很多的头文件内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">......</div><div class=\"line\"># 1 &quot;/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot; 1 3</div><div class=\"line\"># 185 &quot;/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot; 2 3</div><div class=\"line\"># 2 &quot;main.m&quot; 2</div><div class=\"line\"></div><div class=\"line\">int main()&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        int numberOne = 10;</div><div class=\"line\">        int numberTwo = 8;</div><div class=\"line\">        NSString* name = [[NSString alloc] initWithUTF8String:&quot;AloneMonkey&quot;];</div><div class=\"line\">        int age = numberOne + numberTwo;</div><div class=\"line\">        NSLog(@&quot;Hello, %@, Age: %d&quot;, name, age);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到上面的预处理已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation，所以有了pch预处理文件，可以在这里去引入一些通用的头文件。</p>\n<p>后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入，默认会加上-fmodules参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -E -fmodules main.m</div></pre></td></tr></table></figure>\n<p>这样的话，只需要@import一下就能导入对应库的modules模块了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@import Foundation; </div><div class=\"line\">int main()&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        int numberOne = 10;</div><div class=\"line\">        int numberTwo = 8;</div><div class=\"line\">        NSString* name = [[NSString alloc] initWithUTF8String:&quot;AloneMonkey&quot;];</div><div class=\"line\">        int age = numberOne + numberTwo;</div><div class=\"line\">        NSLog(@&quot;Hello, %@, Age: %d&quot;, name, age);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-2-词法分析-Lexical-Analysis\"><a href=\"#3-2-词法分析-Lexical-Analysis\" class=\"headerlink\" title=\"3.2 词法分析 (Lexical Analysis)\"></a>3.2 词法分析 (Lexical Analysis)</h3><p>在预处理之后，就要进行词法分析了，将预处理过的代码转化成一个个Token，比如左括号、右括号、等于、字符串等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994028068.png\" alt=\"image\"></p>\n<h3 id=\"3-3-语法分析-Semantic-Analysis\"><a href=\"#3-3-语法分析-Semantic-Analysis\" class=\"headerlink\" title=\"3.3 语法分析 (Semantic Analysis)\"></a>3.3 语法分析 (Semantic Analysis)</h3><p>根据当前语言的语法，验证语法是否正确，并将所有节点组合成抽象语法树(AST)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994071651.png\" alt=\"image\"></p>\n<p>语法树直观图:</p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482150626825.png\" alt=\"image\"></p>\n<h3 id=\"3-4-IR代码生成-CodeGen\"><a href=\"#3-4-IR代码生成-CodeGen\" class=\"headerlink\" title=\"3.4 IR代码生成 (CodeGen)\"></a>3.4 IR代码生成 (CodeGen)</h3><p>CodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。</p>\n<p>可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别<code>-O1</code>,<code>-O3</code>,<code>-Os</code>。 还可以去写一些自己的Pass，这里需要解释一下什么是Pass。</p>\n<p>Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994093995.png\" alt=\"image\"></p>\n<h3 id=\"3-5-生成字节码-LLVM-Bitcode\"><a href=\"#3-5-生成字节码-LLVM-Bitcode\" class=\"headerlink\" title=\"3.5 生成字节码 (LLVM Bitcode)\"></a>3.5 生成字节码 (LLVM Bitcode)</h3><p>我们在Xcode7中默认生成bitcode就是这种的中间形式存在， 开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218230417.png\" alt=\"image\"></p>\n<h3 id=\"3-6-生成相关汇编\"><a href=\"#3-6-生成相关汇编\" class=\"headerlink\" title=\"3.6 生成相关汇编\"></a>3.6 生成相关汇编</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994171109.png\" alt=\"image\"></p>\n<h3 id=\"3-7-生成目标文件\"><a href=\"#3-7-生成目标文件\" class=\"headerlink\" title=\"3.7 生成目标文件\"></a>3.7 生成目标文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218636504.png\" alt=\"image\"></p>\n<h3 id=\"3-8-生成可执行文件\"><a href=\"#3-8-生成可执行文件\" class=\"headerlink\" title=\"3.8 生成可执行文件\"></a>3.8 生成可执行文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang main.o -o main</div><div class=\"line\">./main</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-12-20 15:25:42.299 main[8941:327306] Hello, AloneMonkey, Age: 18</div></pre></td></tr></table></figure>\n<h3 id=\"3-9-整体流程\"><a href=\"#3-9-整体流程\" class=\"headerlink\" title=\"3.9 整体流程\"></a>3.9 整体流程</h3><p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482219005958.png\" alt=\"image\"></p>\n<h2 id=\"4-可以用Clang做什么？\"><a href=\"#4-可以用Clang做什么？\" class=\"headerlink\" title=\"4. 可以用Clang做什么？\"></a>4. 可以用Clang做什么？</h2><h3 id=\"4-1-libclang进行语法分析\"><a href=\"#4-1-libclang进行语法分析\" class=\"headerlink\" title=\"4.1 libclang进行语法分析\"></a>4.1 libclang进行语法分析</h3><p>可以使用libclang里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。</p>\n<p>来看一段代码的使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">void *hand = dlopen(&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib&quot;,RTLD_LAZY);</div><div class=\"line\">        </div><div class=\"line\">//初始化函数指针</div><div class=\"line\">initlibfunclist(hand);</div><div class=\"line\"></div><div class=\"line\">CXIndex cxindex = myclang_createIndex(1, 1);</div><div class=\"line\"></div><div class=\"line\">const char *filename = &quot;/path/to/filename&quot;;</div><div class=\"line\"></div><div class=\"line\">int index = 0;</div><div class=\"line\"></div><div class=\"line\">const char ** new_command = malloc(10240);</div><div class=\"line\"></div><div class=\"line\">NSMutableString *mus = [NSMutableString stringWithString:@&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch armv7 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk&quot;]; </div><div class=\"line\"></div><div class=\"line\">NSArray *arr = [mus componentsSeparatedByString:@&quot; &quot;];</div><div class=\"line\"></div><div class=\"line\">for (NSString *tmp in arr) &#123;</div><div class=\"line\">    new_command[index++] = [tmp UTF8String];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">nameArr = [[NSMutableArray alloc] initWithCapacity:10];</div><div class=\"line\"></div><div class=\"line\">TU = myclang_parseTranslationUnit(cxindex, filename, new_command, index, NULL, 0, myclang_defaultEditingTranslationUnitOptions());</div><div class=\"line\"></div><div class=\"line\">CXCursor rootCursor = myclang_getTranslationUnitCursor(TU);</div><div class=\"line\"></div><div class=\"line\">myclang_visitChildren(rootCursor, printVisitor, NULL);</div><div class=\"line\"></div><div class=\"line\">myclang_disposeTranslationUnit(TU);</div><div class=\"line\">myclang_disposeIndex(cxindex);</div><div class=\"line\">free(new_command);</div><div class=\"line\"></div><div class=\"line\">dlclose(hand);</div></pre></td></tr></table></figure>\n<p>然后我们就可以在<code>printVisitor</code>这个函数里面去遍历输入文件的语法树了。</p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994195691.png\" alt=\"image\"></p>\n<p>我们也通过通过python去调用用clang：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install clang</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994863704.png\" alt=\"image\"></p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994879267.png\" alt=\"image\"></p>\n<p>那么基于语法树的分析，我们可以针对字符串做加密：</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320827975.png\"></center>\n\n<p>从左上角的明文字符串，处理成右下角的介个样子~</p>\n<h3 id=\"4-2-LibTooling\"><a href=\"#4-2-LibTooling\" class=\"headerlink\" title=\"4.2 LibTooling\"></a>4.2 LibTooling</h3><p>对语法树有完全的控制权，可以作为一个单独的命令使用，如：<code>clang-format</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang-format main.m</div></pre></td></tr></table></figure>\n<p>我们也可以自己写一个这样的工具去遍历、访问、甚至修改语法树。 目录:<code>llvm/tools/clang/tools</code></p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994222169.png\" alt=\"image\"></p>\n<p>上面的代码通过遍历语法树，去修改里面的方法名和返回变量名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">before:</div><div class=\"line\">void do_math(int *x) &#123;</div><div class=\"line\">    *x += 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(void) &#123;</div><div class=\"line\">    int result = -1, val = 4;</div><div class=\"line\">    do_math(&amp;val);</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">after:</div><div class=\"line\">** Rewrote function def: do_math</div><div class=\"line\">** Rewrote function call</div><div class=\"line\">** Rewrote ReturnStmt</div><div class=\"line\"></div><div class=\"line\">Found 2 functions.</div><div class=\"line\"></div><div class=\"line\">void add5(int *x) &#123;</div><div class=\"line\">    *x += 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(void) &#123;</div><div class=\"line\">    int result = -1, val = 4;</div><div class=\"line\">    add5(&amp;val);</div><div class=\"line\">    return val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们看到<code>LibTooling</code>对代码的语法树有完全的控制，那么我们可以基于它去检查命名的规范，甚至做一个代码的转换，比如实现OC转Swift。</p>\n<h3 id=\"4-3-ClangPlugin\"><a href=\"#4-3-ClangPlugin\" class=\"headerlink\" title=\"4.3 ClangPlugin\"></a>4.3 ClangPlugin</h3><p>对语法树有完全的控制权，作为插件注入到编译流程中，可以影响build和决定编译过程。目录:<code>llvm/tools/clang/examples</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;clang/Driver/Options.h&quot;</div><div class=\"line\">#include &quot;clang/AST/AST.h&quot;</div><div class=\"line\">#include &quot;clang/AST/ASTContext.h&quot;</div><div class=\"line\">#include &quot;clang/AST/ASTConsumer.h&quot;</div><div class=\"line\">#include &quot;clang/AST/RecursiveASTVisitor.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/ASTConsumers.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/FrontendActions.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/CompilerInstance.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;</div><div class=\"line\">#include &quot;clang/Rewrite/Core/Rewriter.h&quot;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\">using namespace clang;</div><div class=\"line\">using namespace llvm;</div><div class=\"line\"></div><div class=\"line\">Rewriter rewriter;</div><div class=\"line\">int numFunctions = 0;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class ExampleVisitor : public RecursiveASTVisitor&lt;ExampleVisitor&gt; &#123;</div><div class=\"line\">private:</div><div class=\"line\">    ASTContext *astContext; // used for getting additional AST info</div><div class=\"line\"></div><div class=\"line\">public:</div><div class=\"line\">    explicit ExampleVisitor(CompilerInstance *CI) </div><div class=\"line\">      : astContext(&amp;(CI-&gt;getASTContext())) // initialize private members</div><div class=\"line\">    &#123;</div><div class=\"line\">        rewriter.setSourceMgr(astContext-&gt;getSourceManager(), astContext-&gt;getLangOpts());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    virtual bool VisitFunctionDecl(FunctionDecl *func) &#123;</div><div class=\"line\">        numFunctions++;</div><div class=\"line\">        string funcName = func-&gt;getNameInfo().getName().getAsString();</div><div class=\"line\">        if (funcName == &quot;do_math&quot;) &#123;</div><div class=\"line\">            rewriter.ReplaceText(func-&gt;getLocation(), funcName.length(), &quot;add5&quot;);</div><div class=\"line\">            errs() &lt;&lt; &quot;** Rewrote function def: &quot; &lt;&lt; funcName &lt;&lt; &quot;\\n&quot;;</div><div class=\"line\">        &#125;    </div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    virtual bool VisitStmt(Stmt *st) &#123;</div><div class=\"line\">        if (ReturnStmt *ret = dyn_cast&lt;ReturnStmt&gt;(st)) &#123;</div><div class=\"line\">            rewriter.ReplaceText(ret-&gt;getRetValue()-&gt;getLocStart(), 6, &quot;val&quot;);</div><div class=\"line\">            errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;;</div><div class=\"line\">        &#125;        </div><div class=\"line\">        if (CallExpr *call = dyn_cast&lt;CallExpr&gt;(st)) &#123;</div><div class=\"line\">            rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;);</div><div class=\"line\">            errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class ExampleASTConsumer : public ASTConsumer &#123;</div><div class=\"line\">private:</div><div class=\"line\">    ExampleVisitor *visitor; // doesn&apos;t have to be private</div><div class=\"line\"></div><div class=\"line\">public:</div><div class=\"line\">    // override the constructor in order to pass CI</div><div class=\"line\">    explicit ExampleASTConsumer(CompilerInstance *CI):</div><div class=\"line\">        visitor(new ExampleVisitor(CI)) &#123; &#125; // initialize the visitor</div><div class=\"line\"></div><div class=\"line\">    // override this to call our ExampleVisitor on the entire source file</div><div class=\"line\">    virtual void HandleTranslationUnit(ASTContext &amp;Context) &#123;</div><div class=\"line\">        /* we can use ASTContext to get the TranslationUnitDecl, which is</div><div class=\"line\">             a single Decl that collectively represents the entire source file */</div><div class=\"line\">        visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class PluginExampleAction : public PluginASTAction &#123;</div><div class=\"line\">protected:</div><div class=\"line\">    // this gets called by Clang when it invokes our Plugin</div><div class=\"line\">    // Note that unique pointer is used here.</div><div class=\"line\">    std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef file) &#123;</div><div class=\"line\">        return llvm::make_unique&lt;ExampleASTConsumer&gt;(&amp;CI);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // implement this function if you want to parse custom cmd-line args</div><div class=\"line\">    bool ParseArgs(const CompilerInstance &amp;CI, const vector&lt;string&gt; &amp;args) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">static FrontendPluginRegistry::Add&lt;PluginExampleAction&gt; X(&quot;-example-plugin&quot;, &quot;simple Plugin example&quot;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -Xclang -load -Xclang ../build/lib/PluginExample.dylib -Xclang -plugin -Xclang -example-plugin -c testPlugin.c</div><div class=\"line\"></div><div class=\"line\">** Rewrote function def: do_math</div><div class=\"line\">** Rewrote function call</div><div class=\"line\">** Rewrote ReturnStmt</div></pre></td></tr></table></figure>\n<p>我们可以基于ClangPlugin做些什么事情呢？我们可以用来定义一些编码规范，比如代码风格检查，命名检查等等。下面是我写的判断类名前两个字母是不是大写的例子，如果不是报错。(当然这只是一个例子而已。。。)</p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482318703701.png\" alt=\"image\"></p>\n<h2 id=\"5-动手写Pass\"><a href=\"#5-动手写Pass\" class=\"headerlink\" title=\"5. 动手写Pass\"></a>5. 动手写Pass</h2><h3 id=\"5-1-一个简单的Pass\"><a href=\"#5-1-一个简单的Pass\" class=\"headerlink\" title=\"5.1 一个简单的Pass\"></a>5.1 一个简单的Pass</h3><p>前面我们说到，Pass就是LLVM系统转化和优化的工作的一个节点，当然我们也可以写一个这样的节点去做一些自己的优化工作或者其它的操作。下面我们来看一下一个简单Pass的编写流程：</p>\n<p>1.创建头文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd llvm/include/llvm/Transforms/</div><div class=\"line\">mkdir Obfuscation</div><div class=\"line\">cd Obfuscation</div><div class=\"line\">touch SimplePass.h</div></pre></td></tr></table></figure>\n<p>写入内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;llvm/IR/Function.h&quot;</div><div class=\"line\">#include &quot;llvm/Pass.h&quot;</div><div class=\"line\">#include &quot;llvm/Support/raw_ostream.h&quot;</div><div class=\"line\">#include &quot;llvm/IR/Intrinsics.h&quot;</div><div class=\"line\">#include &quot;llvm/IR/Instructions.h&quot;</div><div class=\"line\">#include &quot;llvm/IR/LegacyPassManager.h&quot;</div><div class=\"line\">#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</div><div class=\"line\"></div><div class=\"line\">// Namespace</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">namespace llvm &#123;</div><div class=\"line\">\tPass *createSimplePass(bool flag);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.创建源文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd llvm/lib/Transforms/</div><div class=\"line\">mkdir Obfuscation</div><div class=\"line\">cd Obfuscation</div><div class=\"line\"></div><div class=\"line\">touch CMakeLists.txt</div><div class=\"line\">touch LLVMBuild.txt</div><div class=\"line\">touch SimplePass.cpp</div></pre></td></tr></table></figure>\n<p>CMakeLists.txt:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_loadable_module(LLVMObfuscation</div><div class=\"line\">  SimplePass.cpp</div><div class=\"line\">  </div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\">  add_dependencies(LLVMObfuscation intrinsics_gen)</div></pre></td></tr></table></figure>\n<p>LLVMBuild.txt:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[component_0]</div><div class=\"line\">type = Library</div><div class=\"line\">name = Obfuscation</div><div class=\"line\">parent = Transforms</div><div class=\"line\">library_name = Obfuscation</div></pre></td></tr></table></figure>\n<p>SimplePass.cpp:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;llvm/Transforms/Obfuscation/SimplePass.h&quot;</div><div class=\"line\"></div><div class=\"line\">using namespace llvm;</div><div class=\"line\"></div><div class=\"line\">namespace &#123;</div><div class=\"line\">    struct SimplePass : public FunctionPass &#123;</div><div class=\"line\">        static char ID; // Pass identification, replacement for typeid</div><div class=\"line\">        bool flag;</div><div class=\"line\">         </div><div class=\"line\">        SimplePass() : FunctionPass(ID) &#123;&#125;</div><div class=\"line\">        SimplePass(bool flag) : FunctionPass(ID) &#123;</div><div class=\"line\">        \tthis-&gt;flag = flag;</div><div class=\"line\">        &#125;</div><div class=\"line\">         </div><div class=\"line\">        bool runOnFunction(Function &amp;F) override &#123;</div><div class=\"line\">        \tif(this-&gt;flag)&#123;</div><div class=\"line\">                Function *tmp = &amp;F;</div><div class=\"line\">                // 遍历函数中的所有基本块</div><div class=\"line\">                for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123;</div><div class=\"line\">                    // 遍历基本块中的每条指令</div><div class=\"line\">                    for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</div><div class=\"line\">                        // 是否是add指令</div><div class=\"line\">                        if (inst-&gt;isBinaryOp()) &#123;</div><div class=\"line\">                            if (inst-&gt;getOpcode() == Instruction::Add) &#123;</div><div class=\"line\">                                ob_add(cast&lt;BinaryOperator&gt;(inst));</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">         </div><div class=\"line\">        // a+b === a-(-b)</div><div class=\"line\">        void ob_add(BinaryOperator *bo) &#123;</div><div class=\"line\">            BinaryOperator *op = NULL;</div><div class=\"line\">             </div><div class=\"line\">            if (bo-&gt;getOpcode() == Instruction::Add) &#123;</div><div class=\"line\">                // 生成 (－b)</div><div class=\"line\">                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);</div><div class=\"line\">                // 生成 a-(-b)</div><div class=\"line\">                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);</div><div class=\"line\">                 </div><div class=\"line\">                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());</div><div class=\"line\">                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());</div><div class=\"line\">            &#125;</div><div class=\"line\">             </div><div class=\"line\">            // 替换所有出现该指令的地方</div><div class=\"line\">            bo-&gt;replaceAllUsesWith(op);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">char SimplePass::ID = 0;</div><div class=\"line\"> </div><div class=\"line\">// 注册pass 命令行选项显示为simplepass</div><div class=\"line\">static RegisterPass&lt;SimplePass&gt; X(&quot;simplepass&quot;, &quot;this is a Simple Pass&quot;);</div><div class=\"line\">Pass *llvm::createSimplePass() &#123; return new SimplePass(); &#125;</div></pre></td></tr></table></figure>\n<p>修改<code>.../Transforms/LLVMBuild.txt</code>, 加上刚刚写的模块<code>Obfuscation</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">subdirectories = Coroutines IPO InstCombine Instrumentation Scalar Utils Vectorize ObjCARC Obfuscation</div></pre></td></tr></table></figure>\n<p>修改<code>.../Transforms/CMakeLists.txt</code>,  加上刚刚写的模块<code>Obfuscation</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_subdirectory(Obfuscation)</div></pre></td></tr></table></figure>\n<p>编译生成：<code>LLVMSimplePass.dylib</code></p>\n<p>因为Pass是作用于中间代码，所以我们首先要生成一份中间代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -emit-llvm -c test.c -o test.bc</div></pre></td></tr></table></figure>\n<p>然后加载Pass优化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">../build/bin/opt -load ../build/lib/LLVMSimplePass.dylib -test &lt; test.bc &gt; after_test.bc</div></pre></td></tr></table></figure>\n<p>对比中间代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">llvm-dis test.bc -o test.ll</div><div class=\"line\">llvm-dis after_test.bc -o after_test.ll</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.ll</div><div class=\"line\">......</div><div class=\"line\">entry:</div><div class=\"line\">  %retval = alloca i32, align 4</div><div class=\"line\">  %a = alloca i32, align 4</div><div class=\"line\">  %b = alloca i32, align 4</div><div class=\"line\">  %c = alloca i32, align 4</div><div class=\"line\">  store i32 0, i32* %retval, align 4</div><div class=\"line\">  store i32 3, i32* %a, align 4</div><div class=\"line\">  store i32 4, i32* %b, align 4</div><div class=\"line\">  %0 = load i32, i32* %a, align 4</div><div class=\"line\">  %1 = load i32, i32* %b, align 4</div><div class=\"line\">  %add = add nsw i32 %0, %1</div><div class=\"line\">  store i32 %add, i32* %c, align 4</div><div class=\"line\">  %2 = load i32, i32* %c, align 4</div><div class=\"line\">  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %2)</div><div class=\"line\">  ret i32 0</div><div class=\"line\">&#125;</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">after_test.ll</div><div class=\"line\">......</div><div class=\"line\">entry:</div><div class=\"line\">  %retval = alloca i32, align 4</div><div class=\"line\">  %a = alloca i32, align 4</div><div class=\"line\">  %b = alloca i32, align 4</div><div class=\"line\">  %c = alloca i32, align 4</div><div class=\"line\">  store i32 0, i32* %retval, align 4</div><div class=\"line\">  store i32 3, i32* %a, align 4</div><div class=\"line\">  store i32 4, i32* %b, align 4</div><div class=\"line\">  %0 = load i32, i32* %a, align 4</div><div class=\"line\">  %1 = load i32, i32* %b, align 4</div><div class=\"line\">  %2 = sub i32 0, %1</div><div class=\"line\">  %3 = sub nsw i32 %0, %2</div><div class=\"line\">  %add = add nsw i32 %0, %1</div><div class=\"line\">  store i32 %3, i32* %c, align 4</div><div class=\"line\">  %4 = load i32, i32* %c, align 4</div><div class=\"line\">  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %4)</div><div class=\"line\">  ret i32 0</div><div class=\"line\">&#125;</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n<p>这里写的Pass只是把a+b简单的替换成了a-(-b),只是一个演示，怎么去写自己的Pass，并且作用于代码。</p>\n<h3 id=\"5-2-将Pass加入PassManager管理\"><a href=\"#5-2-将Pass加入PassManager管理\" class=\"headerlink\" title=\"5.2 将Pass加入PassManager管理\"></a>5.2 将Pass加入PassManager管理</h3><p>上面我们是单独去加载Pass动态库，这里我们将Pass加入PassManager，这样我们就可以直接通过clang的参数去加载我们的Pass了。</p>\n<p>首先在<code>llvm/lib/Transforms/IPO/PassManagerBuilder.cpp</code>添加头文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;llvm/Transforms/Obfuscation/SimplePass.h&quot;</div></pre></td></tr></table></figure>\n<p>然后添加如下语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">static cl::opt&lt;bool&gt; SimplePass(&quot;simplepass&quot;, cl::init(false),</div><div class=\"line\">                           cl::desc(&quot;Enable simple pass&quot;));</div></pre></td></tr></table></figure>\n<p>然后在<code>populateModulePassManager</code>这个函数中添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MPM.add(createSimplePass(SimplePass));</div></pre></td></tr></table></figure>\n<p>最后在IPO这个目录的<code>LLVMBuild.txt</code>中添加库的支持，否则在编译的时候会提示链接错误。具体内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">required_libraries = Analysis Core InstCombine IRReader Linker Object ProfileData Scalar Support TransformUtils Vectorize Obfuscation</div></pre></td></tr></table></figure>\n<p>修改Pass的CMakeLists.txt为静态库形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_library(LLVMObfuscation</div><div class=\"line\">  SimplePass.cpp</div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\">add_dependencies(LLVMObfuscation intrinsics_gen)</div></pre></td></tr></table></figure>\n<p>最后再编译一次。</p>\n<p>那么我们可以这么去调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">../build/bin/clang -mllvm -simplepass test.c -o after_test</div></pre></td></tr></table></figure>\n<p>基于Pass，我们可以做什么？ 我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320959711.png\"></center>\n\n<p>我们可以把代码左上角的样子，变成右下角的样子，甚至更加复杂~ </p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>上面说了那么说，来总结一下：</p>\n<p>1.LLVM编译一个源文件的过程：</p>\n<p>预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</p>\n<p>2.基于LLVM，我们可以做什么？</p>\n<ol>\n<li>做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。</li>\n<li>编写ClangPlugin，命名规范，代码规范，扩展功能。</li>\n<li>编写Pass，代码混淆优化。</li>\n</ol>\n<p>这篇只是一个简单的入门介绍，个人还需要深入去学习LLVM，再给大家分享，如有问题，欢迎拍砖~  </p>\n","excerpt":"<p>只要你和代码打交道，了解编译器的工作流程和原理定会让你受益无穷，无论是分析程序，还是基于它写自己的插件，甚至学习一门全新的语音。通过本文，将带你了解LLVM，并使用LLVM来完成一些有意思的事情。","more":"</p>\n<h2 id=\"1-什么是LLVM？\"><a href=\"#1-什么是LLVM？\" class=\"headerlink\" title=\"1. 什么是LLVM？\"></a>1. 什么是LLVM？</h2><blockquote>\n<p>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.</p>\n</blockquote>\n<p>简单来说，LLVM项目是一系列分模块、可重用的编译工具链。它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。</p>\n<p>先来看下LLVM架构的主要组成部分：</p>\n<ul>\n<li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li>\n<li>Pass(通常翻译为“流程”)：Pass用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。</li>\n<li>后端：后端用来生成实际的机器码。</li>\n</ul>\n<p>虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。传统的编译器的架构如下:</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136450962.png\"/></center>\n\n<p>LLVM的架构如下：</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482136601642.png\"/></center>\n\n<p>当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端就行了。其它部分完成可以复用，就不用再重新设计一次了。</p>\n<h2 id=\"2-安装编译LLVM\"><a href=\"#2-安装编译LLVM\" class=\"headerlink\" title=\"2. 安装编译LLVM\"></a>2. 安装编译LLVM</h2><p>这里使用clang作为前端:</p>\n<ol>\n<li><p>直接从官网下载:<a href=\"http://releases.llvm.org/download.html\">http://releases.llvm.org/download.html\n</a></p>\n</li>\n<li><p>svn获取</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div><div class=\"line\">cd llvm/tools</div><div class=\"line\">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div><div class=\"line\">cd ../projects</div><div class=\"line\">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div><div class=\"line\">cd ../tools/clang/tools</div><div class=\"line\">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</div></pre></td></tr></table></figure>\n<ol>\n<li>git获取</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone http://llvm.org/git/llvm.git</div><div class=\"line\">cd llvm/tools</div><div class=\"line\">git clone http://llvm.org/git/clang.git</div><div class=\"line\">cd ../projects</div><div class=\"line\">git clone http://llvm.org/git/compiler-rt.git</div><div class=\"line\">cd ../tools/clang/tools</div><div class=\"line\">git clone http://llvm.org/git/clang-tools-extra.git</div></pre></td></tr></table></figure>\n<p>最新的LLVM只支持cmake来编译了，首先安装cmake。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install cmake</div></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir build</div><div class=\"line\">cmake /path/to/llvm/source</div><div class=\"line\">cmake --build .</div></pre></td></tr></table></figure>\n<p>编译时间比较长，而且编译结果会生成20G左右的文件。</p>\n<p>编译完成后，就能在<code>build/bin/</code>目录下面找到生成的工具了。</p>\n<h2 id=\"3-从源码到可执行文件\"><a href=\"#3-从源码到可执行文件\" class=\"headerlink\" title=\"3. 从源码到可执行文件\"></a>3. 从源码到可执行文件</h2><p>我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？</p>\n<p>我们先来一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define TEN 10</div><div class=\"line\"></div><div class=\"line\">int main()&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        int numberOne = TEN;</div><div class=\"line\">        int numberTwo = 8;</div><div class=\"line\">        NSString* name = [[NSString alloc] initWithUTF8String:&quot;AloneMonkey&quot;];</div><div class=\"line\">        int age = numberOne + numberTwo;</div><div class=\"line\">        NSLog(@&quot;Hello, %@, Age: %d&quot;, name, age);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这个文件，我们可以通过命令行直接编译，然后链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o</div><div class=\"line\">xcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main</div></pre></td></tr></table></figure>\n<p>拷贝到手机运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">monkeyde-iPhone:/tmp root# ./main</div><div class=\"line\">2016-12-19 17:16:34.654 main[2164:213100] Hello, AloneMonkey, Age: 18</div></pre></td></tr></table></figure>\n<p>大家不会以为就这样就完了吧，当然不是，我们要继续深入剖析。</p>\n<h3 id=\"3-1-预处理（Preprocess）\"><a href=\"#3-1-预处理（Preprocess）\" class=\"headerlink\" title=\"3.1 预处理（Preprocess）\"></a>3.1 预处理（Preprocess）</h3><p>这部分包括macro宏的展开，import/include头文件的导入，以及#if等处理。</p>\n<p>可以通过执行以下命令，来告诉clang只执行到预处理这一步：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -E main.m</div></pre></td></tr></table></figure>\n<p>执行完这个命令之后，我们会发现导入了很多的头文件内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">......</div><div class=\"line\"># 1 &quot;/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot; 1 3</div><div class=\"line\"># 185 &quot;/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot; 2 3</div><div class=\"line\"># 2 &quot;main.m&quot; 2</div><div class=\"line\"></div><div class=\"line\">int main()&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        int numberOne = 10;</div><div class=\"line\">        int numberTwo = 8;</div><div class=\"line\">        NSString* name = [[NSString alloc] initWithUTF8String:&quot;AloneMonkey&quot;];</div><div class=\"line\">        int age = numberOne + numberTwo;</div><div class=\"line\">        NSLog(@&quot;Hello, %@, Age: %d&quot;, name, age);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到上面的预处理已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation，所以有了pch预处理文件，可以在这里去引入一些通用的头文件。</p>\n<p>后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入，默认会加上-fmodules参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -E -fmodules main.m</div></pre></td></tr></table></figure>\n<p>这样的话，只需要@import一下就能导入对应库的modules模块了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@import Foundation; </div><div class=\"line\">int main()&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        int numberOne = 10;</div><div class=\"line\">        int numberTwo = 8;</div><div class=\"line\">        NSString* name = [[NSString alloc] initWithUTF8String:&quot;AloneMonkey&quot;];</div><div class=\"line\">        int age = numberOne + numberTwo;</div><div class=\"line\">        NSLog(@&quot;Hello, %@, Age: %d&quot;, name, age);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-2-词法分析-Lexical-Analysis\"><a href=\"#3-2-词法分析-Lexical-Analysis\" class=\"headerlink\" title=\"3.2 词法分析 (Lexical Analysis)\"></a>3.2 词法分析 (Lexical Analysis)</h3><p>在预处理之后，就要进行词法分析了，将预处理过的代码转化成一个个Token，比如左括号、右括号、等于、字符串等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994028068.png\" alt=\"image\"></p>\n<h3 id=\"3-3-语法分析-Semantic-Analysis\"><a href=\"#3-3-语法分析-Semantic-Analysis\" class=\"headerlink\" title=\"3.3 语法分析 (Semantic Analysis)\"></a>3.3 语法分析 (Semantic Analysis)</h3><p>根据当前语言的语法，验证语法是否正确，并将所有节点组合成抽象语法树(AST)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994071651.png\" alt=\"image\"></p>\n<p>语法树直观图:</p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482150626825.png\" alt=\"image\"></p>\n<h3 id=\"3-4-IR代码生成-CodeGen\"><a href=\"#3-4-IR代码生成-CodeGen\" class=\"headerlink\" title=\"3.4 IR代码生成 (CodeGen)\"></a>3.4 IR代码生成 (CodeGen)</h3><p>CodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。</p>\n<p>可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别<code>-O1</code>,<code>-O3</code>,<code>-Os</code>。 还可以去写一些自己的Pass，这里需要解释一下什么是Pass。</p>\n<p>Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994093995.png\" alt=\"image\"></p>\n<h3 id=\"3-5-生成字节码-LLVM-Bitcode\"><a href=\"#3-5-生成字节码-LLVM-Bitcode\" class=\"headerlink\" title=\"3.5 生成字节码 (LLVM Bitcode)\"></a>3.5 生成字节码 (LLVM Bitcode)</h3><p>我们在Xcode7中默认生成bitcode就是这种的中间形式存在， 开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218230417.png\" alt=\"image\"></p>\n<h3 id=\"3-6-生成相关汇编\"><a href=\"#3-6-生成相关汇编\" class=\"headerlink\" title=\"3.6 生成相关汇编\"></a>3.6 生成相关汇编</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994171109.png\" alt=\"image\"></p>\n<h3 id=\"3-7-生成目标文件\"><a href=\"#3-7-生成目标文件\" class=\"headerlink\" title=\"3.7 生成目标文件\"></a>3.7 生成目标文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482218636504.png\" alt=\"image\"></p>\n<h3 id=\"3-8-生成可执行文件\"><a href=\"#3-8-生成可执行文件\" class=\"headerlink\" title=\"3.8 生成可执行文件\"></a>3.8 生成可执行文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang main.o -o main</div><div class=\"line\">./main</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-12-20 15:25:42.299 main[8941:327306] Hello, AloneMonkey, Age: 18</div></pre></td></tr></table></figure>\n<h3 id=\"3-9-整体流程\"><a href=\"#3-9-整体流程\" class=\"headerlink\" title=\"3.9 整体流程\"></a>3.9 整体流程</h3><p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482219005958.png\" alt=\"image\"></p>\n<h2 id=\"4-可以用Clang做什么？\"><a href=\"#4-可以用Clang做什么？\" class=\"headerlink\" title=\"4. 可以用Clang做什么？\"></a>4. 可以用Clang做什么？</h2><h3 id=\"4-1-libclang进行语法分析\"><a href=\"#4-1-libclang进行语法分析\" class=\"headerlink\" title=\"4.1 libclang进行语法分析\"></a>4.1 libclang进行语法分析</h3><p>可以使用libclang里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。</p>\n<p>来看一段代码的使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">void *hand = dlopen(&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib&quot;,RTLD_LAZY);</div><div class=\"line\">        </div><div class=\"line\">//初始化函数指针</div><div class=\"line\">initlibfunclist(hand);</div><div class=\"line\"></div><div class=\"line\">CXIndex cxindex = myclang_createIndex(1, 1);</div><div class=\"line\"></div><div class=\"line\">const char *filename = &quot;/path/to/filename&quot;;</div><div class=\"line\"></div><div class=\"line\">int index = 0;</div><div class=\"line\"></div><div class=\"line\">const char ** new_command = malloc(10240);</div><div class=\"line\"></div><div class=\"line\">NSMutableString *mus = [NSMutableString stringWithString:@&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch armv7 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk&quot;]; </div><div class=\"line\"></div><div class=\"line\">NSArray *arr = [mus componentsSeparatedByString:@&quot; &quot;];</div><div class=\"line\"></div><div class=\"line\">for (NSString *tmp in arr) &#123;</div><div class=\"line\">    new_command[index++] = [tmp UTF8String];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">nameArr = [[NSMutableArray alloc] initWithCapacity:10];</div><div class=\"line\"></div><div class=\"line\">TU = myclang_parseTranslationUnit(cxindex, filename, new_command, index, NULL, 0, myclang_defaultEditingTranslationUnitOptions());</div><div class=\"line\"></div><div class=\"line\">CXCursor rootCursor = myclang_getTranslationUnitCursor(TU);</div><div class=\"line\"></div><div class=\"line\">myclang_visitChildren(rootCursor, printVisitor, NULL);</div><div class=\"line\"></div><div class=\"line\">myclang_disposeTranslationUnit(TU);</div><div class=\"line\">myclang_disposeIndex(cxindex);</div><div class=\"line\">free(new_command);</div><div class=\"line\"></div><div class=\"line\">dlclose(hand);</div></pre></td></tr></table></figure>\n<p>然后我们就可以在<code>printVisitor</code>这个函数里面去遍历输入文件的语法树了。</p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994195691.png\" alt=\"image\"></p>\n<p>我们也通过通过python去调用用clang：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install clang</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994863704.png\" alt=\"image\"></p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994879267.png\" alt=\"image\"></p>\n<p>那么基于语法树的分析，我们可以针对字符串做加密：</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320827975.png\"/></center>\n\n<p>从左上角的明文字符串，处理成右下角的介个样子~</p>\n<h3 id=\"4-2-LibTooling\"><a href=\"#4-2-LibTooling\" class=\"headerlink\" title=\"4.2 LibTooling\"></a>4.2 LibTooling</h3><p>对语法树有完全的控制权，可以作为一个单独的命令使用，如：<code>clang-format</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang-format main.m</div></pre></td></tr></table></figure>\n<p>我们也可以自己写一个这样的工具去遍历、访问、甚至修改语法树。 目录:<code>llvm/tools/clang/tools</code></p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482994222169.png\" alt=\"image\"></p>\n<p>上面的代码通过遍历语法树，去修改里面的方法名和返回变量名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">before:</div><div class=\"line\">void do_math(int *x) &#123;</div><div class=\"line\">    *x += 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(void) &#123;</div><div class=\"line\">    int result = -1, val = 4;</div><div class=\"line\">    do_math(&amp;val);</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">after:</div><div class=\"line\">** Rewrote function def: do_math</div><div class=\"line\">** Rewrote function call</div><div class=\"line\">** Rewrote ReturnStmt</div><div class=\"line\"></div><div class=\"line\">Found 2 functions.</div><div class=\"line\"></div><div class=\"line\">void add5(int *x) &#123;</div><div class=\"line\">    *x += 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(void) &#123;</div><div class=\"line\">    int result = -1, val = 4;</div><div class=\"line\">    add5(&amp;val);</div><div class=\"line\">    return val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们看到<code>LibTooling</code>对代码的语法树有完全的控制，那么我们可以基于它去检查命名的规范，甚至做一个代码的转换，比如实现OC转Swift。</p>\n<h3 id=\"4-3-ClangPlugin\"><a href=\"#4-3-ClangPlugin\" class=\"headerlink\" title=\"4.3 ClangPlugin\"></a>4.3 ClangPlugin</h3><p>对语法树有完全的控制权，作为插件注入到编译流程中，可以影响build和决定编译过程。目录:<code>llvm/tools/clang/examples</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;clang/Driver/Options.h&quot;</div><div class=\"line\">#include &quot;clang/AST/AST.h&quot;</div><div class=\"line\">#include &quot;clang/AST/ASTContext.h&quot;</div><div class=\"line\">#include &quot;clang/AST/ASTConsumer.h&quot;</div><div class=\"line\">#include &quot;clang/AST/RecursiveASTVisitor.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/ASTConsumers.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/FrontendActions.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/CompilerInstance.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;</div><div class=\"line\">#include &quot;clang/Rewrite/Core/Rewriter.h&quot;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\">using namespace clang;</div><div class=\"line\">using namespace llvm;</div><div class=\"line\"></div><div class=\"line\">Rewriter rewriter;</div><div class=\"line\">int numFunctions = 0;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class ExampleVisitor : public RecursiveASTVisitor&lt;ExampleVisitor&gt; &#123;</div><div class=\"line\">private:</div><div class=\"line\">    ASTContext *astContext; // used for getting additional AST info</div><div class=\"line\"></div><div class=\"line\">public:</div><div class=\"line\">    explicit ExampleVisitor(CompilerInstance *CI) </div><div class=\"line\">      : astContext(&amp;(CI-&gt;getASTContext())) // initialize private members</div><div class=\"line\">    &#123;</div><div class=\"line\">        rewriter.setSourceMgr(astContext-&gt;getSourceManager(), astContext-&gt;getLangOpts());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    virtual bool VisitFunctionDecl(FunctionDecl *func) &#123;</div><div class=\"line\">        numFunctions++;</div><div class=\"line\">        string funcName = func-&gt;getNameInfo().getName().getAsString();</div><div class=\"line\">        if (funcName == &quot;do_math&quot;) &#123;</div><div class=\"line\">            rewriter.ReplaceText(func-&gt;getLocation(), funcName.length(), &quot;add5&quot;);</div><div class=\"line\">            errs() &lt;&lt; &quot;** Rewrote function def: &quot; &lt;&lt; funcName &lt;&lt; &quot;\\n&quot;;</div><div class=\"line\">        &#125;    </div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    virtual bool VisitStmt(Stmt *st) &#123;</div><div class=\"line\">        if (ReturnStmt *ret = dyn_cast&lt;ReturnStmt&gt;(st)) &#123;</div><div class=\"line\">            rewriter.ReplaceText(ret-&gt;getRetValue()-&gt;getLocStart(), 6, &quot;val&quot;);</div><div class=\"line\">            errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;;</div><div class=\"line\">        &#125;        </div><div class=\"line\">        if (CallExpr *call = dyn_cast&lt;CallExpr&gt;(st)) &#123;</div><div class=\"line\">            rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;);</div><div class=\"line\">            errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class ExampleASTConsumer : public ASTConsumer &#123;</div><div class=\"line\">private:</div><div class=\"line\">    ExampleVisitor *visitor; // doesn&apos;t have to be private</div><div class=\"line\"></div><div class=\"line\">public:</div><div class=\"line\">    // override the constructor in order to pass CI</div><div class=\"line\">    explicit ExampleASTConsumer(CompilerInstance *CI):</div><div class=\"line\">        visitor(new ExampleVisitor(CI)) &#123; &#125; // initialize the visitor</div><div class=\"line\"></div><div class=\"line\">    // override this to call our ExampleVisitor on the entire source file</div><div class=\"line\">    virtual void HandleTranslationUnit(ASTContext &amp;Context) &#123;</div><div class=\"line\">        /* we can use ASTContext to get the TranslationUnitDecl, which is</div><div class=\"line\">             a single Decl that collectively represents the entire source file */</div><div class=\"line\">        visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class PluginExampleAction : public PluginASTAction &#123;</div><div class=\"line\">protected:</div><div class=\"line\">    // this gets called by Clang when it invokes our Plugin</div><div class=\"line\">    // Note that unique pointer is used here.</div><div class=\"line\">    std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef file) &#123;</div><div class=\"line\">        return llvm::make_unique&lt;ExampleASTConsumer&gt;(&amp;CI);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // implement this function if you want to parse custom cmd-line args</div><div class=\"line\">    bool ParseArgs(const CompilerInstance &amp;CI, const vector&lt;string&gt; &amp;args) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">static FrontendPluginRegistry::Add&lt;PluginExampleAction&gt; X(&quot;-example-plugin&quot;, &quot;simple Plugin example&quot;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -Xclang -load -Xclang ../build/lib/PluginExample.dylib -Xclang -plugin -Xclang -example-plugin -c testPlugin.c</div><div class=\"line\"></div><div class=\"line\">** Rewrote function def: do_math</div><div class=\"line\">** Rewrote function call</div><div class=\"line\">** Rewrote ReturnStmt</div></pre></td></tr></table></figure>\n<p>我们可以基于ClangPlugin做些什么事情呢？我们可以用来定义一些编码规范，比如代码风格检查，命名检查等等。下面是我写的判断类名前两个字母是不是大写的例子，如果不是报错。(当然这只是一个例子而已。。。)</p>\n<p><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482318703701.png\" alt=\"image\"></p>\n<h2 id=\"5-动手写Pass\"><a href=\"#5-动手写Pass\" class=\"headerlink\" title=\"5. 动手写Pass\"></a>5. 动手写Pass</h2><h3 id=\"5-1-一个简单的Pass\"><a href=\"#5-1-一个简单的Pass\" class=\"headerlink\" title=\"5.1 一个简单的Pass\"></a>5.1 一个简单的Pass</h3><p>前面我们说到，Pass就是LLVM系统转化和优化的工作的一个节点，当然我们也可以写一个这样的节点去做一些自己的优化工作或者其它的操作。下面我们来看一下一个简单Pass的编写流程：</p>\n<p>1.创建头文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd llvm/include/llvm/Transforms/</div><div class=\"line\">mkdir Obfuscation</div><div class=\"line\">cd Obfuscation</div><div class=\"line\">touch SimplePass.h</div></pre></td></tr></table></figure>\n<p>写入内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;llvm/IR/Function.h&quot;</div><div class=\"line\">#include &quot;llvm/Pass.h&quot;</div><div class=\"line\">#include &quot;llvm/Support/raw_ostream.h&quot;</div><div class=\"line\">#include &quot;llvm/IR/Intrinsics.h&quot;</div><div class=\"line\">#include &quot;llvm/IR/Instructions.h&quot;</div><div class=\"line\">#include &quot;llvm/IR/LegacyPassManager.h&quot;</div><div class=\"line\">#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</div><div class=\"line\"></div><div class=\"line\">// Namespace</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">namespace llvm &#123;</div><div class=\"line\">\tPass *createSimplePass(bool flag);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.创建源文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd llvm/lib/Transforms/</div><div class=\"line\">mkdir Obfuscation</div><div class=\"line\">cd Obfuscation</div><div class=\"line\"></div><div class=\"line\">touch CMakeLists.txt</div><div class=\"line\">touch LLVMBuild.txt</div><div class=\"line\">touch SimplePass.cpp</div></pre></td></tr></table></figure>\n<p>CMakeLists.txt:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_loadable_module(LLVMObfuscation</div><div class=\"line\">  SimplePass.cpp</div><div class=\"line\">  </div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\">  add_dependencies(LLVMObfuscation intrinsics_gen)</div></pre></td></tr></table></figure>\n<p>LLVMBuild.txt:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[component_0]</div><div class=\"line\">type = Library</div><div class=\"line\">name = Obfuscation</div><div class=\"line\">parent = Transforms</div><div class=\"line\">library_name = Obfuscation</div></pre></td></tr></table></figure>\n<p>SimplePass.cpp:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;llvm/Transforms/Obfuscation/SimplePass.h&quot;</div><div class=\"line\"></div><div class=\"line\">using namespace llvm;</div><div class=\"line\"></div><div class=\"line\">namespace &#123;</div><div class=\"line\">    struct SimplePass : public FunctionPass &#123;</div><div class=\"line\">        static char ID; // Pass identification, replacement for typeid</div><div class=\"line\">        bool flag;</div><div class=\"line\">         </div><div class=\"line\">        SimplePass() : FunctionPass(ID) &#123;&#125;</div><div class=\"line\">        SimplePass(bool flag) : FunctionPass(ID) &#123;</div><div class=\"line\">        \tthis-&gt;flag = flag;</div><div class=\"line\">        &#125;</div><div class=\"line\">         </div><div class=\"line\">        bool runOnFunction(Function &amp;F) override &#123;</div><div class=\"line\">        \tif(this-&gt;flag)&#123;</div><div class=\"line\">                Function *tmp = &amp;F;</div><div class=\"line\">                // 遍历函数中的所有基本块</div><div class=\"line\">                for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123;</div><div class=\"line\">                    // 遍历基本块中的每条指令</div><div class=\"line\">                    for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</div><div class=\"line\">                        // 是否是add指令</div><div class=\"line\">                        if (inst-&gt;isBinaryOp()) &#123;</div><div class=\"line\">                            if (inst-&gt;getOpcode() == Instruction::Add) &#123;</div><div class=\"line\">                                ob_add(cast&lt;BinaryOperator&gt;(inst));</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">         </div><div class=\"line\">        // a+b === a-(-b)</div><div class=\"line\">        void ob_add(BinaryOperator *bo) &#123;</div><div class=\"line\">            BinaryOperator *op = NULL;</div><div class=\"line\">             </div><div class=\"line\">            if (bo-&gt;getOpcode() == Instruction::Add) &#123;</div><div class=\"line\">                // 生成 (－b)</div><div class=\"line\">                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);</div><div class=\"line\">                // 生成 a-(-b)</div><div class=\"line\">                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);</div><div class=\"line\">                 </div><div class=\"line\">                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());</div><div class=\"line\">                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());</div><div class=\"line\">            &#125;</div><div class=\"line\">             </div><div class=\"line\">            // 替换所有出现该指令的地方</div><div class=\"line\">            bo-&gt;replaceAllUsesWith(op);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">char SimplePass::ID = 0;</div><div class=\"line\"> </div><div class=\"line\">// 注册pass 命令行选项显示为simplepass</div><div class=\"line\">static RegisterPass&lt;SimplePass&gt; X(&quot;simplepass&quot;, &quot;this is a Simple Pass&quot;);</div><div class=\"line\">Pass *llvm::createSimplePass() &#123; return new SimplePass(); &#125;</div></pre></td></tr></table></figure>\n<p>修改<code>.../Transforms/LLVMBuild.txt</code>, 加上刚刚写的模块<code>Obfuscation</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">subdirectories = Coroutines IPO InstCombine Instrumentation Scalar Utils Vectorize ObjCARC Obfuscation</div></pre></td></tr></table></figure>\n<p>修改<code>.../Transforms/CMakeLists.txt</code>,  加上刚刚写的模块<code>Obfuscation</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_subdirectory(Obfuscation)</div></pre></td></tr></table></figure>\n<p>编译生成：<code>LLVMSimplePass.dylib</code></p>\n<p>因为Pass是作用于中间代码，所以我们首先要生成一份中间代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -emit-llvm -c test.c -o test.bc</div></pre></td></tr></table></figure>\n<p>然后加载Pass优化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">../build/bin/opt -load ../build/lib/LLVMSimplePass.dylib -test &lt; test.bc &gt; after_test.bc</div></pre></td></tr></table></figure>\n<p>对比中间代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">llvm-dis test.bc -o test.ll</div><div class=\"line\">llvm-dis after_test.bc -o after_test.ll</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">test.ll</div><div class=\"line\">......</div><div class=\"line\">entry:</div><div class=\"line\">  %retval = alloca i32, align 4</div><div class=\"line\">  %a = alloca i32, align 4</div><div class=\"line\">  %b = alloca i32, align 4</div><div class=\"line\">  %c = alloca i32, align 4</div><div class=\"line\">  store i32 0, i32* %retval, align 4</div><div class=\"line\">  store i32 3, i32* %a, align 4</div><div class=\"line\">  store i32 4, i32* %b, align 4</div><div class=\"line\">  %0 = load i32, i32* %a, align 4</div><div class=\"line\">  %1 = load i32, i32* %b, align 4</div><div class=\"line\">  %add = add nsw i32 %0, %1</div><div class=\"line\">  store i32 %add, i32* %c, align 4</div><div class=\"line\">  %2 = load i32, i32* %c, align 4</div><div class=\"line\">  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %2)</div><div class=\"line\">  ret i32 0</div><div class=\"line\">&#125;</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">after_test.ll</div><div class=\"line\">......</div><div class=\"line\">entry:</div><div class=\"line\">  %retval = alloca i32, align 4</div><div class=\"line\">  %a = alloca i32, align 4</div><div class=\"line\">  %b = alloca i32, align 4</div><div class=\"line\">  %c = alloca i32, align 4</div><div class=\"line\">  store i32 0, i32* %retval, align 4</div><div class=\"line\">  store i32 3, i32* %a, align 4</div><div class=\"line\">  store i32 4, i32* %b, align 4</div><div class=\"line\">  %0 = load i32, i32* %a, align 4</div><div class=\"line\">  %1 = load i32, i32* %b, align 4</div><div class=\"line\">  %2 = sub i32 0, %1</div><div class=\"line\">  %3 = sub nsw i32 %0, %2</div><div class=\"line\">  %add = add nsw i32 %0, %1</div><div class=\"line\">  store i32 %3, i32* %c, align 4</div><div class=\"line\">  %4 = load i32, i32* %c, align 4</div><div class=\"line\">  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %4)</div><div class=\"line\">  ret i32 0</div><div class=\"line\">&#125;</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n<p>这里写的Pass只是把a+b简单的替换成了a-(-b),只是一个演示，怎么去写自己的Pass，并且作用于代码。</p>\n<h3 id=\"5-2-将Pass加入PassManager管理\"><a href=\"#5-2-将Pass加入PassManager管理\" class=\"headerlink\" title=\"5.2 将Pass加入PassManager管理\"></a>5.2 将Pass加入PassManager管理</h3><p>上面我们是单独去加载Pass动态库，这里我们将Pass加入PassManager，这样我们就可以直接通过clang的参数去加载我们的Pass了。</p>\n<p>首先在<code>llvm/lib/Transforms/IPO/PassManagerBuilder.cpp</code>添加头文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;llvm/Transforms/Obfuscation/SimplePass.h&quot;</div></pre></td></tr></table></figure>\n<p>然后添加如下语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">static cl::opt&lt;bool&gt; SimplePass(&quot;simplepass&quot;, cl::init(false),</div><div class=\"line\">                           cl::desc(&quot;Enable simple pass&quot;));</div></pre></td></tr></table></figure>\n<p>然后在<code>populateModulePassManager</code>这个函数中添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MPM.add(createSimplePass(SimplePass));</div></pre></td></tr></table></figure>\n<p>最后在IPO这个目录的<code>LLVMBuild.txt</code>中添加库的支持，否则在编译的时候会提示链接错误。具体内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">required_libraries = Analysis Core InstCombine IRReader Linker Object ProfileData Scalar Support TransformUtils Vectorize Obfuscation</div></pre></td></tr></table></figure>\n<p>修改Pass的CMakeLists.txt为静态库形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_library(LLVMObfuscation</div><div class=\"line\">  SimplePass.cpp</div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\">add_dependencies(LLVMObfuscation intrinsics_gen)</div></pre></td></tr></table></figure>\n<p>最后再编译一次。</p>\n<p>那么我们可以这么去调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">../build/bin/clang -mllvm -simplepass test.c -o after_test</div></pre></td></tr></table></figure>\n<p>基于Pass，我们可以做什么？ 我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。</p>\n<center><img src=\"http://7xtdl4.com1.z0.glb.clouddn.com/script_1482320959711.png\"/></center>\n\n<p>我们可以把代码左上角的样子，变成右下角的样子，甚至更加复杂~ </p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>上面说了那么说，来总结一下：</p>\n<p>1.LLVM编译一个源文件的过程：</p>\n<p>预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</p>\n<p>2.基于LLVM，我们可以做什么？</p>\n<ol>\n<li>做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。</li>\n<li>编写ClangPlugin，命名规范，代码规范，扩展功能。</li>\n<li>编写Pass，代码混淆优化。</li>\n</ol>\n<p>这篇只是一个简单的入门介绍，个人还需要深入去学习LLVM，再给大家分享，如有问题，欢迎拍砖~  </p>"},{"title":"Android平台上的JavaScript引擎","date":"2016-12-22T16:00:00.000Z","author":"刘宏涛","_content":"JavaScript引擎能够解析和执行JS脚本，帮助移动端进行跨平台开发。本文主要介绍和讨论JS引擎在Android系统上的使用和性能比较，并针对JS绘制本地化问题给出了基于V8的开发实例。<!-- more -->\n\n### 1. 前言\n\n近期在产品中遇到了这样的一个问题：Web端已经存在一个功能完善的JavaScript库，如果将相关Web嵌入到App中，则WebView将带来一定的性能影响；如果Android端本地开发一个相同的库，则需要消耗大量的资源。考虑到代码复用和跨平台开发，团队调研了JS引擎在Android上的使用，希望解决”不经过WebView，而将JS库拿到Android端运行，并将运行结果交给本地输出”这一需求。\n\nJS引擎能够解析JS脚本，通常被依附于浏览器中，例如Safari所使用的**JavaScriptCore**、Google Chrome所使用的**V8**和FireFox所使用的**SpiderMonkey**等等。也被用作移动端的跨平台开发，例如[NativeScript](http://developer.telerik.com/featured/nativescript-works/)在iOS端和Android分别使用了JavaScriptCore和V8，[ReactNative](https://facebook.github.io/react-native/docs/javascript-environment.html)则都使用了JavaScriptCore。\n\n### 2. JS引擎介绍\n\n在Android系统中能运行的JS引擎有如下5种：\n\n#### 1. [JavaScriptCore](https://trac.webkit.org/wiki/JavaScriptCore)\n\nJavaScriptCore是一个在WebKit中提供JS引擎的开源框架，最近更新日期是2016年9月26日。目前该引擎由Apple维护，使用于Safari浏览器，iOS7后也集成到了iPhone平台。\n\n由于其使用C语言编写，因此在Android开发中并不能直接使用。Github上的开源项目[AndroidJSCore](https://github.com/ericwlange/AndroidJSCore)能够帮助开发者经过调用Java接口而使用JavaScriptCore。该项目由**ericwlange**维护，最新版本3.0.1发布于2016年7月31日，有API文档和示例代码，但缺少相关技术文章，并仍存在一些性能问题。\n\n#### 2. [V8](https://developers.google.com/v8/)\n\nV8是由Google开发并维护的高性能开源JS引擎，采用C++编写，使用于Google Chrome浏览器。最新版本为V8 5.5 beta，更新于2016年10月24日。\n\n同JavaScriptCore一样，在Android开发中，相关接口需要通过一层包装进行调用。Github上的开源项目[J2V8](https://github.com/eclipsesource/J2V8)，相关文章可在此处<http://eclipsesource.com/blogs/tag/j2v8/>查阅，最新版本4.6.0发布于2016年9月22日。\n\nJ2V8是一套针对V8的Java绑定。J2V8的开发为Android平台带来了高效的Javascript的执行环境，其以性能与内存消耗为设计目标。它采用了“基本类型优先”原则，意味着一个执行结果是基本类型，那么所返回的值也就是该基本类型。它还采用了“懒加载”技术，只有当JS执行结果被访问时，才会通过JNI复制到Java中。\n\n此外J2V8提供了`release()`方法，开发者在某一对象不再需要时主动调用该方法去释放本地对象句柄，释放规则如下：\n\n* 如果是由代码创建的对象，那么必须释放它；如果一个对象是通过返回语句传回来的话，系统会替你释放它；\n* 如果是由系统创建的对象，则无需担心释放，而如果对象是JS方法的返回值，就必须手动的释放它。\n\n#### 3. [SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey)\n\n开源JS引擎SpiderMonkey最初由Netscape开发，如今由Mozilla开发并维护，且被广泛用于Mozilla产品（如FireFox）。最新版本为SpiderMonkey 45，更新于2016年4月14日。\n\nSpiderMonkey提供了一些核心的JavaScript数据类型，如数字，字符串，数组，对象等等，以及一些方法如Array.push。它还使得每个应用程序都容易将其自己的对象和方法暴露给JavaScript代码。应用开发者可以决定应用如何将与所写脚本相关的对象暴露出来。\n\n#### 4. [Rhino](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino)\n\nRhino是由Mozilla开发的开源JS引擎。采用Java编写，因此可以直接调用，在JDK 6、JDK 7中更是捆绑了该引擎。最新版本为Rhino 1.7.7.1，更新于2016年2月1日。\n\n其提供的特性包括：\n\n* JavaScript 1.7的全部特性\n* 可以用脚本方式调用Java\n* 用一个JavaScript Shell来执行JavaScript脚本\n* 用一个JavaScript编译器来将JavaScript脚本文件转换成Java类文件\n* 用一个JavaScript调试器来调试Rhino执行的脚本\n\n#### 5. [Nashorn](http://openjdk.java.net/projects/nashorn/)\n\nNashorn由Oracle开发并维护，从JDK 8开始，Rhino被Nashorn代替，成为JDK默认JS引擎。Nashorn同JDK 8一同发布和开源，较Rhino而言性能更好，但不支持Android Dalvik虚拟机。\n\n### 3. JS引擎性能比较\n\n从可用性方面考虑，选取了JavaScriptCore+AndroidJSCore（下文由“JSCore”指代）、V8+J2V8（下文由“J2V8”指代）和Rhino三种方案进行实验。\n\n#### 3.1 创建JS环境\n\n部分引擎并不支持直接运行文件，因此将JS代码作为字符串交给JS引擎执行，执行过程中可以调用已注册到JS上下文的Java方法。\n\n##### 3.1.1 JSCore\n\n\t//创建JS上下文\n\tJSContext context = new JSContext();\n\t//创建Java方法\n\tJSFunction func = new JSFunction(context, \"func\") {\n\t\tpublic void func(String msg) {\n\t\t\t//相关处理\n\t\t}\n\t};\n\t//将Java方法注册到JS上下文\n\tcontext.property(\"func\", func);\n\t//执行JS\n\tcontext.evaluateScript(/*JS代码*/);\n\t\n##### 3.1.2 J2V8\n\n\t//创建JS上下文\n\tV8 context = V8.createV8Runtime();\n\t//创建Java方法，并注册到JS上下文\n\tcontext.registerJavaMethod(new JavaVoidCallback() {\n\t    public void invoke(final V8Object receiver, final V8Array parameters) {\n\t        //相关处理\n\t    }\n\t}, \"func\");\n\t//执行JS\n\tcontext.executeScript(js);\n\t//释放资源\n\tcontext.release();\n\t\n##### 3.1.3 Rhino\n\n\tclass Func {\n\t\tvoid func(String msg) {\n\t\t\t//相关处理\n\t\t}\n\t}\n\n\t//创建JS上下文\n\tContext context = Context.enter();\n\tcontext.setOptimizationLevel(-1);\n\tScriptable scope = context.initStandardObjects();\n\ttry {\n\t\t//执行JS\n\t    context.evaluateString(scope, js, \"RhinoUtil\", 1, null);\n\t\n\t    //将Java方法封装到类中，并作为参数传递给JS方法\n\t    Function function = (Function) scope.get(\"rhinofunc\", scope);\n\t    function.call(context, scope, scope, new Object[]{new Func()});\n\t} finally {\n\t    Context.exit();\n\t}\n\t\n#### 3.2 实验〇：包的依赖\n\n比较各方案依赖包引入后，apk的体积增量：\n\n||依赖包占用(MB)|依赖方式|\n|---|---|---|\n|J2V8|8.2|compile 'com.eclipsesource.j2v8:j2v8:4.6.0@aar'|\n|JSCore|44.9😳|compile 'com.github.ericwlange:AndroidJSCore:3.0.1'|\n|Rhino|0.6|将jar包放入libs文件夹下|\n\n* J2V8引入的是全平台包，实际上它有针对Linux、Windows、MacOS、Android各平台进行打包，而Android平台最新版本为3.0.5（约4MB），并不是最新的4.6.0版本\n* 具AndroidJsCore作者回答，由于必须针对各CPU架构进行打包，而有7种CPU架构，每种架构包约6MB，因此整个依赖包体积相比之下显得庞大，但也可以通过ABIs Splits进行拆分。\n* Rhino的jar包仅1.2M，因此apk增量并不显著。\n\n#### 3.3 实验一：空循环\n\nJSCore和J2V8执行JS代码如下：\n\n\tvar i = 0;\n\tfor (;i < /*次数*/; i++) {\n\t}\n\t\nRhino执行JS代码如下：\n\n\tfunction rhinofunc(f) {\n\t    var i = 0;\n\t    for (;i < /*次数*/; i++) {\n\t    }\n\t}\n\t\n循环次数分别设置为100万、1000万、1亿次，在Java代码中执行JS前输出开始时间，在JS执行后输出结束时间，相减得出执行时间记录如下：\n\n|执行时间(ms)|100万次|1000万次|1亿次|\n|---|---|---|---|\n|J2V8|17.6|122.8|1116.6|\n|JSCore|22|173.2|1551|\n|Rhino|2078.4|22358.4|198600😳|\n\n由实验结果可以看到：J2V8和JSCore相比，J2V8执行时间更短，但两者时间都在同一数量级上。而Rhino执行时间远大于前两者，根本原因在于Java程序运行较C/C++慢。\n\n#### 3.4 实验二：JS调用Java方法\n\nJSCore和J2V8执行JS代码如下：\n\n\tvar i = 0;\n\tfor (;i < /*次数*/; i++) {\n\t\tfunc();\n\t}\n\t\nRhino执行JS代码如下：\n\n\tfunction rhinofunc(f) {\n\t    var i = 0;\n\t    for (;i < /*次数*/; i++) {\n\t    \tf.func();\n\t    }\n\t}\n\n调用次数分别设置为1万、10万、100万次，记录执行时间如下：\n\n|执行时间(ms)|1万次|10万次|100万次|\n|---|---|---|---|\n|J2V8|490.2|4855.8|47527|\n|JSCore|1287.6|13448.2|121586.8😳|\n|Rhino|408.2|4007.2|36752.4|\n\n启动App时记录占用内存，JS执行过程中记录最高占用内存，相减得出占用内存。\n\n|占用内存(KB)|1万次|10万次|100万次|\n|---|---|---|---|\n|J2V8|7264|14004|17328|\n|JSCore|15368|15140|16720|\n|Rhino|2776|9084|9116|\n\n同样也是由于开发语言的差异，在JS调用Java上Rhino性能更优。执行时间方面，J2V8接近Rhino，而JSCore则远落后于前两种方案，这可能与其Java绑定层有很大关系。对于J2V8和JSCore则需要先经过JNI包装层才能调用到Java方法，而大量的JNI调用是非常耗时、耗内存的。\n\n#### 3.5 实验三：JS递归计算斐波那契\n\nJS代码斐波那契函数如下：\n\n\tfunction fibo(n) {\n\t    if (n == 1 || n == 2) {\n\t        return 1;\n\t    }\n\t    else {\n\t        return fibo(n - 1) + fibo(n - 2);\n\t    }\n\t}\n\n|执行时间(ms)|fibo(20)|fibo(30)|fibo(40)|\n|---|---|---|---|\n|J2V8|4|67.6|8158.6|\n|JSCore|6.6|76.2|7884.4|\n|Rhino|248.4|26898|???😳|\n\n|占用内存(KB)|fibo(20)|fibo(30)|fibo(40)|\n|---|---|---|---|\n|J2V8|6148|6120|17328|\n|JSCore|6204|6200|16720|\n|Rhino|5284|9052|9116|\n\nRhino运行JS时频繁GC，虽然使其所占内存较少，但执行速度非常缓慢，相比之下J2V8和JSCore方案效率更高。\n\n#### 3.6 实验总结\n\n单从JS引擎来说：Rhino执行不需要通过JNI且占用更少的内存，但执行效率很低；V8和JavaScriptCore等C语言开发的引擎远胜于Rhino等Java开发的引擎，但需要一层Java包装层，并存在JNI调用性能问题。就J2V8和AndroidJSCore两个包装层而言：J2V8的可用性、可靠性、健壮性更优；AndroidJSCore还存在着不少的性能问题，在上述实验中出现较少，但实际开发中还存在很多坑。\n\n以上三种实现方案中更推荐J2V8方案。对于内存问题，J2V8的内存释放机制较为完善，在实际开发中可以通过主动release来释放内存；对于JNI调用性能问题，J2V8团队也在尝试通过批处理回调来进行优化，在将来的版本中会得到改善。\n\n### 4. J2V8的Android开发实例\n\n有以下一段JS代码，其中Canvas绘制了一些简单的图形：\n\n\tvar c=document.getElementById(\"myCanvas\");\n\tvar ctx=c.getContext(\"2d\");\n\t\n\tctx.beginPath();\n\tctx.arc(100, 100, 25, 0, 360, false);\n\tctx.moveTo(20,20);\n\tctx.lineTo(20,100);\n\tctx.lineTo(70,100);\n\tctx.moveTo(100, 100);\n\tctx.setLineWidth(15);\n\tctx.setStrokeColor(\"#188ffc\");\n\tctx.stroke();\n\t\n\tctx.setFillColor(\"#188ffc\");\n\tctx.fillText(\"Hello World!\",150,50);\n\t\n其在Web端绘制效果如下：\n\n![logo](Android平台上的JavaScript引擎/web_shape.png)\n\n实例中，借助J2V8在Android端运行同样一段脚本，使图形绘制到Android Canvas中。下面给出简单实现，主要思路为自定义View，JS中将要绘制的图形先存储到在List中，待整个JS脚本执行完毕，再将所有图形在`View.onDraw(Canvas canvas)`中通过Android Canvas绘制。\n\n1) 将ctx封装为V8Object，并在其中对应实现JS Canvas的方法\n\n\t\tpublic class JustContext {\n\t\t\tprotected V8 mRuntime;\n\t\t\tprotected V8Object mCtx;\n\t\t\tprivate ArrayList<AbstractDraw> mShapeList = new ArrayList<>();\n\t\t\n\t\t\tpublic JustContext(V8 v8Runtime) {\n\t\t\t\tmRuntime = v8Runtime;\n\t\t\t\tinitCtx();\n\t\t\t}\n\t\t\t\n\t\t\tpublic V8Object getCtx() {\n\t\t\t\treturn mCtx;\n\t\t\t}\n\t\t\t\n\t\t\tpublic ArrayList<AbstractDraw> getShapeList() {\n\t\t\t\treturn mShapeList;\n\t\t\t}\n\t\t\t\t    \n\t\t\tprotected void initCtx() {\n\t\t\t\tmCtx = new V8Object(mRuntime);\n\t\t\t\t\n\t\t\t\t//将Java方法注册到该V8Object中\n\t\t\t\tmCtx.registerJavaMethod(this, \"beginPath\", \"beginPath\", null);\n        \t\tmCtx.registerJavaMethod(this, \"closePath\", \"closePath\", null);\n        \t\t\n        \t\t...\n\t\t\t}\n\t\t\t\n\t\t\tpublic void clean() {\n\t\t\t\tmCtx.release();\n\t\t\t}\n\t\t\t\n\t\t\tpublic void beginPath() {...}\n\t\t\t\n\t\t\tpublic void closePath() {...}\n\t\t\t\n\t\t\t...\n\t\t}\n\n\n2) 自定义View，在View的`onDraw(Canvas canvas)`方法中将传入的图形List绘制出来\n\n\t\tpublic class JustView extends View implements Serializable {\n\t\t\t...\n\t\t\t\n\t\t\tprivate ArrayList<AbstractDraw> mShapeList = new ArrayList<>();\n\t\t\n\t\t\tpublic void setShapeList(ArrayList<AbstractDraw> shapeList) {\n\t\t\t\tthis.mShapeList = shapeList;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t    protected void onDraw(Canvas canvas) {\n\t\t        super.onDraw(canvas);\n\t\t\n\t\t        for (AbstractDraw abstractDraw : mShapeList) {\n\t\t            abstractDraw.draw(canvas);\n\t\t        }\n\t\t    }\n\t\t\t\n\t\t\t...\n\t\t}\n\n3) 将ctx注册到JS上下文，并执行JS代码，执行完毕后将绘制图形List传递给View\n\t\n\t\tJustView mJustView;\n\t\t...\n\t\t\n\t\tpublic void runJs(String js) {\n\t\t\tV8 context = V8.createV8Runtime();\n\t\t\tJustContext ctx = new JustContext(context);\n\t\t\tcontext.add(\"ctx\", ctx.getCtx());\n\t\t\tcontext.executeScript(js);\n\t\t\t\n\t\t\t//释放内存\n\t\t\tctx.clean();\n\t\t\tcontext.release();\n\t\t\t\n\t\t\tmJustView.setShapeList(ctx.getShapeList());\n\t\t}\n\t\t\n\t\t...\n\t\t\n\t\n4) 因为已将ctx注册到JS上下文，因此可以直接使用`ctx`变量，并运行如下JS代码\n\n\t\tctx.beginPath();\n\t\tctx.arc(100, 100, 25, 0, 360, false);\n\t\tctx.moveTo(20,20);\n\t\tctx.lineTo(20,100);\n\t\tctx.lineTo(70,100);\n\t\tctx.moveTo(100, 100);\n\t\tctx.setLineWidth(15);\n\t\tctx.setStrokeColor(\"#188ffc\");\n\t\tctx.stroke();\t\t\n\t\tctx.setFillColor(\"#188ffc\");\n\t\tctx.fillText(\"Hello World!\",150,50);\n\t\n\t绘制结果如下：\n\t\n![android_shape](Android平台上的JavaScript引擎/android_shape.png)\n\t\n以上仅是该实例的简单实现，详细的代码和设计可以根据需求的不同而进行细化，此处<https://github.com/LiuHongtao/JustDraw>提供一份具体实现的参考。由于每执行一个Canvas方法都将调用一次Java方法，该方案当绘制量过大的时候会出现JNI调用的性能问题，在性能方面也存在优化的空间，后续工作中将进行调用的优化，减少JNI调用次数。\n\nJ2V8的团队开发的一套移动端跨平台框架[Tabris.js](https://tabrisjs.com/)，支持Android和iOS平台，又于近期宣布支持Windows 10。该框架旨在编写一份JavaScript代码，而能生成Android和iOS两个平台的本地应用。它在Android上使用了J2V8作为JS引擎方案，在iOS上使用系统自带的JSCore。\n\n不同于ReactNative、Weex之类的框架，它的亮点在于不通过WebView，但却能使用Web APIs，如Canvas 2d context（据了解，Weex也正在测试Canvas组件并即将开源）、XMLHttpRequest、localStorage。该框架通过批处理回调减少了JNI的调用，在一定程度上解决了JNI性能问题，例如其Canvas相关代码`tabris.CanvasContext`中，先将每次调用的Canvas方法和参数存储起来，并在适当的时候通过一次JNI调用来传递要执行的Canvas方法，相关代码如下：\n\n\tdefineMethod(\"fillText\", 3, function(text, x, y /* , maxWidth */) {\n\t\tthis._strings.push(text);\n\t\tthis._booleans.push(false, false, false);\n\t\tthis._doubles.push(x, y);\n\t});\n\t\n\tfunction defineMethod(name, reqArgCount, fn) {\n    \ttabris.CanvasContext.prototype[name] = function() {\n    \t\tif (reqArgCount && arguments.length < reqArgCount) {\n    \t\t\tthrow new Error(\"Not enough arguments to CanvasContext.\" + name);\n    \t\t}\n    \t\tthis._pushOperation(name);\n    \t\tif (fn) {\n    \t\t\tfn.apply(this, arguments);\n    \t\t}\n    \t};\n    }\n    \n    _pushOperation: function(operation) {\n\t\tif (this._opCodes.indexOf(operation) < 0) {\n\t\t\tthis._newOpCodes.push(operation);\n\t\t\tthis._opCodes.push(operation);\n\t\t}\n\t\tthis._operations.push(this._opCodes.indexOf(operation));\n\t}\n\t\n\t_flush: function() {\n\t\tif (this._operations.length > 0) {\n\t\t\tthis._gc._nativeCall(\"draw\", {packedOperations: [\n\t          this._newOpCodes,\n\t          this._operations,\n\t          this._doubles,\n\t          this._booleans,\n\t          this._strings,\n\t          this._ints]});\n\t\t\tthis._newOpCodes = [];\n          this._operations = [];\n          this._doubles = [];\n          this._booleans = [];\n          this._strings = [];\n          this._ints = [];\n\t\t}\n\t}\n  \n\n也就是说Tabris.js更完整的的实现了本节中的方案，这也使得“将Web端JS库直接拿到移动端执行，并由本地输出结果”变得更加容易。\n\n相关文章\n\n* [Developing a mobile cross-platform library - Part 3. JavaScript](https://www.skyscanner.net/blogs/developing-mobile-cross-platform-library-part-3-javascript)\n\n* [Part I: How to Choose a JavaScript Engine for iOS and Android Development](http://openaphid.github.io/blog/2013/01/17/part-i-how-to-choose-a-javascript-engine-for-ios-and-android-apps/)\n\n* [Getting Started With J2V8](http://eclipsesource.com/blogs/getting-started-with-j2v8/)\n\n* [J2V8-A Highly Efficient JS Runtime For Java](https://www.eclipsecon.org/na2015/sites/default/files/slides/J2V8_0.pdf)\n\n* [Smile: Deploying a mobile app has never been so easy](http://eclipsesource.com/blogs/2016/08/10/smile-deploying-a-mobile-app-has-never-been-so-easy/)","source":"_posts/android/Android Js引擎/Android平台上的JavaScript引擎.md","raw":"---\ntitle: Android平台上的JavaScript引擎\n\ndate: 2016-12-23\n\nauthor: 刘宏涛\n\ncategories: android\n\ntags: \n- Js引擎\n\n---\nJavaScript引擎能够解析和执行JS脚本，帮助移动端进行跨平台开发。本文主要介绍和讨论JS引擎在Android系统上的使用和性能比较，并针对JS绘制本地化问题给出了基于V8的开发实例。<!-- more -->\n\n### 1. 前言\n\n近期在产品中遇到了这样的一个问题：Web端已经存在一个功能完善的JavaScript库，如果将相关Web嵌入到App中，则WebView将带来一定的性能影响；如果Android端本地开发一个相同的库，则需要消耗大量的资源。考虑到代码复用和跨平台开发，团队调研了JS引擎在Android上的使用，希望解决”不经过WebView，而将JS库拿到Android端运行，并将运行结果交给本地输出”这一需求。\n\nJS引擎能够解析JS脚本，通常被依附于浏览器中，例如Safari所使用的**JavaScriptCore**、Google Chrome所使用的**V8**和FireFox所使用的**SpiderMonkey**等等。也被用作移动端的跨平台开发，例如[NativeScript](http://developer.telerik.com/featured/nativescript-works/)在iOS端和Android分别使用了JavaScriptCore和V8，[ReactNative](https://facebook.github.io/react-native/docs/javascript-environment.html)则都使用了JavaScriptCore。\n\n### 2. JS引擎介绍\n\n在Android系统中能运行的JS引擎有如下5种：\n\n#### 1. [JavaScriptCore](https://trac.webkit.org/wiki/JavaScriptCore)\n\nJavaScriptCore是一个在WebKit中提供JS引擎的开源框架，最近更新日期是2016年9月26日。目前该引擎由Apple维护，使用于Safari浏览器，iOS7后也集成到了iPhone平台。\n\n由于其使用C语言编写，因此在Android开发中并不能直接使用。Github上的开源项目[AndroidJSCore](https://github.com/ericwlange/AndroidJSCore)能够帮助开发者经过调用Java接口而使用JavaScriptCore。该项目由**ericwlange**维护，最新版本3.0.1发布于2016年7月31日，有API文档和示例代码，但缺少相关技术文章，并仍存在一些性能问题。\n\n#### 2. [V8](https://developers.google.com/v8/)\n\nV8是由Google开发并维护的高性能开源JS引擎，采用C++编写，使用于Google Chrome浏览器。最新版本为V8 5.5 beta，更新于2016年10月24日。\n\n同JavaScriptCore一样，在Android开发中，相关接口需要通过一层包装进行调用。Github上的开源项目[J2V8](https://github.com/eclipsesource/J2V8)，相关文章可在此处<http://eclipsesource.com/blogs/tag/j2v8/>查阅，最新版本4.6.0发布于2016年9月22日。\n\nJ2V8是一套针对V8的Java绑定。J2V8的开发为Android平台带来了高效的Javascript的执行环境，其以性能与内存消耗为设计目标。它采用了“基本类型优先”原则，意味着一个执行结果是基本类型，那么所返回的值也就是该基本类型。它还采用了“懒加载”技术，只有当JS执行结果被访问时，才会通过JNI复制到Java中。\n\n此外J2V8提供了`release()`方法，开发者在某一对象不再需要时主动调用该方法去释放本地对象句柄，释放规则如下：\n\n* 如果是由代码创建的对象，那么必须释放它；如果一个对象是通过返回语句传回来的话，系统会替你释放它；\n* 如果是由系统创建的对象，则无需担心释放，而如果对象是JS方法的返回值，就必须手动的释放它。\n\n#### 3. [SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey)\n\n开源JS引擎SpiderMonkey最初由Netscape开发，如今由Mozilla开发并维护，且被广泛用于Mozilla产品（如FireFox）。最新版本为SpiderMonkey 45，更新于2016年4月14日。\n\nSpiderMonkey提供了一些核心的JavaScript数据类型，如数字，字符串，数组，对象等等，以及一些方法如Array.push。它还使得每个应用程序都容易将其自己的对象和方法暴露给JavaScript代码。应用开发者可以决定应用如何将与所写脚本相关的对象暴露出来。\n\n#### 4. [Rhino](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino)\n\nRhino是由Mozilla开发的开源JS引擎。采用Java编写，因此可以直接调用，在JDK 6、JDK 7中更是捆绑了该引擎。最新版本为Rhino 1.7.7.1，更新于2016年2月1日。\n\n其提供的特性包括：\n\n* JavaScript 1.7的全部特性\n* 可以用脚本方式调用Java\n* 用一个JavaScript Shell来执行JavaScript脚本\n* 用一个JavaScript编译器来将JavaScript脚本文件转换成Java类文件\n* 用一个JavaScript调试器来调试Rhino执行的脚本\n\n#### 5. [Nashorn](http://openjdk.java.net/projects/nashorn/)\n\nNashorn由Oracle开发并维护，从JDK 8开始，Rhino被Nashorn代替，成为JDK默认JS引擎。Nashorn同JDK 8一同发布和开源，较Rhino而言性能更好，但不支持Android Dalvik虚拟机。\n\n### 3. JS引擎性能比较\n\n从可用性方面考虑，选取了JavaScriptCore+AndroidJSCore（下文由“JSCore”指代）、V8+J2V8（下文由“J2V8”指代）和Rhino三种方案进行实验。\n\n#### 3.1 创建JS环境\n\n部分引擎并不支持直接运行文件，因此将JS代码作为字符串交给JS引擎执行，执行过程中可以调用已注册到JS上下文的Java方法。\n\n##### 3.1.1 JSCore\n\n\t//创建JS上下文\n\tJSContext context = new JSContext();\n\t//创建Java方法\n\tJSFunction func = new JSFunction(context, \"func\") {\n\t\tpublic void func(String msg) {\n\t\t\t//相关处理\n\t\t}\n\t};\n\t//将Java方法注册到JS上下文\n\tcontext.property(\"func\", func);\n\t//执行JS\n\tcontext.evaluateScript(/*JS代码*/);\n\t\n##### 3.1.2 J2V8\n\n\t//创建JS上下文\n\tV8 context = V8.createV8Runtime();\n\t//创建Java方法，并注册到JS上下文\n\tcontext.registerJavaMethod(new JavaVoidCallback() {\n\t    public void invoke(final V8Object receiver, final V8Array parameters) {\n\t        //相关处理\n\t    }\n\t}, \"func\");\n\t//执行JS\n\tcontext.executeScript(js);\n\t//释放资源\n\tcontext.release();\n\t\n##### 3.1.3 Rhino\n\n\tclass Func {\n\t\tvoid func(String msg) {\n\t\t\t//相关处理\n\t\t}\n\t}\n\n\t//创建JS上下文\n\tContext context = Context.enter();\n\tcontext.setOptimizationLevel(-1);\n\tScriptable scope = context.initStandardObjects();\n\ttry {\n\t\t//执行JS\n\t    context.evaluateString(scope, js, \"RhinoUtil\", 1, null);\n\t\n\t    //将Java方法封装到类中，并作为参数传递给JS方法\n\t    Function function = (Function) scope.get(\"rhinofunc\", scope);\n\t    function.call(context, scope, scope, new Object[]{new Func()});\n\t} finally {\n\t    Context.exit();\n\t}\n\t\n#### 3.2 实验〇：包的依赖\n\n比较各方案依赖包引入后，apk的体积增量：\n\n||依赖包占用(MB)|依赖方式|\n|---|---|---|\n|J2V8|8.2|compile 'com.eclipsesource.j2v8:j2v8:4.6.0@aar'|\n|JSCore|44.9😳|compile 'com.github.ericwlange:AndroidJSCore:3.0.1'|\n|Rhino|0.6|将jar包放入libs文件夹下|\n\n* J2V8引入的是全平台包，实际上它有针对Linux、Windows、MacOS、Android各平台进行打包，而Android平台最新版本为3.0.5（约4MB），并不是最新的4.6.0版本\n* 具AndroidJsCore作者回答，由于必须针对各CPU架构进行打包，而有7种CPU架构，每种架构包约6MB，因此整个依赖包体积相比之下显得庞大，但也可以通过ABIs Splits进行拆分。\n* Rhino的jar包仅1.2M，因此apk增量并不显著。\n\n#### 3.3 实验一：空循环\n\nJSCore和J2V8执行JS代码如下：\n\n\tvar i = 0;\n\tfor (;i < /*次数*/; i++) {\n\t}\n\t\nRhino执行JS代码如下：\n\n\tfunction rhinofunc(f) {\n\t    var i = 0;\n\t    for (;i < /*次数*/; i++) {\n\t    }\n\t}\n\t\n循环次数分别设置为100万、1000万、1亿次，在Java代码中执行JS前输出开始时间，在JS执行后输出结束时间，相减得出执行时间记录如下：\n\n|执行时间(ms)|100万次|1000万次|1亿次|\n|---|---|---|---|\n|J2V8|17.6|122.8|1116.6|\n|JSCore|22|173.2|1551|\n|Rhino|2078.4|22358.4|198600😳|\n\n由实验结果可以看到：J2V8和JSCore相比，J2V8执行时间更短，但两者时间都在同一数量级上。而Rhino执行时间远大于前两者，根本原因在于Java程序运行较C/C++慢。\n\n#### 3.4 实验二：JS调用Java方法\n\nJSCore和J2V8执行JS代码如下：\n\n\tvar i = 0;\n\tfor (;i < /*次数*/; i++) {\n\t\tfunc();\n\t}\n\t\nRhino执行JS代码如下：\n\n\tfunction rhinofunc(f) {\n\t    var i = 0;\n\t    for (;i < /*次数*/; i++) {\n\t    \tf.func();\n\t    }\n\t}\n\n调用次数分别设置为1万、10万、100万次，记录执行时间如下：\n\n|执行时间(ms)|1万次|10万次|100万次|\n|---|---|---|---|\n|J2V8|490.2|4855.8|47527|\n|JSCore|1287.6|13448.2|121586.8😳|\n|Rhino|408.2|4007.2|36752.4|\n\n启动App时记录占用内存，JS执行过程中记录最高占用内存，相减得出占用内存。\n\n|占用内存(KB)|1万次|10万次|100万次|\n|---|---|---|---|\n|J2V8|7264|14004|17328|\n|JSCore|15368|15140|16720|\n|Rhino|2776|9084|9116|\n\n同样也是由于开发语言的差异，在JS调用Java上Rhino性能更优。执行时间方面，J2V8接近Rhino，而JSCore则远落后于前两种方案，这可能与其Java绑定层有很大关系。对于J2V8和JSCore则需要先经过JNI包装层才能调用到Java方法，而大量的JNI调用是非常耗时、耗内存的。\n\n#### 3.5 实验三：JS递归计算斐波那契\n\nJS代码斐波那契函数如下：\n\n\tfunction fibo(n) {\n\t    if (n == 1 || n == 2) {\n\t        return 1;\n\t    }\n\t    else {\n\t        return fibo(n - 1) + fibo(n - 2);\n\t    }\n\t}\n\n|执行时间(ms)|fibo(20)|fibo(30)|fibo(40)|\n|---|---|---|---|\n|J2V8|4|67.6|8158.6|\n|JSCore|6.6|76.2|7884.4|\n|Rhino|248.4|26898|???😳|\n\n|占用内存(KB)|fibo(20)|fibo(30)|fibo(40)|\n|---|---|---|---|\n|J2V8|6148|6120|17328|\n|JSCore|6204|6200|16720|\n|Rhino|5284|9052|9116|\n\nRhino运行JS时频繁GC，虽然使其所占内存较少，但执行速度非常缓慢，相比之下J2V8和JSCore方案效率更高。\n\n#### 3.6 实验总结\n\n单从JS引擎来说：Rhino执行不需要通过JNI且占用更少的内存，但执行效率很低；V8和JavaScriptCore等C语言开发的引擎远胜于Rhino等Java开发的引擎，但需要一层Java包装层，并存在JNI调用性能问题。就J2V8和AndroidJSCore两个包装层而言：J2V8的可用性、可靠性、健壮性更优；AndroidJSCore还存在着不少的性能问题，在上述实验中出现较少，但实际开发中还存在很多坑。\n\n以上三种实现方案中更推荐J2V8方案。对于内存问题，J2V8的内存释放机制较为完善，在实际开发中可以通过主动release来释放内存；对于JNI调用性能问题，J2V8团队也在尝试通过批处理回调来进行优化，在将来的版本中会得到改善。\n\n### 4. J2V8的Android开发实例\n\n有以下一段JS代码，其中Canvas绘制了一些简单的图形：\n\n\tvar c=document.getElementById(\"myCanvas\");\n\tvar ctx=c.getContext(\"2d\");\n\t\n\tctx.beginPath();\n\tctx.arc(100, 100, 25, 0, 360, false);\n\tctx.moveTo(20,20);\n\tctx.lineTo(20,100);\n\tctx.lineTo(70,100);\n\tctx.moveTo(100, 100);\n\tctx.setLineWidth(15);\n\tctx.setStrokeColor(\"#188ffc\");\n\tctx.stroke();\n\t\n\tctx.setFillColor(\"#188ffc\");\n\tctx.fillText(\"Hello World!\",150,50);\n\t\n其在Web端绘制效果如下：\n\n![logo](Android平台上的JavaScript引擎/web_shape.png)\n\n实例中，借助J2V8在Android端运行同样一段脚本，使图形绘制到Android Canvas中。下面给出简单实现，主要思路为自定义View，JS中将要绘制的图形先存储到在List中，待整个JS脚本执行完毕，再将所有图形在`View.onDraw(Canvas canvas)`中通过Android Canvas绘制。\n\n1) 将ctx封装为V8Object，并在其中对应实现JS Canvas的方法\n\n\t\tpublic class JustContext {\n\t\t\tprotected V8 mRuntime;\n\t\t\tprotected V8Object mCtx;\n\t\t\tprivate ArrayList<AbstractDraw> mShapeList = new ArrayList<>();\n\t\t\n\t\t\tpublic JustContext(V8 v8Runtime) {\n\t\t\t\tmRuntime = v8Runtime;\n\t\t\t\tinitCtx();\n\t\t\t}\n\t\t\t\n\t\t\tpublic V8Object getCtx() {\n\t\t\t\treturn mCtx;\n\t\t\t}\n\t\t\t\n\t\t\tpublic ArrayList<AbstractDraw> getShapeList() {\n\t\t\t\treturn mShapeList;\n\t\t\t}\n\t\t\t\t    \n\t\t\tprotected void initCtx() {\n\t\t\t\tmCtx = new V8Object(mRuntime);\n\t\t\t\t\n\t\t\t\t//将Java方法注册到该V8Object中\n\t\t\t\tmCtx.registerJavaMethod(this, \"beginPath\", \"beginPath\", null);\n        \t\tmCtx.registerJavaMethod(this, \"closePath\", \"closePath\", null);\n        \t\t\n        \t\t...\n\t\t\t}\n\t\t\t\n\t\t\tpublic void clean() {\n\t\t\t\tmCtx.release();\n\t\t\t}\n\t\t\t\n\t\t\tpublic void beginPath() {...}\n\t\t\t\n\t\t\tpublic void closePath() {...}\n\t\t\t\n\t\t\t...\n\t\t}\n\n\n2) 自定义View，在View的`onDraw(Canvas canvas)`方法中将传入的图形List绘制出来\n\n\t\tpublic class JustView extends View implements Serializable {\n\t\t\t...\n\t\t\t\n\t\t\tprivate ArrayList<AbstractDraw> mShapeList = new ArrayList<>();\n\t\t\n\t\t\tpublic void setShapeList(ArrayList<AbstractDraw> shapeList) {\n\t\t\t\tthis.mShapeList = shapeList;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t    protected void onDraw(Canvas canvas) {\n\t\t        super.onDraw(canvas);\n\t\t\n\t\t        for (AbstractDraw abstractDraw : mShapeList) {\n\t\t            abstractDraw.draw(canvas);\n\t\t        }\n\t\t    }\n\t\t\t\n\t\t\t...\n\t\t}\n\n3) 将ctx注册到JS上下文，并执行JS代码，执行完毕后将绘制图形List传递给View\n\t\n\t\tJustView mJustView;\n\t\t...\n\t\t\n\t\tpublic void runJs(String js) {\n\t\t\tV8 context = V8.createV8Runtime();\n\t\t\tJustContext ctx = new JustContext(context);\n\t\t\tcontext.add(\"ctx\", ctx.getCtx());\n\t\t\tcontext.executeScript(js);\n\t\t\t\n\t\t\t//释放内存\n\t\t\tctx.clean();\n\t\t\tcontext.release();\n\t\t\t\n\t\t\tmJustView.setShapeList(ctx.getShapeList());\n\t\t}\n\t\t\n\t\t...\n\t\t\n\t\n4) 因为已将ctx注册到JS上下文，因此可以直接使用`ctx`变量，并运行如下JS代码\n\n\t\tctx.beginPath();\n\t\tctx.arc(100, 100, 25, 0, 360, false);\n\t\tctx.moveTo(20,20);\n\t\tctx.lineTo(20,100);\n\t\tctx.lineTo(70,100);\n\t\tctx.moveTo(100, 100);\n\t\tctx.setLineWidth(15);\n\t\tctx.setStrokeColor(\"#188ffc\");\n\t\tctx.stroke();\t\t\n\t\tctx.setFillColor(\"#188ffc\");\n\t\tctx.fillText(\"Hello World!\",150,50);\n\t\n\t绘制结果如下：\n\t\n![android_shape](Android平台上的JavaScript引擎/android_shape.png)\n\t\n以上仅是该实例的简单实现，详细的代码和设计可以根据需求的不同而进行细化，此处<https://github.com/LiuHongtao/JustDraw>提供一份具体实现的参考。由于每执行一个Canvas方法都将调用一次Java方法，该方案当绘制量过大的时候会出现JNI调用的性能问题，在性能方面也存在优化的空间，后续工作中将进行调用的优化，减少JNI调用次数。\n\nJ2V8的团队开发的一套移动端跨平台框架[Tabris.js](https://tabrisjs.com/)，支持Android和iOS平台，又于近期宣布支持Windows 10。该框架旨在编写一份JavaScript代码，而能生成Android和iOS两个平台的本地应用。它在Android上使用了J2V8作为JS引擎方案，在iOS上使用系统自带的JSCore。\n\n不同于ReactNative、Weex之类的框架，它的亮点在于不通过WebView，但却能使用Web APIs，如Canvas 2d context（据了解，Weex也正在测试Canvas组件并即将开源）、XMLHttpRequest、localStorage。该框架通过批处理回调减少了JNI的调用，在一定程度上解决了JNI性能问题，例如其Canvas相关代码`tabris.CanvasContext`中，先将每次调用的Canvas方法和参数存储起来，并在适当的时候通过一次JNI调用来传递要执行的Canvas方法，相关代码如下：\n\n\tdefineMethod(\"fillText\", 3, function(text, x, y /* , maxWidth */) {\n\t\tthis._strings.push(text);\n\t\tthis._booleans.push(false, false, false);\n\t\tthis._doubles.push(x, y);\n\t});\n\t\n\tfunction defineMethod(name, reqArgCount, fn) {\n    \ttabris.CanvasContext.prototype[name] = function() {\n    \t\tif (reqArgCount && arguments.length < reqArgCount) {\n    \t\t\tthrow new Error(\"Not enough arguments to CanvasContext.\" + name);\n    \t\t}\n    \t\tthis._pushOperation(name);\n    \t\tif (fn) {\n    \t\t\tfn.apply(this, arguments);\n    \t\t}\n    \t};\n    }\n    \n    _pushOperation: function(operation) {\n\t\tif (this._opCodes.indexOf(operation) < 0) {\n\t\t\tthis._newOpCodes.push(operation);\n\t\t\tthis._opCodes.push(operation);\n\t\t}\n\t\tthis._operations.push(this._opCodes.indexOf(operation));\n\t}\n\t\n\t_flush: function() {\n\t\tif (this._operations.length > 0) {\n\t\t\tthis._gc._nativeCall(\"draw\", {packedOperations: [\n\t          this._newOpCodes,\n\t          this._operations,\n\t          this._doubles,\n\t          this._booleans,\n\t          this._strings,\n\t          this._ints]});\n\t\t\tthis._newOpCodes = [];\n          this._operations = [];\n          this._doubles = [];\n          this._booleans = [];\n          this._strings = [];\n          this._ints = [];\n\t\t}\n\t}\n  \n\n也就是说Tabris.js更完整的的实现了本节中的方案，这也使得“将Web端JS库直接拿到移动端执行，并由本地输出结果”变得更加容易。\n\n相关文章\n\n* [Developing a mobile cross-platform library - Part 3. JavaScript](https://www.skyscanner.net/blogs/developing-mobile-cross-platform-library-part-3-javascript)\n\n* [Part I: How to Choose a JavaScript Engine for iOS and Android Development](http://openaphid.github.io/blog/2013/01/17/part-i-how-to-choose-a-javascript-engine-for-ios-and-android-apps/)\n\n* [Getting Started With J2V8](http://eclipsesource.com/blogs/getting-started-with-j2v8/)\n\n* [J2V8-A Highly Efficient JS Runtime For Java](https://www.eclipsecon.org/na2015/sites/default/files/slides/J2V8_0.pdf)\n\n* [Smile: Deploying a mobile app has never been so easy](http://eclipsesource.com/blogs/2016/08/10/smile-deploying-a-mobile-app-has-never-been-so-easy/)","slug":"android/Android Js引擎/Android平台上的JavaScript引擎","published":1,"updated":"2017-01-05T05:45:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixk0c24o000h7ekkw1v0m0vu","content":"<p>JavaScript引擎能够解析和执行JS脚本，帮助移动端进行跨平台开发。本文主要介绍和讨论JS引擎在Android系统上的使用和性能比较，并针对JS绘制本地化问题给出了基于V8的开发实例。<a id=\"more\"></a></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>近期在产品中遇到了这样的一个问题：Web端已经存在一个功能完善的JavaScript库，如果将相关Web嵌入到App中，则WebView将带来一定的性能影响；如果Android端本地开发一个相同的库，则需要消耗大量的资源。考虑到代码复用和跨平台开发，团队调研了JS引擎在Android上的使用，希望解决”不经过WebView，而将JS库拿到Android端运行，并将运行结果交给本地输出”这一需求。</p>\n<p>JS引擎能够解析JS脚本，通常被依附于浏览器中，例如Safari所使用的<strong>JavaScriptCore</strong>、Google Chrome所使用的<strong>V8</strong>和FireFox所使用的<strong>SpiderMonkey</strong>等等。也被用作移动端的跨平台开发，例如<a href=\"http://developer.telerik.com/featured/nativescript-works/\" target=\"_blank\" rel=\"external\">NativeScript</a>在iOS端和Android分别使用了JavaScriptCore和V8，<a href=\"https://facebook.github.io/react-native/docs/javascript-environment.html\" target=\"_blank\" rel=\"external\">ReactNative</a>则都使用了JavaScriptCore。</p>\n<h3 id=\"2-JS引擎介绍\"><a href=\"#2-JS引擎介绍\" class=\"headerlink\" title=\"2. JS引擎介绍\"></a>2. JS引擎介绍</h3><p>在Android系统中能运行的JS引擎有如下5种：</p>\n<h4 id=\"1-JavaScriptCore\"><a href=\"#1-JavaScriptCore\" class=\"headerlink\" title=\"1. JavaScriptCore\"></a>1. <a href=\"https://trac.webkit.org/wiki/JavaScriptCore\" target=\"_blank\" rel=\"external\">JavaScriptCore</a></h4><p>JavaScriptCore是一个在WebKit中提供JS引擎的开源框架，最近更新日期是2016年9月26日。目前该引擎由Apple维护，使用于Safari浏览器，iOS7后也集成到了iPhone平台。</p>\n<p>由于其使用C语言编写，因此在Android开发中并不能直接使用。Github上的开源项目<a href=\"https://github.com/ericwlange/AndroidJSCore\" target=\"_blank\" rel=\"external\">AndroidJSCore</a>能够帮助开发者经过调用Java接口而使用JavaScriptCore。该项目由<strong>ericwlange</strong>维护，最新版本3.0.1发布于2016年7月31日，有API文档和示例代码，但缺少相关技术文章，并仍存在一些性能问题。</p>\n<h4 id=\"2-V8\"><a href=\"#2-V8\" class=\"headerlink\" title=\"2. V8\"></a>2. <a href=\"https://developers.google.com/v8/\" target=\"_blank\" rel=\"external\">V8</a></h4><p>V8是由Google开发并维护的高性能开源JS引擎，采用C++编写，使用于Google Chrome浏览器。最新版本为V8 5.5 beta，更新于2016年10月24日。</p>\n<p>同JavaScriptCore一样，在Android开发中，相关接口需要通过一层包装进行调用。Github上的开源项目<a href=\"https://github.com/eclipsesource/J2V8\" target=\"_blank\" rel=\"external\">J2V8</a>，相关文章可在此处<a href=\"http://eclipsesource.com/blogs/tag/j2v8/\" target=\"_blank\" rel=\"external\">http://eclipsesource.com/blogs/tag/j2v8/</a>查阅，最新版本4.6.0发布于2016年9月22日。</p>\n<p>J2V8是一套针对V8的Java绑定。J2V8的开发为Android平台带来了高效的Javascript的执行环境，其以性能与内存消耗为设计目标。它采用了“基本类型优先”原则，意味着一个执行结果是基本类型，那么所返回的值也就是该基本类型。它还采用了“懒加载”技术，只有当JS执行结果被访问时，才会通过JNI复制到Java中。</p>\n<p>此外J2V8提供了<code>release()</code>方法，开发者在某一对象不再需要时主动调用该方法去释放本地对象句柄，释放规则如下：</p>\n<ul>\n<li>如果是由代码创建的对象，那么必须释放它；如果一个对象是通过返回语句传回来的话，系统会替你释放它；</li>\n<li>如果是由系统创建的对象，则无需担心释放，而如果对象是JS方法的返回值，就必须手动的释放它。</li>\n</ul>\n<h4 id=\"3-SpiderMonkey\"><a href=\"#3-SpiderMonkey\" class=\"headerlink\" title=\"3. SpiderMonkey\"></a>3. <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey\" target=\"_blank\" rel=\"external\">SpiderMonkey</a></h4><p>开源JS引擎SpiderMonkey最初由Netscape开发，如今由Mozilla开发并维护，且被广泛用于Mozilla产品（如FireFox）。最新版本为SpiderMonkey 45，更新于2016年4月14日。</p>\n<p>SpiderMonkey提供了一些核心的JavaScript数据类型，如数字，字符串，数组，对象等等，以及一些方法如Array.push。它还使得每个应用程序都容易将其自己的对象和方法暴露给JavaScript代码。应用开发者可以决定应用如何将与所写脚本相关的对象暴露出来。</p>\n<h4 id=\"4-Rhino\"><a href=\"#4-Rhino\" class=\"headerlink\" title=\"4. Rhino\"></a>4. <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino\" target=\"_blank\" rel=\"external\">Rhino</a></h4><p>Rhino是由Mozilla开发的开源JS引擎。采用Java编写，因此可以直接调用，在JDK 6、JDK 7中更是捆绑了该引擎。最新版本为Rhino 1.7.7.1，更新于2016年2月1日。</p>\n<p>其提供的特性包括：</p>\n<ul>\n<li>JavaScript 1.7的全部特性</li>\n<li>可以用脚本方式调用Java</li>\n<li>用一个JavaScript Shell来执行JavaScript脚本</li>\n<li>用一个JavaScript编译器来将JavaScript脚本文件转换成Java类文件</li>\n<li>用一个JavaScript调试器来调试Rhino执行的脚本</li>\n</ul>\n<h4 id=\"5-Nashorn\"><a href=\"#5-Nashorn\" class=\"headerlink\" title=\"5. Nashorn\"></a>5. <a href=\"http://openjdk.java.net/projects/nashorn/\" target=\"_blank\" rel=\"external\">Nashorn</a></h4><p>Nashorn由Oracle开发并维护，从JDK 8开始，Rhino被Nashorn代替，成为JDK默认JS引擎。Nashorn同JDK 8一同发布和开源，较Rhino而言性能更好，但不支持Android Dalvik虚拟机。</p>\n<h3 id=\"3-JS引擎性能比较\"><a href=\"#3-JS引擎性能比较\" class=\"headerlink\" title=\"3. JS引擎性能比较\"></a>3. JS引擎性能比较</h3><p>从可用性方面考虑，选取了JavaScriptCore+AndroidJSCore（下文由“JSCore”指代）、V8+J2V8（下文由“J2V8”指代）和Rhino三种方案进行实验。</p>\n<h4 id=\"3-1-创建JS环境\"><a href=\"#3-1-创建JS环境\" class=\"headerlink\" title=\"3.1 创建JS环境\"></a>3.1 创建JS环境</h4><p>部分引擎并不支持直接运行文件，因此将JS代码作为字符串交给JS引擎执行，执行过程中可以调用已注册到JS上下文的Java方法。</p>\n<h5 id=\"3-1-1-JSCore\"><a href=\"#3-1-1-JSCore\" class=\"headerlink\" title=\"3.1.1 JSCore\"></a>3.1.1 JSCore</h5><pre><code>//创建JS上下文\nJSContext context = new JSContext();\n//创建Java方法\nJSFunction func = new JSFunction(context, &quot;func&quot;) {\n    public void func(String msg) {\n        //相关处理\n    }\n};\n//将Java方法注册到JS上下文\ncontext.property(&quot;func&quot;, func);\n//执行JS\ncontext.evaluateScript(/*JS代码*/);\n</code></pre><h5 id=\"3-1-2-J2V8\"><a href=\"#3-1-2-J2V8\" class=\"headerlink\" title=\"3.1.2 J2V8\"></a>3.1.2 J2V8</h5><pre><code>//创建JS上下文\nV8 context = V8.createV8Runtime();\n//创建Java方法，并注册到JS上下文\ncontext.registerJavaMethod(new JavaVoidCallback() {\n    public void invoke(final V8Object receiver, final V8Array parameters) {\n        //相关处理\n    }\n}, &quot;func&quot;);\n//执行JS\ncontext.executeScript(js);\n//释放资源\ncontext.release();\n</code></pre><h5 id=\"3-1-3-Rhino\"><a href=\"#3-1-3-Rhino\" class=\"headerlink\" title=\"3.1.3 Rhino\"></a>3.1.3 Rhino</h5><pre><code>class Func {\n    void func(String msg) {\n        //相关处理\n    }\n}\n\n//创建JS上下文\nContext context = Context.enter();\ncontext.setOptimizationLevel(-1);\nScriptable scope = context.initStandardObjects();\ntry {\n    //执行JS\n    context.evaluateString(scope, js, &quot;RhinoUtil&quot;, 1, null);\n\n    //将Java方法封装到类中，并作为参数传递给JS方法\n    Function function = (Function) scope.get(&quot;rhinofunc&quot;, scope);\n    function.call(context, scope, scope, new Object[]{new Func()});\n} finally {\n    Context.exit();\n}\n</code></pre><h4 id=\"3-2-实验〇：包的依赖\"><a href=\"#3-2-实验〇：包的依赖\" class=\"headerlink\" title=\"3.2 实验〇：包的依赖\"></a>3.2 实验〇：包的依赖</h4><p>比较各方案依赖包引入后，apk的体积增量：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>依赖包占用(MB)</th>\n<th>依赖方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>8.2</td>\n<td>compile ‘com.eclipsesource.j2v8:j2v8:4.6.0@aar’</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>44.9😳</td>\n<td>compile ‘com.github.ericwlange:AndroidJSCore:3.0.1’</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>0.6</td>\n<td>将jar包放入libs文件夹下</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>J2V8引入的是全平台包，实际上它有针对Linux、Windows、MacOS、Android各平台进行打包，而Android平台最新版本为3.0.5（约4MB），并不是最新的4.6.0版本</li>\n<li>具AndroidJsCore作者回答，由于必须针对各CPU架构进行打包，而有7种CPU架构，每种架构包约6MB，因此整个依赖包体积相比之下显得庞大，但也可以通过ABIs Splits进行拆分。</li>\n<li>Rhino的jar包仅1.2M，因此apk增量并不显著。</li>\n</ul>\n<h4 id=\"3-3-实验一：空循环\"><a href=\"#3-3-实验一：空循环\" class=\"headerlink\" title=\"3.3 实验一：空循环\"></a>3.3 实验一：空循环</h4><p>JSCore和J2V8执行JS代码如下：</p>\n<pre><code>var i = 0;\nfor (;i &lt; /*次数*/; i++) {\n}\n</code></pre><p>Rhino执行JS代码如下：</p>\n<pre><code>function rhinofunc(f) {\n    var i = 0;\n    for (;i &lt; /*次数*/; i++) {\n    }\n}\n</code></pre><p>循环次数分别设置为100万、1000万、1亿次，在Java代码中执行JS前输出开始时间，在JS执行后输出结束时间，相减得出执行时间记录如下：</p>\n<table>\n<thead>\n<tr>\n<th>执行时间(ms)</th>\n<th>100万次</th>\n<th>1000万次</th>\n<th>1亿次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>17.6</td>\n<td>122.8</td>\n<td>1116.6</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>22</td>\n<td>173.2</td>\n<td>1551</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>2078.4</td>\n<td>22358.4</td>\n<td>198600😳</td>\n</tr>\n</tbody>\n</table>\n<p>由实验结果可以看到：J2V8和JSCore相比，J2V8执行时间更短，但两者时间都在同一数量级上。而Rhino执行时间远大于前两者，根本原因在于Java程序运行较C/C++慢。</p>\n<h4 id=\"3-4-实验二：JS调用Java方法\"><a href=\"#3-4-实验二：JS调用Java方法\" class=\"headerlink\" title=\"3.4 实验二：JS调用Java方法\"></a>3.4 实验二：JS调用Java方法</h4><p>JSCore和J2V8执行JS代码如下：</p>\n<pre><code>var i = 0;\nfor (;i &lt; /*次数*/; i++) {\n    func();\n}\n</code></pre><p>Rhino执行JS代码如下：</p>\n<pre><code>function rhinofunc(f) {\n    var i = 0;\n    for (;i &lt; /*次数*/; i++) {\n        f.func();\n    }\n}\n</code></pre><p>调用次数分别设置为1万、10万、100万次，记录执行时间如下：</p>\n<table>\n<thead>\n<tr>\n<th>执行时间(ms)</th>\n<th>1万次</th>\n<th>10万次</th>\n<th>100万次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>490.2</td>\n<td>4855.8</td>\n<td>47527</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>1287.6</td>\n<td>13448.2</td>\n<td>121586.8😳</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>408.2</td>\n<td>4007.2</td>\n<td>36752.4</td>\n</tr>\n</tbody>\n</table>\n<p>启动App时记录占用内存，JS执行过程中记录最高占用内存，相减得出占用内存。</p>\n<table>\n<thead>\n<tr>\n<th>占用内存(KB)</th>\n<th>1万次</th>\n<th>10万次</th>\n<th>100万次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>7264</td>\n<td>14004</td>\n<td>17328</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>15368</td>\n<td>15140</td>\n<td>16720</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>2776</td>\n<td>9084</td>\n<td>9116</td>\n</tr>\n</tbody>\n</table>\n<p>同样也是由于开发语言的差异，在JS调用Java上Rhino性能更优。执行时间方面，J2V8接近Rhino，而JSCore则远落后于前两种方案，这可能与其Java绑定层有很大关系。对于J2V8和JSCore则需要先经过JNI包装层才能调用到Java方法，而大量的JNI调用是非常耗时、耗内存的。</p>\n<h4 id=\"3-5-实验三：JS递归计算斐波那契\"><a href=\"#3-5-实验三：JS递归计算斐波那契\" class=\"headerlink\" title=\"3.5 实验三：JS递归计算斐波那契\"></a>3.5 实验三：JS递归计算斐波那契</h4><p>JS代码斐波那契函数如下：</p>\n<pre><code>function fibo(n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    else {\n        return fibo(n - 1) + fibo(n - 2);\n    }\n}\n</code></pre><table>\n<thead>\n<tr>\n<th>执行时间(ms)</th>\n<th>fibo(20)</th>\n<th>fibo(30)</th>\n<th>fibo(40)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>4</td>\n<td>67.6</td>\n<td>8158.6</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>6.6</td>\n<td>76.2</td>\n<td>7884.4</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>248.4</td>\n<td>26898</td>\n<td>???😳</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>占用内存(KB)</th>\n<th>fibo(20)</th>\n<th>fibo(30)</th>\n<th>fibo(40)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>6148</td>\n<td>6120</td>\n<td>17328</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>6204</td>\n<td>6200</td>\n<td>16720</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>5284</td>\n<td>9052</td>\n<td>9116</td>\n</tr>\n</tbody>\n</table>\n<p>Rhino运行JS时频繁GC，虽然使其所占内存较少，但执行速度非常缓慢，相比之下J2V8和JSCore方案效率更高。</p>\n<h4 id=\"3-6-实验总结\"><a href=\"#3-6-实验总结\" class=\"headerlink\" title=\"3.6 实验总结\"></a>3.6 实验总结</h4><p>单从JS引擎来说：Rhino执行不需要通过JNI且占用更少的内存，但执行效率很低；V8和JavaScriptCore等C语言开发的引擎远胜于Rhino等Java开发的引擎，但需要一层Java包装层，并存在JNI调用性能问题。就J2V8和AndroidJSCore两个包装层而言：J2V8的可用性、可靠性、健壮性更优；AndroidJSCore还存在着不少的性能问题，在上述实验中出现较少，但实际开发中还存在很多坑。</p>\n<p>以上三种实现方案中更推荐J2V8方案。对于内存问题，J2V8的内存释放机制较为完善，在实际开发中可以通过主动release来释放内存；对于JNI调用性能问题，J2V8团队也在尝试通过批处理回调来进行优化，在将来的版本中会得到改善。</p>\n<h3 id=\"4-J2V8的Android开发实例\"><a href=\"#4-J2V8的Android开发实例\" class=\"headerlink\" title=\"4. J2V8的Android开发实例\"></a>4. J2V8的Android开发实例</h3><p>有以下一段JS代码，其中Canvas绘制了一些简单的图形：</p>\n<pre><code>var c=document.getElementById(&quot;myCanvas&quot;);\nvar ctx=c.getContext(&quot;2d&quot;);\n\nctx.beginPath();\nctx.arc(100, 100, 25, 0, 360, false);\nctx.moveTo(20,20);\nctx.lineTo(20,100);\nctx.lineTo(70,100);\nctx.moveTo(100, 100);\nctx.setLineWidth(15);\nctx.setStrokeColor(&quot;#188ffc&quot;);\nctx.stroke();\n\nctx.setFillColor(&quot;#188ffc&quot;);\nctx.fillText(&quot;Hello World!&quot;,150,50);\n</code></pre><p>其在Web端绘制效果如下：</p>\n<p><img src=\"Android平台上的JavaScript引擎/web_shape.png\" alt=\"logo\"></p>\n<p>实例中，借助J2V8在Android端运行同样一段脚本，使图形绘制到Android Canvas中。下面给出简单实现，主要思路为自定义View，JS中将要绘制的图形先存储到在List中，待整个JS脚本执行完毕，再将所有图形在<code>View.onDraw(Canvas canvas)</code>中通过Android Canvas绘制。</p>\n<p>1) 将ctx封装为V8Object，并在其中对应实现JS Canvas的方法</p>\n<pre><code>public class JustContext {\n    protected V8 mRuntime;\n    protected V8Object mCtx;\n    private ArrayList&lt;AbstractDraw&gt; mShapeList = new ArrayList&lt;&gt;();\n\n    public JustContext(V8 v8Runtime) {\n        mRuntime = v8Runtime;\n        initCtx();\n    }\n\n    public V8Object getCtx() {\n        return mCtx;\n    }\n\n    public ArrayList&lt;AbstractDraw&gt; getShapeList() {\n        return mShapeList;\n    }\n\n    protected void initCtx() {\n        mCtx = new V8Object(mRuntime);\n\n        //将Java方法注册到该V8Object中\n        mCtx.registerJavaMethod(this, &quot;beginPath&quot;, &quot;beginPath&quot;, null);\n        mCtx.registerJavaMethod(this, &quot;closePath&quot;, &quot;closePath&quot;, null);\n\n        ...\n    }\n\n    public void clean() {\n        mCtx.release();\n    }\n\n    public void beginPath() {...}\n\n    public void closePath() {...}\n\n    ...\n}\n</code></pre><p>2) 自定义View，在View的<code>onDraw(Canvas canvas)</code>方法中将传入的图形List绘制出来</p>\n<pre><code>public class JustView extends View implements Serializable {\n    ...\n\n    private ArrayList&lt;AbstractDraw&gt; mShapeList = new ArrayList&lt;&gt;();\n\n    public void setShapeList(ArrayList&lt;AbstractDraw&gt; shapeList) {\n        this.mShapeList = shapeList;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        for (AbstractDraw abstractDraw : mShapeList) {\n            abstractDraw.draw(canvas);\n        }\n    }\n\n    ...\n}\n</code></pre><p>3) 将ctx注册到JS上下文，并执行JS代码，执行完毕后将绘制图形List传递给View</p>\n<pre><code>JustView mJustView;\n...\n\npublic void runJs(String js) {\n    V8 context = V8.createV8Runtime();\n    JustContext ctx = new JustContext(context);\n    context.add(&quot;ctx&quot;, ctx.getCtx());\n    context.executeScript(js);\n\n    //释放内存\n    ctx.clean();\n    context.release();\n\n    mJustView.setShapeList(ctx.getShapeList());\n}\n\n...\n</code></pre><p>4) 因为已将ctx注册到JS上下文，因此可以直接使用<code>ctx</code>变量，并运行如下JS代码</p>\n<pre><code>    ctx.beginPath();\n    ctx.arc(100, 100, 25, 0, 360, false);\n    ctx.moveTo(20,20);\n    ctx.lineTo(20,100);\n    ctx.lineTo(70,100);\n    ctx.moveTo(100, 100);\n    ctx.setLineWidth(15);\n    ctx.setStrokeColor(&quot;#188ffc&quot;);\n    ctx.stroke();        \n    ctx.setFillColor(&quot;#188ffc&quot;);\n    ctx.fillText(&quot;Hello World!&quot;,150,50);\n\n绘制结果如下：\n</code></pre><p><img src=\"Android平台上的JavaScript引擎/android_shape.png\" alt=\"android_shape\"></p>\n<p>以上仅是该实例的简单实现，详细的代码和设计可以根据需求的不同而进行细化，此处<a href=\"https://github.com/LiuHongtao/JustDraw\" target=\"_blank\" rel=\"external\">https://github.com/LiuHongtao/JustDraw</a>提供一份具体实现的参考。由于每执行一个Canvas方法都将调用一次Java方法，该方案当绘制量过大的时候会出现JNI调用的性能问题，在性能方面也存在优化的空间，后续工作中将进行调用的优化，减少JNI调用次数。</p>\n<p>J2V8的团队开发的一套移动端跨平台框架<a href=\"https://tabrisjs.com/\" target=\"_blank\" rel=\"external\">Tabris.js</a>，支持Android和iOS平台，又于近期宣布支持Windows 10。该框架旨在编写一份JavaScript代码，而能生成Android和iOS两个平台的本地应用。它在Android上使用了J2V8作为JS引擎方案，在iOS上使用系统自带的JSCore。</p>\n<p>不同于ReactNative、Weex之类的框架，它的亮点在于不通过WebView，但却能使用Web APIs，如Canvas 2d context（据了解，Weex也正在测试Canvas组件并即将开源）、XMLHttpRequest、localStorage。该框架通过批处理回调减少了JNI的调用，在一定程度上解决了JNI性能问题，例如其Canvas相关代码<code>tabris.CanvasContext</code>中，先将每次调用的Canvas方法和参数存储起来，并在适当的时候通过一次JNI调用来传递要执行的Canvas方法，相关代码如下：</p>\n<pre><code>defineMethod(&quot;fillText&quot;, 3, function(text, x, y /* , maxWidth */) {\n    this._strings.push(text);\n    this._booleans.push(false, false, false);\n    this._doubles.push(x, y);\n});\n\nfunction defineMethod(name, reqArgCount, fn) {\n    tabris.CanvasContext.prototype[name] = function() {\n        if (reqArgCount &amp;&amp; arguments.length &lt; reqArgCount) {\n            throw new Error(&quot;Not enough arguments to CanvasContext.&quot; + name);\n        }\n        this._pushOperation(name);\n        if (fn) {\n            fn.apply(this, arguments);\n        }\n    };\n}\n\n_pushOperation: function(operation) {\n    if (this._opCodes.indexOf(operation) &lt; 0) {\n        this._newOpCodes.push(operation);\n        this._opCodes.push(operation);\n    }\n    this._operations.push(this._opCodes.indexOf(operation));\n}\n\n_flush: function() {\n    if (this._operations.length &gt; 0) {\n        this._gc._nativeCall(&quot;draw&quot;, {packedOperations: [\n          this._newOpCodes,\n          this._operations,\n          this._doubles,\n          this._booleans,\n          this._strings,\n          this._ints]});\n        this._newOpCodes = [];\n      this._operations = [];\n      this._doubles = [];\n      this._booleans = [];\n      this._strings = [];\n      this._ints = [];\n    }\n}\n</code></pre><p>也就是说Tabris.js更完整的的实现了本节中的方案，这也使得“将Web端JS库直接拿到移动端执行，并由本地输出结果”变得更加容易。</p>\n<p>相关文章</p>\n<ul>\n<li><p><a href=\"https://www.skyscanner.net/blogs/developing-mobile-cross-platform-library-part-3-javascript\" target=\"_blank\" rel=\"external\">Developing a mobile cross-platform library - Part 3. JavaScript</a></p>\n</li>\n<li><p><a href=\"http://openaphid.github.io/blog/2013/01/17/part-i-how-to-choose-a-javascript-engine-for-ios-and-android-apps/\" target=\"_blank\" rel=\"external\">Part I: How to Choose a JavaScript Engine for iOS and Android Development</a></p>\n</li>\n<li><p><a href=\"http://eclipsesource.com/blogs/getting-started-with-j2v8/\" target=\"_blank\" rel=\"external\">Getting Started With J2V8</a></p>\n</li>\n<li><p><a href=\"https://www.eclipsecon.org/na2015/sites/default/files/slides/J2V8_0.pdf\" target=\"_blank\" rel=\"external\">J2V8-A Highly Efficient JS Runtime For Java</a></p>\n</li>\n<li><p><a href=\"http://eclipsesource.com/blogs/2016/08/10/smile-deploying-a-mobile-app-has-never-been-so-easy/\" target=\"_blank\" rel=\"external\">Smile: Deploying a mobile app has never been so easy</a></p>\n</li>\n</ul>\n","excerpt":"<p>JavaScript引擎能够解析和执行JS脚本，帮助移动端进行跨平台开发。本文主要介绍和讨论JS引擎在Android系统上的使用和性能比较，并针对JS绘制本地化问题给出了基于V8的开发实例。","more":"</p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>近期在产品中遇到了这样的一个问题：Web端已经存在一个功能完善的JavaScript库，如果将相关Web嵌入到App中，则WebView将带来一定的性能影响；如果Android端本地开发一个相同的库，则需要消耗大量的资源。考虑到代码复用和跨平台开发，团队调研了JS引擎在Android上的使用，希望解决”不经过WebView，而将JS库拿到Android端运行，并将运行结果交给本地输出”这一需求。</p>\n<p>JS引擎能够解析JS脚本，通常被依附于浏览器中，例如Safari所使用的<strong>JavaScriptCore</strong>、Google Chrome所使用的<strong>V8</strong>和FireFox所使用的<strong>SpiderMonkey</strong>等等。也被用作移动端的跨平台开发，例如<a href=\"http://developer.telerik.com/featured/nativescript-works/\">NativeScript</a>在iOS端和Android分别使用了JavaScriptCore和V8，<a href=\"https://facebook.github.io/react-native/docs/javascript-environment.html\">ReactNative</a>则都使用了JavaScriptCore。</p>\n<h3 id=\"2-JS引擎介绍\"><a href=\"#2-JS引擎介绍\" class=\"headerlink\" title=\"2. JS引擎介绍\"></a>2. JS引擎介绍</h3><p>在Android系统中能运行的JS引擎有如下5种：</p>\n<h4 id=\"1-JavaScriptCore\"><a href=\"#1-JavaScriptCore\" class=\"headerlink\" title=\"1. JavaScriptCore\"></a>1. <a href=\"https://trac.webkit.org/wiki/JavaScriptCore\">JavaScriptCore</a></h4><p>JavaScriptCore是一个在WebKit中提供JS引擎的开源框架，最近更新日期是2016年9月26日。目前该引擎由Apple维护，使用于Safari浏览器，iOS7后也集成到了iPhone平台。</p>\n<p>由于其使用C语言编写，因此在Android开发中并不能直接使用。Github上的开源项目<a href=\"https://github.com/ericwlange/AndroidJSCore\">AndroidJSCore</a>能够帮助开发者经过调用Java接口而使用JavaScriptCore。该项目由<strong>ericwlange</strong>维护，最新版本3.0.1发布于2016年7月31日，有API文档和示例代码，但缺少相关技术文章，并仍存在一些性能问题。</p>\n<h4 id=\"2-V8\"><a href=\"#2-V8\" class=\"headerlink\" title=\"2. V8\"></a>2. <a href=\"https://developers.google.com/v8/\">V8</a></h4><p>V8是由Google开发并维护的高性能开源JS引擎，采用C++编写，使用于Google Chrome浏览器。最新版本为V8 5.5 beta，更新于2016年10月24日。</p>\n<p>同JavaScriptCore一样，在Android开发中，相关接口需要通过一层包装进行调用。Github上的开源项目<a href=\"https://github.com/eclipsesource/J2V8\">J2V8</a>，相关文章可在此处<a href=\"http://eclipsesource.com/blogs/tag/j2v8/\">http://eclipsesource.com/blogs/tag/j2v8/</a>查阅，最新版本4.6.0发布于2016年9月22日。</p>\n<p>J2V8是一套针对V8的Java绑定。J2V8的开发为Android平台带来了高效的Javascript的执行环境，其以性能与内存消耗为设计目标。它采用了“基本类型优先”原则，意味着一个执行结果是基本类型，那么所返回的值也就是该基本类型。它还采用了“懒加载”技术，只有当JS执行结果被访问时，才会通过JNI复制到Java中。</p>\n<p>此外J2V8提供了<code>release()</code>方法，开发者在某一对象不再需要时主动调用该方法去释放本地对象句柄，释放规则如下：</p>\n<ul>\n<li>如果是由代码创建的对象，那么必须释放它；如果一个对象是通过返回语句传回来的话，系统会替你释放它；</li>\n<li>如果是由系统创建的对象，则无需担心释放，而如果对象是JS方法的返回值，就必须手动的释放它。</li>\n</ul>\n<h4 id=\"3-SpiderMonkey\"><a href=\"#3-SpiderMonkey\" class=\"headerlink\" title=\"3. SpiderMonkey\"></a>3. <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey\">SpiderMonkey</a></h4><p>开源JS引擎SpiderMonkey最初由Netscape开发，如今由Mozilla开发并维护，且被广泛用于Mozilla产品（如FireFox）。最新版本为SpiderMonkey 45，更新于2016年4月14日。</p>\n<p>SpiderMonkey提供了一些核心的JavaScript数据类型，如数字，字符串，数组，对象等等，以及一些方法如Array.push。它还使得每个应用程序都容易将其自己的对象和方法暴露给JavaScript代码。应用开发者可以决定应用如何将与所写脚本相关的对象暴露出来。</p>\n<h4 id=\"4-Rhino\"><a href=\"#4-Rhino\" class=\"headerlink\" title=\"4. Rhino\"></a>4. <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino\">Rhino</a></h4><p>Rhino是由Mozilla开发的开源JS引擎。采用Java编写，因此可以直接调用，在JDK 6、JDK 7中更是捆绑了该引擎。最新版本为Rhino 1.7.7.1，更新于2016年2月1日。</p>\n<p>其提供的特性包括：</p>\n<ul>\n<li>JavaScript 1.7的全部特性</li>\n<li>可以用脚本方式调用Java</li>\n<li>用一个JavaScript Shell来执行JavaScript脚本</li>\n<li>用一个JavaScript编译器来将JavaScript脚本文件转换成Java类文件</li>\n<li>用一个JavaScript调试器来调试Rhino执行的脚本</li>\n</ul>\n<h4 id=\"5-Nashorn\"><a href=\"#5-Nashorn\" class=\"headerlink\" title=\"5. Nashorn\"></a>5. <a href=\"http://openjdk.java.net/projects/nashorn/\">Nashorn</a></h4><p>Nashorn由Oracle开发并维护，从JDK 8开始，Rhino被Nashorn代替，成为JDK默认JS引擎。Nashorn同JDK 8一同发布和开源，较Rhino而言性能更好，但不支持Android Dalvik虚拟机。</p>\n<h3 id=\"3-JS引擎性能比较\"><a href=\"#3-JS引擎性能比较\" class=\"headerlink\" title=\"3. JS引擎性能比较\"></a>3. JS引擎性能比较</h3><p>从可用性方面考虑，选取了JavaScriptCore+AndroidJSCore（下文由“JSCore”指代）、V8+J2V8（下文由“J2V8”指代）和Rhino三种方案进行实验。</p>\n<h4 id=\"3-1-创建JS环境\"><a href=\"#3-1-创建JS环境\" class=\"headerlink\" title=\"3.1 创建JS环境\"></a>3.1 创建JS环境</h4><p>部分引擎并不支持直接运行文件，因此将JS代码作为字符串交给JS引擎执行，执行过程中可以调用已注册到JS上下文的Java方法。</p>\n<h5 id=\"3-1-1-JSCore\"><a href=\"#3-1-1-JSCore\" class=\"headerlink\" title=\"3.1.1 JSCore\"></a>3.1.1 JSCore</h5><pre><code>//创建JS上下文\nJSContext context = new JSContext();\n//创建Java方法\nJSFunction func = new JSFunction(context, &quot;func&quot;) {\n    public void func(String msg) {\n        //相关处理\n    }\n};\n//将Java方法注册到JS上下文\ncontext.property(&quot;func&quot;, func);\n//执行JS\ncontext.evaluateScript(/*JS代码*/);\n</code></pre><h5 id=\"3-1-2-J2V8\"><a href=\"#3-1-2-J2V8\" class=\"headerlink\" title=\"3.1.2 J2V8\"></a>3.1.2 J2V8</h5><pre><code>//创建JS上下文\nV8 context = V8.createV8Runtime();\n//创建Java方法，并注册到JS上下文\ncontext.registerJavaMethod(new JavaVoidCallback() {\n    public void invoke(final V8Object receiver, final V8Array parameters) {\n        //相关处理\n    }\n}, &quot;func&quot;);\n//执行JS\ncontext.executeScript(js);\n//释放资源\ncontext.release();\n</code></pre><h5 id=\"3-1-3-Rhino\"><a href=\"#3-1-3-Rhino\" class=\"headerlink\" title=\"3.1.3 Rhino\"></a>3.1.3 Rhino</h5><pre><code>class Func {\n    void func(String msg) {\n        //相关处理\n    }\n}\n\n//创建JS上下文\nContext context = Context.enter();\ncontext.setOptimizationLevel(-1);\nScriptable scope = context.initStandardObjects();\ntry {\n    //执行JS\n    context.evaluateString(scope, js, &quot;RhinoUtil&quot;, 1, null);\n\n    //将Java方法封装到类中，并作为参数传递给JS方法\n    Function function = (Function) scope.get(&quot;rhinofunc&quot;, scope);\n    function.call(context, scope, scope, new Object[]{new Func()});\n} finally {\n    Context.exit();\n}\n</code></pre><h4 id=\"3-2-实验〇：包的依赖\"><a href=\"#3-2-实验〇：包的依赖\" class=\"headerlink\" title=\"3.2 实验〇：包的依赖\"></a>3.2 实验〇：包的依赖</h4><p>比较各方案依赖包引入后，apk的体积增量：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>依赖包占用(MB)</th>\n<th>依赖方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>8.2</td>\n<td>compile ‘com.eclipsesource.j2v8:j2v8:4.6.0@aar’</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>44.9😳</td>\n<td>compile ‘com.github.ericwlange:AndroidJSCore:3.0.1’</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>0.6</td>\n<td>将jar包放入libs文件夹下</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>J2V8引入的是全平台包，实际上它有针对Linux、Windows、MacOS、Android各平台进行打包，而Android平台最新版本为3.0.5（约4MB），并不是最新的4.6.0版本</li>\n<li>具AndroidJsCore作者回答，由于必须针对各CPU架构进行打包，而有7种CPU架构，每种架构包约6MB，因此整个依赖包体积相比之下显得庞大，但也可以通过ABIs Splits进行拆分。</li>\n<li>Rhino的jar包仅1.2M，因此apk增量并不显著。</li>\n</ul>\n<h4 id=\"3-3-实验一：空循环\"><a href=\"#3-3-实验一：空循环\" class=\"headerlink\" title=\"3.3 实验一：空循环\"></a>3.3 实验一：空循环</h4><p>JSCore和J2V8执行JS代码如下：</p>\n<pre><code>var i = 0;\nfor (;i &lt; /*次数*/; i++) {\n}\n</code></pre><p>Rhino执行JS代码如下：</p>\n<pre><code>function rhinofunc(f) {\n    var i = 0;\n    for (;i &lt; /*次数*/; i++) {\n    }\n}\n</code></pre><p>循环次数分别设置为100万、1000万、1亿次，在Java代码中执行JS前输出开始时间，在JS执行后输出结束时间，相减得出执行时间记录如下：</p>\n<table>\n<thead>\n<tr>\n<th>执行时间(ms)</th>\n<th>100万次</th>\n<th>1000万次</th>\n<th>1亿次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>17.6</td>\n<td>122.8</td>\n<td>1116.6</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>22</td>\n<td>173.2</td>\n<td>1551</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>2078.4</td>\n<td>22358.4</td>\n<td>198600😳</td>\n</tr>\n</tbody>\n</table>\n<p>由实验结果可以看到：J2V8和JSCore相比，J2V8执行时间更短，但两者时间都在同一数量级上。而Rhino执行时间远大于前两者，根本原因在于Java程序运行较C/C++慢。</p>\n<h4 id=\"3-4-实验二：JS调用Java方法\"><a href=\"#3-4-实验二：JS调用Java方法\" class=\"headerlink\" title=\"3.4 实验二：JS调用Java方法\"></a>3.4 实验二：JS调用Java方法</h4><p>JSCore和J2V8执行JS代码如下：</p>\n<pre><code>var i = 0;\nfor (;i &lt; /*次数*/; i++) {\n    func();\n}\n</code></pre><p>Rhino执行JS代码如下：</p>\n<pre><code>function rhinofunc(f) {\n    var i = 0;\n    for (;i &lt; /*次数*/; i++) {\n        f.func();\n    }\n}\n</code></pre><p>调用次数分别设置为1万、10万、100万次，记录执行时间如下：</p>\n<table>\n<thead>\n<tr>\n<th>执行时间(ms)</th>\n<th>1万次</th>\n<th>10万次</th>\n<th>100万次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>490.2</td>\n<td>4855.8</td>\n<td>47527</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>1287.6</td>\n<td>13448.2</td>\n<td>121586.8😳</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>408.2</td>\n<td>4007.2</td>\n<td>36752.4</td>\n</tr>\n</tbody>\n</table>\n<p>启动App时记录占用内存，JS执行过程中记录最高占用内存，相减得出占用内存。</p>\n<table>\n<thead>\n<tr>\n<th>占用内存(KB)</th>\n<th>1万次</th>\n<th>10万次</th>\n<th>100万次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>7264</td>\n<td>14004</td>\n<td>17328</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>15368</td>\n<td>15140</td>\n<td>16720</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>2776</td>\n<td>9084</td>\n<td>9116</td>\n</tr>\n</tbody>\n</table>\n<p>同样也是由于开发语言的差异，在JS调用Java上Rhino性能更优。执行时间方面，J2V8接近Rhino，而JSCore则远落后于前两种方案，这可能与其Java绑定层有很大关系。对于J2V8和JSCore则需要先经过JNI包装层才能调用到Java方法，而大量的JNI调用是非常耗时、耗内存的。</p>\n<h4 id=\"3-5-实验三：JS递归计算斐波那契\"><a href=\"#3-5-实验三：JS递归计算斐波那契\" class=\"headerlink\" title=\"3.5 实验三：JS递归计算斐波那契\"></a>3.5 实验三：JS递归计算斐波那契</h4><p>JS代码斐波那契函数如下：</p>\n<pre><code>function fibo(n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    else {\n        return fibo(n - 1) + fibo(n - 2);\n    }\n}\n</code></pre><table>\n<thead>\n<tr>\n<th>执行时间(ms)</th>\n<th>fibo(20)</th>\n<th>fibo(30)</th>\n<th>fibo(40)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>4</td>\n<td>67.6</td>\n<td>8158.6</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>6.6</td>\n<td>76.2</td>\n<td>7884.4</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>248.4</td>\n<td>26898</td>\n<td>???😳</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>占用内存(KB)</th>\n<th>fibo(20)</th>\n<th>fibo(30)</th>\n<th>fibo(40)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>J2V8</td>\n<td>6148</td>\n<td>6120</td>\n<td>17328</td>\n</tr>\n<tr>\n<td>JSCore</td>\n<td>6204</td>\n<td>6200</td>\n<td>16720</td>\n</tr>\n<tr>\n<td>Rhino</td>\n<td>5284</td>\n<td>9052</td>\n<td>9116</td>\n</tr>\n</tbody>\n</table>\n<p>Rhino运行JS时频繁GC，虽然使其所占内存较少，但执行速度非常缓慢，相比之下J2V8和JSCore方案效率更高。</p>\n<h4 id=\"3-6-实验总结\"><a href=\"#3-6-实验总结\" class=\"headerlink\" title=\"3.6 实验总结\"></a>3.6 实验总结</h4><p>单从JS引擎来说：Rhino执行不需要通过JNI且占用更少的内存，但执行效率很低；V8和JavaScriptCore等C语言开发的引擎远胜于Rhino等Java开发的引擎，但需要一层Java包装层，并存在JNI调用性能问题。就J2V8和AndroidJSCore两个包装层而言：J2V8的可用性、可靠性、健壮性更优；AndroidJSCore还存在着不少的性能问题，在上述实验中出现较少，但实际开发中还存在很多坑。</p>\n<p>以上三种实现方案中更推荐J2V8方案。对于内存问题，J2V8的内存释放机制较为完善，在实际开发中可以通过主动release来释放内存；对于JNI调用性能问题，J2V8团队也在尝试通过批处理回调来进行优化，在将来的版本中会得到改善。</p>\n<h3 id=\"4-J2V8的Android开发实例\"><a href=\"#4-J2V8的Android开发实例\" class=\"headerlink\" title=\"4. J2V8的Android开发实例\"></a>4. J2V8的Android开发实例</h3><p>有以下一段JS代码，其中Canvas绘制了一些简单的图形：</p>\n<pre><code>var c=document.getElementById(&quot;myCanvas&quot;);\nvar ctx=c.getContext(&quot;2d&quot;);\n\nctx.beginPath();\nctx.arc(100, 100, 25, 0, 360, false);\nctx.moveTo(20,20);\nctx.lineTo(20,100);\nctx.lineTo(70,100);\nctx.moveTo(100, 100);\nctx.setLineWidth(15);\nctx.setStrokeColor(&quot;#188ffc&quot;);\nctx.stroke();\n\nctx.setFillColor(&quot;#188ffc&quot;);\nctx.fillText(&quot;Hello World!&quot;,150,50);\n</code></pre><p>其在Web端绘制效果如下：</p>\n<p><img src=\"Android平台上的JavaScript引擎/web_shape.png\" alt=\"logo\"></p>\n<p>实例中，借助J2V8在Android端运行同样一段脚本，使图形绘制到Android Canvas中。下面给出简单实现，主要思路为自定义View，JS中将要绘制的图形先存储到在List中，待整个JS脚本执行完毕，再将所有图形在<code>View.onDraw(Canvas canvas)</code>中通过Android Canvas绘制。</p>\n<p>1) 将ctx封装为V8Object，并在其中对应实现JS Canvas的方法</p>\n<pre><code>public class JustContext {\n    protected V8 mRuntime;\n    protected V8Object mCtx;\n    private ArrayList&lt;AbstractDraw&gt; mShapeList = new ArrayList&lt;&gt;();\n\n    public JustContext(V8 v8Runtime) {\n        mRuntime = v8Runtime;\n        initCtx();\n    }\n\n    public V8Object getCtx() {\n        return mCtx;\n    }\n\n    public ArrayList&lt;AbstractDraw&gt; getShapeList() {\n        return mShapeList;\n    }\n\n    protected void initCtx() {\n        mCtx = new V8Object(mRuntime);\n\n        //将Java方法注册到该V8Object中\n        mCtx.registerJavaMethod(this, &quot;beginPath&quot;, &quot;beginPath&quot;, null);\n        mCtx.registerJavaMethod(this, &quot;closePath&quot;, &quot;closePath&quot;, null);\n\n        ...\n    }\n\n    public void clean() {\n        mCtx.release();\n    }\n\n    public void beginPath() {...}\n\n    public void closePath() {...}\n\n    ...\n}\n</code></pre><p>2) 自定义View，在View的<code>onDraw(Canvas canvas)</code>方法中将传入的图形List绘制出来</p>\n<pre><code>public class JustView extends View implements Serializable {\n    ...\n\n    private ArrayList&lt;AbstractDraw&gt; mShapeList = new ArrayList&lt;&gt;();\n\n    public void setShapeList(ArrayList&lt;AbstractDraw&gt; shapeList) {\n        this.mShapeList = shapeList;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        for (AbstractDraw abstractDraw : mShapeList) {\n            abstractDraw.draw(canvas);\n        }\n    }\n\n    ...\n}\n</code></pre><p>3) 将ctx注册到JS上下文，并执行JS代码，执行完毕后将绘制图形List传递给View</p>\n<pre><code>JustView mJustView;\n...\n\npublic void runJs(String js) {\n    V8 context = V8.createV8Runtime();\n    JustContext ctx = new JustContext(context);\n    context.add(&quot;ctx&quot;, ctx.getCtx());\n    context.executeScript(js);\n\n    //释放内存\n    ctx.clean();\n    context.release();\n\n    mJustView.setShapeList(ctx.getShapeList());\n}\n\n...\n</code></pre><p>4) 因为已将ctx注册到JS上下文，因此可以直接使用<code>ctx</code>变量，并运行如下JS代码</p>\n<pre><code>    ctx.beginPath();\n    ctx.arc(100, 100, 25, 0, 360, false);\n    ctx.moveTo(20,20);\n    ctx.lineTo(20,100);\n    ctx.lineTo(70,100);\n    ctx.moveTo(100, 100);\n    ctx.setLineWidth(15);\n    ctx.setStrokeColor(&quot;#188ffc&quot;);\n    ctx.stroke();        \n    ctx.setFillColor(&quot;#188ffc&quot;);\n    ctx.fillText(&quot;Hello World!&quot;,150,50);\n\n绘制结果如下：\n</code></pre><p><img src=\"Android平台上的JavaScript引擎/android_shape.png\" alt=\"android_shape\"></p>\n<p>以上仅是该实例的简单实现，详细的代码和设计可以根据需求的不同而进行细化，此处<a href=\"https://github.com/LiuHongtao/JustDraw\">https://github.com/LiuHongtao/JustDraw</a>提供一份具体实现的参考。由于每执行一个Canvas方法都将调用一次Java方法，该方案当绘制量过大的时候会出现JNI调用的性能问题，在性能方面也存在优化的空间，后续工作中将进行调用的优化，减少JNI调用次数。</p>\n<p>J2V8的团队开发的一套移动端跨平台框架<a href=\"https://tabrisjs.com/\">Tabris.js</a>，支持Android和iOS平台，又于近期宣布支持Windows 10。该框架旨在编写一份JavaScript代码，而能生成Android和iOS两个平台的本地应用。它在Android上使用了J2V8作为JS引擎方案，在iOS上使用系统自带的JSCore。</p>\n<p>不同于ReactNative、Weex之类的框架，它的亮点在于不通过WebView，但却能使用Web APIs，如Canvas 2d context（据了解，Weex也正在测试Canvas组件并即将开源）、XMLHttpRequest、localStorage。该框架通过批处理回调减少了JNI的调用，在一定程度上解决了JNI性能问题，例如其Canvas相关代码<code>tabris.CanvasContext</code>中，先将每次调用的Canvas方法和参数存储起来，并在适当的时候通过一次JNI调用来传递要执行的Canvas方法，相关代码如下：</p>\n<pre><code>defineMethod(&quot;fillText&quot;, 3, function(text, x, y /* , maxWidth */) {\n    this._strings.push(text);\n    this._booleans.push(false, false, false);\n    this._doubles.push(x, y);\n});\n\nfunction defineMethod(name, reqArgCount, fn) {\n    tabris.CanvasContext.prototype[name] = function() {\n        if (reqArgCount &amp;&amp; arguments.length &lt; reqArgCount) {\n            throw new Error(&quot;Not enough arguments to CanvasContext.&quot; + name);\n        }\n        this._pushOperation(name);\n        if (fn) {\n            fn.apply(this, arguments);\n        }\n    };\n}\n\n_pushOperation: function(operation) {\n    if (this._opCodes.indexOf(operation) &lt; 0) {\n        this._newOpCodes.push(operation);\n        this._opCodes.push(operation);\n    }\n    this._operations.push(this._opCodes.indexOf(operation));\n}\n\n_flush: function() {\n    if (this._operations.length &gt; 0) {\n        this._gc._nativeCall(&quot;draw&quot;, {packedOperations: [\n          this._newOpCodes,\n          this._operations,\n          this._doubles,\n          this._booleans,\n          this._strings,\n          this._ints]});\n        this._newOpCodes = [];\n      this._operations = [];\n      this._doubles = [];\n      this._booleans = [];\n      this._strings = [];\n      this._ints = [];\n    }\n}\n</code></pre><p>也就是说Tabris.js更完整的的实现了本节中的方案，这也使得“将Web端JS库直接拿到移动端执行，并由本地输出结果”变得更加容易。</p>\n<p>相关文章</p>\n<ul>\n<li><p><a href=\"https://www.skyscanner.net/blogs/developing-mobile-cross-platform-library-part-3-javascript\">Developing a mobile cross-platform library - Part 3. JavaScript</a></p>\n</li>\n<li><p><a href=\"http://openaphid.github.io/blog/2013/01/17/part-i-how-to-choose-a-javascript-engine-for-ios-and-android-apps/\">Part I: How to Choose a JavaScript Engine for iOS and Android Development</a></p>\n</li>\n<li><p><a href=\"http://eclipsesource.com/blogs/getting-started-with-j2v8/\">Getting Started With J2V8</a></p>\n</li>\n<li><p><a href=\"https://www.eclipsecon.org/na2015/sites/default/files/slides/J2V8_0.pdf\">J2V8-A Highly Efficient JS Runtime For Java</a></p>\n</li>\n<li><p><a href=\"http://eclipsesource.com/blogs/2016/08/10/smile-deploying-a-mobile-app-has-never-been-so-easy/\">Smile: Deploying a mobile app has never been so easy</a></p>\n</li>\n</ul>"},{"title":"NeteaseAPM iOS SDK技术实现","date":"2016-12-15T16:00:00.000Z","author":"朱志强","_content":"一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。<!-- more -->  \n\n## 一. <span id=\"一\">NeteaseAPM 是什么</span>\n\nApplication Performance Management(APM)，应用程序性能管理，主要指对企业的关键业务应用进行监测、优化，提高企业应用的可靠性和质量，保证用户得到良好的服务。一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。<!-- more -->  \n\nNetsaseAPM 移动端支持的功能：\n\n1. 应用性能分析  \n对当前应用请求的各项性能指标进行分析，如响应时间，吞吐量，下载速率等，帮助用户全面了解应用性能表现。\n2. 错误分析  \n分析应用每个域名的网络错误率及响应码错误率，快速定位应用问题。\n3. 多维分析  \n可以组合域名，地理位置，运营商，网络环境等参数，精确定位应用的性能问题。\n\n下面是从移动端收集的数据在 NeteaseAPM Web 平台的展示\n\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequestSearch.png\" width=\"800\" height=\"160\"/>\n</div>\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequest.png\" width=\"800\" height=\"300\"/>\n</div>\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMUITrace.png\" width=\"800\" height=\"360\"/>\n</div>\n\n\n## 二. <span id=\"二\">NeteaseAPM iOS SDK 的目标</span>\n\n1.\t最小侵入：  \n只需要启动一次，就可以持续收集网络和交互数据，不需要手动收集数据。  \n启动方式：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMUseSample.png\" width=\"800\" height=\"116\"/>\n</div>\n启动之后，NeteaseAPM 会插入收集数据的代码到系统调用中，却不会影响用户的使用，在用户的网络消息中的位置如图：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMStruct.png\" width=\"300\" height=\"287\"/>\n</div>\n2.\t最大化自由配置：  \n\t*\t用户可以看到收集到的数据，选择是否上传到 NeteaseAPM 服务器；  \n\t*\t用户可以自己上传数据到 NeteaseAPM 服务器；  \n3. 功能特点：  \n支持对底层网络库 CFNetwork 的监控；\n\n## 三 <span id=\"三\">现状</span>\n\n目前实现的功能： \n \n*\t网络请求的响应时间，下载速率，状态码，错误码，网络状态等数据的收集；\n*\t页面加载时间的收集，检查出慢交互页面；\n\n已经接入的应用： 网易新闻，网易云音乐，考拉。\n\n## 四 <span id=\"四\">整体设计</span>\n\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMStructDesign.png\" width=\"400\" height=\"272\"/>\n</div>\n\nNeteaseAPM iOS SDK分为四个部分：  \n\n+ Hooker：  \nHooker 负责在用户无感知的情况下替换程序原实现，转发消息回调，完成对系统消息的 hook 和数据的采集。  \nHooker 能否监控到更多更准确的数据，是衡量一个 APM 产品是否优秀的最重要的标准。  \n一个 APM 产品监控的数据面越广，收集的数据越细，就越能准确地取得用户的性能数据，帮助产品优化性能。\n\n+ DataBuilder：     \n收集监控数据；\n+ Persistence：  \n缓存监控数据；\n+ Poster：         \n上传监控数据到NeteaseAPM；  \n\n线程模型： 监控数据的保存和发送都在后台队列中执行，不会影响用户线程。  \n\n数据上传规则：  \n\n*\t可设置允许数据上传的网络环境；\n*\t数据支持批量发送，可自定义发送批量和等待间隔；\n\n===================================================================\n\n## 五. <span id=\"五\">一些关键实现</span>\n\nAPM SDK 使用方式和一般的UI库有很大不同，APM 只需要启动一次即可生效，不需要修改代码。例如：启动APM之后，用户使用 NSURLConnection 执行的网络请求就会在开始连接，得到响应，获取数据等时机被 APM 监控到，而不需要使用者手动添加任何监控代码。要实现这样的目标，Hooker 需要使用一些比较特殊的的方式来实现，下面介绍Hooker使用到的解决方案：\n\n### 1.\t<span id=\"五1\">开始使用面向切面编程</span> \n \nAPM需要将监控代码插入到系统实现中，完成系统消息的拦截和数据收集。比如我们需要知道 NSURLConnection 在什么时候开始发送请求，就会监控 `-[NSURLConnection start]` 方法，这就需要在这个方法中插入APM的逻辑，要做到这一点，需要理解面向切面编程的思想。\n\nAspect Oriented Programming(AOP)，面向切面编程，面对的是处理过程中的某个步骤或阶段。在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。借助 AOP，甚至不用修改一行代码，就可以修改现有程序的行为，非常高效。\n\nAOP 基本原理：将一个函数替换为一个新函数，新的函数中插入代码片段，然后执行原函数。\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMAOPTheory.png\" width=\"400\" height=\"277\"/>\n</div>\n下面分别介绍 Objective-C 和 C 这两种语言支持 AOP 的方式。  \n\nObjective-C 对 AOP 的支持非常容易：  \n一个 Objective-C 的方法调用 `[self setFilled:YES]` 在运行时和下方的代码等效\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/Objective-CAOP.png\" width=\"580\" height=\"97\"/>\n</div>\n系统会通过 **SEL** 查找对应的函数指针 **IMP**，所以通过修改SEL对应的IMP，可以方便地hook原方法。  \nObjective-C 借助这个原理实现的 AOP 有一个形象的名字：\n[Method Swizzling](http://blog.csdn.net/yiyaaixuexi/article/details/9374411) 醉了的方法 ~~！  \n\nC 的 AOP 使用了 `dyld`(dynamic link editor)，在系统加载可执行文件时修改了符号的地址，简单了解一下：  \nC函数指针的地址可以通过`dlsym`函数取得，如：\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMDlsymClose.png\" width=\"600\" height=\"50\"/>\n</div>\n我们需要查找到这个函数指针的地址，查找过程见下图：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMFindSymbolIMPLocation.png\" width=\"600\" height=\"460\"/>\n</div>\n[fishhook](https://github.com/facebook/fishhook)可以方便地查找替换C函数的指针。\n\n### 2.\t<span id=\"五2\">使用代理模式拦截回调消息</span>  \n通过 AOP ，可以监控指定类的指定方法了，我们可以取得方法调用的时机了，但是程序中除了方法调用还存在方法回调，这是一种不适合用AOP监控的情况。例如，NSURLConnection 的 `start` 方法可以通过 Method Swizzling 监控，\n但是回调消息的接收者 `delegate` 的类名不固定，可能是任意一个页面实例，不适合需要指定 Class 的 Method Swizzling。  \n\n解决方法是构造一个回调消息的转发者，作为代理，在转发者中收集数据，再转发给用户。下图演示对 NSURLConnection 的监控，MAM IMP 是 `start` 方法被替换后的实现，ProxyDelegate 就是消息转发者，负责将回调消息转发给 `delegate` 对象：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMURLConnectionHook.png\" width=\"600\" height=\"347\"/>\n</div>  \n\n`NSProxy` 是 `Objective-C` 中除了 `NSObject` 之外的另一个基类，由于它实现的方法非常少，可以方便地借助消息转发机制转发未实现的消息。\n\nProxyDelegate 的转发使用系统的消息转发机制：\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/ProxyDelegateInvocation.png\" width=\"647\" height=\"180\"/>\n</div>  \n\nCFNetwork 的监控也使用了代理模式，获取 stream 读取的数据长度：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookConnectionFlow.png\" width=\"600\" height=\"429\"/>\n</div>\n\n\n### 3.\t<span id=\"五3\">桥接模式，从面向过程到面向对象</span>\n\nCFNetwork 是一个 C 语言实现的网络系统框架，虽然使用起来比较麻烦，但是可配置的功能更多。但由于面向过程编程难以扩展的缺点，没有办法选择性地监控和 http 有关的 `CFReadStreamRef` ，而不影响到来自文件或内存的 `CFReadStreamRef`。\n\n所幸 Objective-C 支持从面向过程到面向对象的桥接：[**Toll-Free Bridging**](http://blog.csdn.net/nlforever/article/details/12908115)，允许某些 CoreFoundation类与对应的Objective-C 类互相转换，使我们可以在面向过程编程和面向对象编程两种编程思想中自由切换。\n\nNeteaseAPM 的策略：在系统构造 http stream 时，将一个 `NSInputStream` 的子类 ProxyStream 桥接为 `CFReadStreamRef `，返回给用户，达到单独监控 http stream 的效果。\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookCreate.png\" width=\"360\" height=\"178\"/>\n</div>\n\n使用 Toll-Free Bridging 时需要重点关注两种不同的内存管理机制的问题。例如 `-[NSInputStream propertyForKey]` 方法和 `CFReadStreamCopyProperty` 函数是桥接的，但是它们内存管理方法不同，前者是自动管理，后者是手动管理，后者在调用之后需要使用者在随后手动调用 `CFRelease`。\n\n以 ProxyStream 举例，ProxyStream 是 `CFReadStreamRef` 的代理，负责管理 http stream 的数据收集。如果用户对一个 http stream 执行如下调用：\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMCopyProperty.png\" width=\"563\" height=\"54\"/>\n</div>\nProxyStream的`propertyForKey:`方法会因为桥接而被调用，ProxyStream需要从original stream中获取正确的property，如果ProxyStream中这么写\n\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMErrorPropertyForKey.png\" width=\"300\" height=\"72\"/>\n</div>\n\n那么这个方法返回的结果会被`CFReadStreamCopyProperty`随后的`CFRelease`函数错误地释放，引起内存异常。\n\n正确的书写方式应该是\n\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMRightPropertyForKey.png\" width=\"600\" height=\"75\"/>\n</div>\n\nProxyStream 只需要”转发” `CFReadStreamCopyProperty` 函数给 original stream 就可以了。\n\n### 4. <span id=\"五4\">使用 NSURLProtocol 监控 UIWebView</span>\n\n`NSURLProtocol` 是监控 `UIWebView` 请求最普遍的解决方案。这里用户会产生多个 `NSURLProtocol` 会不会冲突的疑问？其实是不会的，因为即使用户注册了 `NSURLProtocol` ，拦截了 NeteaseAPM 的 `NSURLProtocol` 的请求，但用户的 `NSURLProtocol ` 在发送请求时使用的的 `NSURLConnection` 或者 `NSURLSession` 还是会被 NeteaseAPM 监控到的。\n\n===================================================================\n\n## 六. <span id=\"六\">后续工作</span>\n\n*\t支持更多性能数据的收集，如内存，CPU，帧率等；\n*\t支持自动诊断性能问题，如卡顿，Out of Memory 等；\n\n## 七. 引用链接\n\n[Objective-C的hook方案: Method Swizzling](http://blog.csdn.net/yiyaaixuexi/article/details/9374411)  \n[使用NSProxy和NSObject设计代理类的差异](http://www.tanhao.me/code/160702.html/)  \n[fishhook](https://github.com/facebook/fishhook)  \n[Toll-free bridging介绍](http://blog.csdn.net/nlforever/article/details/12908115)\n\n\n","source":"_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现.md","raw":"---\ntitle: NeteaseAPM iOS SDK技术实现\n\ndate: 2016-12-16\n\ncategory: ios\n\nauthor: 朱志强\n\ntags: \n- NeteaseAPM\n\n---\n一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。<!-- more -->  \n\n## 一. <span id=\"一\">NeteaseAPM 是什么</span>\n\nApplication Performance Management(APM)，应用程序性能管理，主要指对企业的关键业务应用进行监测、优化，提高企业应用的可靠性和质量，保证用户得到良好的服务。一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。<!-- more -->  \n\nNetsaseAPM 移动端支持的功能：\n\n1. 应用性能分析  \n对当前应用请求的各项性能指标进行分析，如响应时间，吞吐量，下载速率等，帮助用户全面了解应用性能表现。\n2. 错误分析  \n分析应用每个域名的网络错误率及响应码错误率，快速定位应用问题。\n3. 多维分析  \n可以组合域名，地理位置，运营商，网络环境等参数，精确定位应用的性能问题。\n\n下面是从移动端收集的数据在 NeteaseAPM Web 平台的展示\n\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequestSearch.png\" width=\"800\" height=\"160\"/>\n</div>\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequest.png\" width=\"800\" height=\"300\"/>\n</div>\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMUITrace.png\" width=\"800\" height=\"360\"/>\n</div>\n\n\n## 二. <span id=\"二\">NeteaseAPM iOS SDK 的目标</span>\n\n1.\t最小侵入：  \n只需要启动一次，就可以持续收集网络和交互数据，不需要手动收集数据。  \n启动方式：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMUseSample.png\" width=\"800\" height=\"116\"/>\n</div>\n启动之后，NeteaseAPM 会插入收集数据的代码到系统调用中，却不会影响用户的使用，在用户的网络消息中的位置如图：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMStruct.png\" width=\"300\" height=\"287\"/>\n</div>\n2.\t最大化自由配置：  \n\t*\t用户可以看到收集到的数据，选择是否上传到 NeteaseAPM 服务器；  \n\t*\t用户可以自己上传数据到 NeteaseAPM 服务器；  \n3. 功能特点：  \n支持对底层网络库 CFNetwork 的监控；\n\n## 三 <span id=\"三\">现状</span>\n\n目前实现的功能： \n \n*\t网络请求的响应时间，下载速率，状态码，错误码，网络状态等数据的收集；\n*\t页面加载时间的收集，检查出慢交互页面；\n\n已经接入的应用： 网易新闻，网易云音乐，考拉。\n\n## 四 <span id=\"四\">整体设计</span>\n\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMStructDesign.png\" width=\"400\" height=\"272\"/>\n</div>\n\nNeteaseAPM iOS SDK分为四个部分：  \n\n+ Hooker：  \nHooker 负责在用户无感知的情况下替换程序原实现，转发消息回调，完成对系统消息的 hook 和数据的采集。  \nHooker 能否监控到更多更准确的数据，是衡量一个 APM 产品是否优秀的最重要的标准。  \n一个 APM 产品监控的数据面越广，收集的数据越细，就越能准确地取得用户的性能数据，帮助产品优化性能。\n\n+ DataBuilder：     \n收集监控数据；\n+ Persistence：  \n缓存监控数据；\n+ Poster：         \n上传监控数据到NeteaseAPM；  \n\n线程模型： 监控数据的保存和发送都在后台队列中执行，不会影响用户线程。  \n\n数据上传规则：  \n\n*\t可设置允许数据上传的网络环境；\n*\t数据支持批量发送，可自定义发送批量和等待间隔；\n\n===================================================================\n\n## 五. <span id=\"五\">一些关键实现</span>\n\nAPM SDK 使用方式和一般的UI库有很大不同，APM 只需要启动一次即可生效，不需要修改代码。例如：启动APM之后，用户使用 NSURLConnection 执行的网络请求就会在开始连接，得到响应，获取数据等时机被 APM 监控到，而不需要使用者手动添加任何监控代码。要实现这样的目标，Hooker 需要使用一些比较特殊的的方式来实现，下面介绍Hooker使用到的解决方案：\n\n### 1.\t<span id=\"五1\">开始使用面向切面编程</span> \n \nAPM需要将监控代码插入到系统实现中，完成系统消息的拦截和数据收集。比如我们需要知道 NSURLConnection 在什么时候开始发送请求，就会监控 `-[NSURLConnection start]` 方法，这就需要在这个方法中插入APM的逻辑，要做到这一点，需要理解面向切面编程的思想。\n\nAspect Oriented Programming(AOP)，面向切面编程，面对的是处理过程中的某个步骤或阶段。在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。借助 AOP，甚至不用修改一行代码，就可以修改现有程序的行为，非常高效。\n\nAOP 基本原理：将一个函数替换为一个新函数，新的函数中插入代码片段，然后执行原函数。\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMAOPTheory.png\" width=\"400\" height=\"277\"/>\n</div>\n下面分别介绍 Objective-C 和 C 这两种语言支持 AOP 的方式。  \n\nObjective-C 对 AOP 的支持非常容易：  \n一个 Objective-C 的方法调用 `[self setFilled:YES]` 在运行时和下方的代码等效\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/Objective-CAOP.png\" width=\"580\" height=\"97\"/>\n</div>\n系统会通过 **SEL** 查找对应的函数指针 **IMP**，所以通过修改SEL对应的IMP，可以方便地hook原方法。  \nObjective-C 借助这个原理实现的 AOP 有一个形象的名字：\n[Method Swizzling](http://blog.csdn.net/yiyaaixuexi/article/details/9374411) 醉了的方法 ~~！  \n\nC 的 AOP 使用了 `dyld`(dynamic link editor)，在系统加载可执行文件时修改了符号的地址，简单了解一下：  \nC函数指针的地址可以通过`dlsym`函数取得，如：\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMDlsymClose.png\" width=\"600\" height=\"50\"/>\n</div>\n我们需要查找到这个函数指针的地址，查找过程见下图：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMFindSymbolIMPLocation.png\" width=\"600\" height=\"460\"/>\n</div>\n[fishhook](https://github.com/facebook/fishhook)可以方便地查找替换C函数的指针。\n\n### 2.\t<span id=\"五2\">使用代理模式拦截回调消息</span>  \n通过 AOP ，可以监控指定类的指定方法了，我们可以取得方法调用的时机了，但是程序中除了方法调用还存在方法回调，这是一种不适合用AOP监控的情况。例如，NSURLConnection 的 `start` 方法可以通过 Method Swizzling 监控，\n但是回调消息的接收者 `delegate` 的类名不固定，可能是任意一个页面实例，不适合需要指定 Class 的 Method Swizzling。  \n\n解决方法是构造一个回调消息的转发者，作为代理，在转发者中收集数据，再转发给用户。下图演示对 NSURLConnection 的监控，MAM IMP 是 `start` 方法被替换后的实现，ProxyDelegate 就是消息转发者，负责将回调消息转发给 `delegate` 对象：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMURLConnectionHook.png\" width=\"600\" height=\"347\"/>\n</div>  \n\n`NSProxy` 是 `Objective-C` 中除了 `NSObject` 之外的另一个基类，由于它实现的方法非常少，可以方便地借助消息转发机制转发未实现的消息。\n\nProxyDelegate 的转发使用系统的消息转发机制：\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/ProxyDelegateInvocation.png\" width=\"647\" height=\"180\"/>\n</div>  \n\nCFNetwork 的监控也使用了代理模式，获取 stream 读取的数据长度：\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookConnectionFlow.png\" width=\"600\" height=\"429\"/>\n</div>\n\n\n### 3.\t<span id=\"五3\">桥接模式，从面向过程到面向对象</span>\n\nCFNetwork 是一个 C 语言实现的网络系统框架，虽然使用起来比较麻烦，但是可配置的功能更多。但由于面向过程编程难以扩展的缺点，没有办法选择性地监控和 http 有关的 `CFReadStreamRef` ，而不影响到来自文件或内存的 `CFReadStreamRef`。\n\n所幸 Objective-C 支持从面向过程到面向对象的桥接：[**Toll-Free Bridging**](http://blog.csdn.net/nlforever/article/details/12908115)，允许某些 CoreFoundation类与对应的Objective-C 类互相转换，使我们可以在面向过程编程和面向对象编程两种编程思想中自由切换。\n\nNeteaseAPM 的策略：在系统构造 http stream 时，将一个 `NSInputStream` 的子类 ProxyStream 桥接为 `CFReadStreamRef `，返回给用户，达到单独监控 http stream 的效果。\n<div align=center>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookCreate.png\" width=\"360\" height=\"178\"/>\n</div>\n\n使用 Toll-Free Bridging 时需要重点关注两种不同的内存管理机制的问题。例如 `-[NSInputStream propertyForKey]` 方法和 `CFReadStreamCopyProperty` 函数是桥接的，但是它们内存管理方法不同，前者是自动管理，后者是手动管理，后者在调用之后需要使用者在随后手动调用 `CFRelease`。\n\n以 ProxyStream 举例，ProxyStream 是 `CFReadStreamRef` 的代理，负责管理 http stream 的数据收集。如果用户对一个 http stream 执行如下调用：\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMCopyProperty.png\" width=\"563\" height=\"54\"/>\n</div>\nProxyStream的`propertyForKey:`方法会因为桥接而被调用，ProxyStream需要从original stream中获取正确的property，如果ProxyStream中这么写\n\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMErrorPropertyForKey.png\" width=\"300\" height=\"72\"/>\n</div>\n\n那么这个方法返回的结果会被`CFReadStreamCopyProperty`随后的`CFRelease`函数错误地释放，引起内存异常。\n\n正确的书写方式应该是\n\n<div align=left>\n<img src=\"NeteaseAPM iOS SDK技术实现/NAPMRightPropertyForKey.png\" width=\"600\" height=\"75\"/>\n</div>\n\nProxyStream 只需要”转发” `CFReadStreamCopyProperty` 函数给 original stream 就可以了。\n\n### 4. <span id=\"五4\">使用 NSURLProtocol 监控 UIWebView</span>\n\n`NSURLProtocol` 是监控 `UIWebView` 请求最普遍的解决方案。这里用户会产生多个 `NSURLProtocol` 会不会冲突的疑问？其实是不会的，因为即使用户注册了 `NSURLProtocol` ，拦截了 NeteaseAPM 的 `NSURLProtocol` 的请求，但用户的 `NSURLProtocol ` 在发送请求时使用的的 `NSURLConnection` 或者 `NSURLSession` 还是会被 NeteaseAPM 监控到的。\n\n===================================================================\n\n## 六. <span id=\"六\">后续工作</span>\n\n*\t支持更多性能数据的收集，如内存，CPU，帧率等；\n*\t支持自动诊断性能问题，如卡顿，Out of Memory 等；\n\n## 七. 引用链接\n\n[Objective-C的hook方案: Method Swizzling](http://blog.csdn.net/yiyaaixuexi/article/details/9374411)  \n[使用NSProxy和NSObject设计代理类的差异](http://www.tanhao.me/code/160702.html/)  \n[fishhook](https://github.com/facebook/fishhook)  \n[Toll-free bridging介绍](http://blog.csdn.net/nlforever/article/details/12908115)\n\n\n","slug":"ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现","published":1,"updated":"2016-12-30T11:31:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixk0c24p000i7ekk8k6xy4sf","content":"<p>一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。<a id=\"more\"></a>  </p>\n<h2 id=\"一-NeteaseAPM-是什么\"><a href=\"#一-NeteaseAPM-是什么\" class=\"headerlink\" title=\"一. NeteaseAPM 是什么\"></a>一. <span id=\"一\">NeteaseAPM 是什么</span></h2><p>Application Performance Management(APM)，应用程序性能管理，主要指对企业的关键业务应用进行监测、优化，提高企业应用的可靠性和质量，保证用户得到良好的服务。一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。<!-- more -->  </p>\n<p>NetsaseAPM 移动端支持的功能：</p>\n<ol>\n<li>应用性能分析<br>对当前应用请求的各项性能指标进行分析，如响应时间，吞吐量，下载速率等，帮助用户全面了解应用性能表现。</li>\n<li>错误分析<br>分析应用每个域名的网络错误率及响应码错误率，快速定位应用问题。</li>\n<li>多维分析<br>可以组合域名，地理位置，运营商，网络环境等参数，精确定位应用的性能问题。</li>\n</ol>\n<p>下面是从移动端收集的数据在 NeteaseAPM Web 平台的展示</p>\n<div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequestSearch.png\" width=\"800\" height=\"160\"><br></div><br><div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequest.png\" width=\"800\" height=\"300\"><br></div><br><div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMUITrace.png\" width=\"800\" height=\"360\"><br></div>\n\n\n<h2 id=\"二-NeteaseAPM-iOS-SDK-的目标\"><a href=\"#二-NeteaseAPM-iOS-SDK-的目标\" class=\"headerlink\" title=\"二. NeteaseAPM iOS SDK 的目标\"></a>二. <span id=\"二\">NeteaseAPM iOS SDK 的目标</span></h2><ol>\n<li>最小侵入：<br>只需要启动一次，就可以持续收集网络和交互数据，不需要手动收集数据。<br>启动方式：<div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMUseSample.png\" width=\"800\" height=\"116\"><br></div><br>启动之后，NeteaseAPM 会插入收集数据的代码到系统调用中，却不会影响用户的使用，在用户的网络消息中的位置如图：<br><div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMStruct.png\" width=\"300\" height=\"287\"><br></div></li>\n<li>最大化自由配置：  <ul>\n<li>用户可以看到收集到的数据，选择是否上传到 NeteaseAPM 服务器；  </li>\n<li>用户可以自己上传数据到 NeteaseAPM 服务器；  </li>\n</ul>\n</li>\n<li>功能特点：<br>支持对底层网络库 CFNetwork 的监控；</li>\n</ol>\n<h2 id=\"三-现状\"><a href=\"#三-现状\" class=\"headerlink\" title=\"三 现状\"></a>三 <span id=\"三\">现状</span></h2><p>目前实现的功能： </p>\n<ul>\n<li>网络请求的响应时间，下载速率，状态码，错误码，网络状态等数据的收集；</li>\n<li>页面加载时间的收集，检查出慢交互页面；</li>\n</ul>\n<p>已经接入的应用： 网易新闻，网易云音乐，考拉。</p>\n<h2 id=\"四-整体设计\"><a href=\"#四-整体设计\" class=\"headerlink\" title=\"四 整体设计\"></a>四 <span id=\"四\">整体设计</span></h2><div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMStructDesign.png\" width=\"400\" height=\"272\"><br></div>\n\n<p>NeteaseAPM iOS SDK分为四个部分：  </p>\n<ul>\n<li><p>Hooker：<br>Hooker 负责在用户无感知的情况下替换程序原实现，转发消息回调，完成对系统消息的 hook 和数据的采集。<br>Hooker 能否监控到更多更准确的数据，是衡量一个 APM 产品是否优秀的最重要的标准。<br>一个 APM 产品监控的数据面越广，收集的数据越细，就越能准确地取得用户的性能数据，帮助产品优化性能。</p>\n</li>\n<li><p>DataBuilder：<br>收集监控数据；</p>\n</li>\n<li>Persistence：<br>缓存监控数据；</li>\n<li>Poster：<br>上传监控数据到NeteaseAPM；  </li>\n</ul>\n<p>线程模型： 监控数据的保存和发送都在后台队列中执行，不会影响用户线程。  </p>\n<p>数据上传规则：  </p>\n<ul>\n<li>可设置允许数据上传的网络环境；</li>\n<li>数据支持批量发送，可自定义发送批量和等待间隔；</li>\n</ul>\n<p>===================================================================</p>\n<h2 id=\"五-一些关键实现\"><a href=\"#五-一些关键实现\" class=\"headerlink\" title=\"五. 一些关键实现\"></a>五. <span id=\"五\">一些关键实现</span></h2><p>APM SDK 使用方式和一般的UI库有很大不同，APM 只需要启动一次即可生效，不需要修改代码。例如：启动APM之后，用户使用 NSURLConnection 执行的网络请求就会在开始连接，得到响应，获取数据等时机被 APM 监控到，而不需要使用者手动添加任何监控代码。要实现这样的目标，Hooker 需要使用一些比较特殊的的方式来实现，下面介绍Hooker使用到的解决方案：</p>\n<h3 id=\"1-开始使用面向切面编程\"><a href=\"#1-开始使用面向切面编程\" class=\"headerlink\" title=\"1.    开始使用面向切面编程\"></a>1.    <span id=\"五1\">开始使用面向切面编程</span></h3><p>APM需要将监控代码插入到系统实现中，完成系统消息的拦截和数据收集。比如我们需要知道 NSURLConnection 在什么时候开始发送请求，就会监控 <code>-[NSURLConnection start]</code> 方法，这就需要在这个方法中插入APM的逻辑，要做到这一点，需要理解面向切面编程的思想。</p>\n<p>Aspect Oriented Programming(AOP)，面向切面编程，面对的是处理过程中的某个步骤或阶段。在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。借助 AOP，甚至不用修改一行代码，就可以修改现有程序的行为，非常高效。</p>\n<p>AOP 基本原理：将一个函数替换为一个新函数，新的函数中插入代码片段，然后执行原函数。</p>\n<div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMAOPTheory.png\" width=\"400\" height=\"277\"><br></div><br>下面分别介绍 Objective-C 和 C 这两种语言支持 AOP 的方式。<br><br>Objective-C 对 AOP 的支持非常容易：<br>一个 Objective-C 的方法调用 <code>[self setFilled:YES]</code> 在运行时和下方的代码等效<br><div align=\"left\"><br><img src=\"NeteaseAPM iOS SDK技术实现/Objective-CAOP.png\" width=\"580\" height=\"97\"><br></div><br>系统会通过 <strong>SEL</strong> 查找对应的函数指针 <strong>IMP</strong>，所以通过修改SEL对应的IMP，可以方便地hook原方法。<br>Objective-C 借助这个原理实现的 AOP 有一个形象的名字：<br><a href=\"http://blog.csdn.net/yiyaaixuexi/article/details/9374411\" target=\"_blank\" rel=\"external\">Method Swizzling</a> 醉了的方法 ~~！<br><br>C 的 AOP 使用了 <code>dyld</code>(dynamic link editor)，在系统加载可执行文件时修改了符号的地址，简单了解一下：<br>C函数指针的地址可以通过<code>dlsym</code>函数取得，如：<br><div align=\"left\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMDlsymClose.png\" width=\"600\" height=\"50\"><br></div><br>我们需要查找到这个函数指针的地址，查找过程见下图：<br><div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMFindSymbolIMPLocation.png\" width=\"600\" height=\"460\"><br></div><br><a href=\"https://github.com/facebook/fishhook\" target=\"_blank\" rel=\"external\">fishhook</a>可以方便地查找替换C函数的指针。<br><br>### 2.    <span id=\"五2\">使用代理模式拦截回调消息</span><br>通过 AOP ，可以监控指定类的指定方法了，我们可以取得方法调用的时机了，但是程序中除了方法调用还存在方法回调，这是一种不适合用AOP监控的情况。例如，NSURLConnection 的 <code>start</code> 方法可以通过 Method Swizzling 监控，<br>但是回调消息的接收者 <code>delegate</code> 的类名不固定，可能是任意一个页面实例，不适合需要指定 Class 的 Method Swizzling。<br><br>解决方法是构造一个回调消息的转发者，作为代理，在转发者中收集数据，再转发给用户。下图演示对 NSURLConnection 的监控，MAM IMP 是 <code>start</code> 方法被替换后的实现，ProxyDelegate 就是消息转发者，负责将回调消息转发给 <code>delegate</code> 对象：<br><div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMURLConnectionHook.png\" width=\"600\" height=\"347\"><br></div>  \n\n<p><code>NSProxy</code> 是 <code>Objective-C</code> 中除了 <code>NSObject</code> 之外的另一个基类，由于它实现的方法非常少，可以方便地借助消息转发机制转发未实现的消息。</p>\n<p>ProxyDelegate 的转发使用系统的消息转发机制：</p>\n<div align=\"left\"><br><img src=\"NeteaseAPM iOS SDK技术实现/ProxyDelegateInvocation.png\" width=\"647\" height=\"180\"><br></div>  \n\n<p>CFNetwork 的监控也使用了代理模式，获取 stream 读取的数据长度：</p>\n<div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookConnectionFlow.png\" width=\"600\" height=\"429\"><br></div>\n\n\n<h3 id=\"3-桥接模式，从面向过程到面向对象\"><a href=\"#3-桥接模式，从面向过程到面向对象\" class=\"headerlink\" title=\"3.    桥接模式，从面向过程到面向对象\"></a>3.    <span id=\"五3\">桥接模式，从面向过程到面向对象</span></h3><p>CFNetwork 是一个 C 语言实现的网络系统框架，虽然使用起来比较麻烦，但是可配置的功能更多。但由于面向过程编程难以扩展的缺点，没有办法选择性地监控和 http 有关的 <code>CFReadStreamRef</code> ，而不影响到来自文件或内存的 <code>CFReadStreamRef</code>。</p>\n<p>所幸 Objective-C 支持从面向过程到面向对象的桥接：<a href=\"http://blog.csdn.net/nlforever/article/details/12908115\" target=\"_blank\" rel=\"external\"><strong>Toll-Free Bridging</strong></a>，允许某些 CoreFoundation类与对应的Objective-C 类互相转换，使我们可以在面向过程编程和面向对象编程两种编程思想中自由切换。</p>\n<p>NeteaseAPM 的策略：在系统构造 http stream 时，将一个 <code>NSInputStream</code> 的子类 ProxyStream 桥接为 <code>CFReadStreamRef</code>，返回给用户，达到单独监控 http stream 的效果。</p>\n<div align=\"center\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookCreate.png\" width=\"360\" height=\"178\"><br></div>\n\n<p>使用 Toll-Free Bridging 时需要重点关注两种不同的内存管理机制的问题。例如 <code>-[NSInputStream propertyForKey]</code> 方法和 <code>CFReadStreamCopyProperty</code> 函数是桥接的，但是它们内存管理方法不同，前者是自动管理，后者是手动管理，后者在调用之后需要使用者在随后手动调用 <code>CFRelease</code>。</p>\n<p>以 ProxyStream 举例，ProxyStream 是 <code>CFReadStreamRef</code> 的代理，负责管理 http stream 的数据收集。如果用户对一个 http stream 执行如下调用：</p>\n<div align=\"left\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMCopyProperty.png\" width=\"563\" height=\"54\"><br></div><br>ProxyStream的<code>propertyForKey:</code>方法会因为桥接而被调用，ProxyStream需要从original stream中获取正确的property，如果ProxyStream中这么写<br><br><div align=\"left\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMErrorPropertyForKey.png\" width=\"300\" height=\"72\"><br></div>\n\n<p>那么这个方法返回的结果会被<code>CFReadStreamCopyProperty</code>随后的<code>CFRelease</code>函数错误地释放，引起内存异常。</p>\n<p>正确的书写方式应该是</p>\n<div align=\"left\"><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMRightPropertyForKey.png\" width=\"600\" height=\"75\"><br></div>\n\n<p>ProxyStream 只需要”转发” <code>CFReadStreamCopyProperty</code> 函数给 original stream 就可以了。</p>\n<h3 id=\"4-使用-NSURLProtocol-监控-UIWebView\"><a href=\"#4-使用-NSURLProtocol-监控-UIWebView\" class=\"headerlink\" title=\"4. 使用 NSURLProtocol 监控 UIWebView\"></a>4. <span id=\"五4\">使用 NSURLProtocol 监控 UIWebView</span></h3><p><code>NSURLProtocol</code> 是监控 <code>UIWebView</code> 请求最普遍的解决方案。这里用户会产生多个 <code>NSURLProtocol</code> 会不会冲突的疑问？其实是不会的，因为即使用户注册了 <code>NSURLProtocol</code> ，拦截了 NeteaseAPM 的 <code>NSURLProtocol</code> 的请求，但用户的 <code>NSURLProtocol</code> 在发送请求时使用的的 <code>NSURLConnection</code> 或者 <code>NSURLSession</code> 还是会被 NeteaseAPM 监控到的。</p>\n<p>===================================================================</p>\n<h2 id=\"六-后续工作\"><a href=\"#六-后续工作\" class=\"headerlink\" title=\"六. 后续工作\"></a>六. <span id=\"六\">后续工作</span></h2><ul>\n<li>支持更多性能数据的收集，如内存，CPU，帧率等；</li>\n<li>支持自动诊断性能问题，如卡顿，Out of Memory 等；</li>\n</ul>\n<h2 id=\"七-引用链接\"><a href=\"#七-引用链接\" class=\"headerlink\" title=\"七. 引用链接\"></a>七. 引用链接</h2><p><a href=\"http://blog.csdn.net/yiyaaixuexi/article/details/9374411\" target=\"_blank\" rel=\"external\">Objective-C的hook方案: Method Swizzling</a><br><a href=\"http://www.tanhao.me/code/160702.html/\" target=\"_blank\" rel=\"external\">使用NSProxy和NSObject设计代理类的差异</a><br><a href=\"https://github.com/facebook/fishhook\" target=\"_blank\" rel=\"external\">fishhook</a><br><a href=\"http://blog.csdn.net/nlforever/article/details/12908115\" target=\"_blank\" rel=\"external\">Toll-free bridging介绍</a></p>\n","excerpt":"<p>一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。","more":"</p>\n<h2 id=\"一-NeteaseAPM-是什么\"><a href=\"#一-NeteaseAPM-是什么\" class=\"headerlink\" title=\"一. NeteaseAPM 是什么\"></a>一. <span id=\"一\">NeteaseAPM 是什么</span></h2><p>Application Performance Management(APM)，应用程序性能管理，主要指对企业的关键业务应用进行监测、优化，提高企业应用的可靠性和质量，保证用户得到良好的服务。一个企业的关键业务应用的性能强大，可以提高竞争力，并取得商业成功。NetsaseAPM 是网易性能数据分析平台，一个用户数据分析平台，支持非侵入式获取应用性能数据，实时展示多个维度分析结果。<!-- more -->  </p>\n<p>NetsaseAPM 移动端支持的功能：</p>\n<ol>\n<li>应用性能分析<br>对当前应用请求的各项性能指标进行分析，如响应时间，吞吐量，下载速率等，帮助用户全面了解应用性能表现。</li>\n<li>错误分析<br>分析应用每个域名的网络错误率及响应码错误率，快速定位应用问题。</li>\n<li>多维分析<br>可以组合域名，地理位置，运营商，网络环境等参数，精确定位应用的性能问题。</li>\n</ol>\n<p>下面是从移动端收集的数据在 NeteaseAPM Web 平台的展示</p>\n<div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequestSearch.png\" width=\"800\" height=\"160\"/><br></div><br><div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMRequest.png\" width=\"800\" height=\"300\"/><br></div><br><div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMUITrace.png\" width=\"800\" height=\"360\"/><br></div>\n\n\n<h2 id=\"二-NeteaseAPM-iOS-SDK-的目标\"><a href=\"#二-NeteaseAPM-iOS-SDK-的目标\" class=\"headerlink\" title=\"二. NeteaseAPM iOS SDK 的目标\"></a>二. <span id=\"二\">NeteaseAPM iOS SDK 的目标</span></h2><ol>\n<li>最小侵入：<br>只需要启动一次，就可以持续收集网络和交互数据，不需要手动收集数据。<br>启动方式：<div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMUseSample.png\" width=\"800\" height=\"116\"/><br></div><br>启动之后，NeteaseAPM 会插入收集数据的代码到系统调用中，却不会影响用户的使用，在用户的网络消息中的位置如图：<br><div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMStruct.png\" width=\"300\" height=\"287\"/><br></div></li>\n<li>最大化自由配置：  <ul>\n<li>用户可以看到收集到的数据，选择是否上传到 NeteaseAPM 服务器；  </li>\n<li>用户可以自己上传数据到 NeteaseAPM 服务器；  </li>\n</ul>\n</li>\n<li>功能特点：<br>支持对底层网络库 CFNetwork 的监控；</li>\n</ol>\n<h2 id=\"三-现状\"><a href=\"#三-现状\" class=\"headerlink\" title=\"三 现状\"></a>三 <span id=\"三\">现状</span></h2><p>目前实现的功能： </p>\n<ul>\n<li>网络请求的响应时间，下载速率，状态码，错误码，网络状态等数据的收集；</li>\n<li>页面加载时间的收集，检查出慢交互页面；</li>\n</ul>\n<p>已经接入的应用： 网易新闻，网易云音乐，考拉。</p>\n<h2 id=\"四-整体设计\"><a href=\"#四-整体设计\" class=\"headerlink\" title=\"四 整体设计\"></a>四 <span id=\"四\">整体设计</span></h2><div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMStructDesign.png\" width=\"400\" height=\"272\"/><br></div>\n\n<p>NeteaseAPM iOS SDK分为四个部分：  </p>\n<ul>\n<li><p>Hooker：<br>Hooker 负责在用户无感知的情况下替换程序原实现，转发消息回调，完成对系统消息的 hook 和数据的采集。<br>Hooker 能否监控到更多更准确的数据，是衡量一个 APM 产品是否优秀的最重要的标准。<br>一个 APM 产品监控的数据面越广，收集的数据越细，就越能准确地取得用户的性能数据，帮助产品优化性能。</p>\n</li>\n<li><p>DataBuilder：<br>收集监控数据；</p>\n</li>\n<li>Persistence：<br>缓存监控数据；</li>\n<li>Poster：<br>上传监控数据到NeteaseAPM；  </li>\n</ul>\n<p>线程模型： 监控数据的保存和发送都在后台队列中执行，不会影响用户线程。  </p>\n<p>数据上传规则：  </p>\n<ul>\n<li>可设置允许数据上传的网络环境；</li>\n<li>数据支持批量发送，可自定义发送批量和等待间隔；</li>\n</ul>\n<p>===================================================================</p>\n<h2 id=\"五-一些关键实现\"><a href=\"#五-一些关键实现\" class=\"headerlink\" title=\"五. 一些关键实现\"></a>五. <span id=\"五\">一些关键实现</span></h2><p>APM SDK 使用方式和一般的UI库有很大不同，APM 只需要启动一次即可生效，不需要修改代码。例如：启动APM之后，用户使用 NSURLConnection 执行的网络请求就会在开始连接，得到响应，获取数据等时机被 APM 监控到，而不需要使用者手动添加任何监控代码。要实现这样的目标，Hooker 需要使用一些比较特殊的的方式来实现，下面介绍Hooker使用到的解决方案：</p>\n<h3 id=\"1-开始使用面向切面编程\"><a href=\"#1-开始使用面向切面编程\" class=\"headerlink\" title=\"1.    开始使用面向切面编程\"></a>1.    <span id=\"五1\">开始使用面向切面编程</span></h3><p>APM需要将监控代码插入到系统实现中，完成系统消息的拦截和数据收集。比如我们需要知道 NSURLConnection 在什么时候开始发送请求，就会监控 <code>-[NSURLConnection start]</code> 方法，这就需要在这个方法中插入APM的逻辑，要做到这一点，需要理解面向切面编程的思想。</p>\n<p>Aspect Oriented Programming(AOP)，面向切面编程，面对的是处理过程中的某个步骤或阶段。在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。借助 AOP，甚至不用修改一行代码，就可以修改现有程序的行为，非常高效。</p>\n<p>AOP 基本原理：将一个函数替换为一个新函数，新的函数中插入代码片段，然后执行原函数。</p>\n<div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMAOPTheory.png\" width=\"400\" height=\"277\"/><br></div><br>下面分别介绍 Objective-C 和 C 这两种语言支持 AOP 的方式。<br><br>Objective-C 对 AOP 的支持非常容易：<br>一个 Objective-C 的方法调用 <code>[self setFilled:YES]</code> 在运行时和下方的代码等效<br><div align=left><br><img src=\"NeteaseAPM iOS SDK技术实现/Objective-CAOP.png\" width=\"580\" height=\"97\"/><br></div><br>系统会通过 <strong>SEL</strong> 查找对应的函数指针 <strong>IMP</strong>，所以通过修改SEL对应的IMP，可以方便地hook原方法。<br>Objective-C 借助这个原理实现的 AOP 有一个形象的名字：<br><a href=\"http://blog.csdn.net/yiyaaixuexi/article/details/9374411\">Method Swizzling</a> 醉了的方法 ~~！<br><br>C 的 AOP 使用了 <code>dyld</code>(dynamic link editor)，在系统加载可执行文件时修改了符号的地址，简单了解一下：<br>C函数指针的地址可以通过<code>dlsym</code>函数取得，如：<br><div align=left><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMDlsymClose.png\" width=\"600\" height=\"50\"/><br></div><br>我们需要查找到这个函数指针的地址，查找过程见下图：<br><div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMFindSymbolIMPLocation.png\" width=\"600\" height=\"460\"/><br></div><br><a href=\"https://github.com/facebook/fishhook\">fishhook</a>可以方便地查找替换C函数的指针。<br><br>### 2.    <span id=\"五2\">使用代理模式拦截回调消息</span><br>通过 AOP ，可以监控指定类的指定方法了，我们可以取得方法调用的时机了，但是程序中除了方法调用还存在方法回调，这是一种不适合用AOP监控的情况。例如，NSURLConnection 的 <code>start</code> 方法可以通过 Method Swizzling 监控，<br>但是回调消息的接收者 <code>delegate</code> 的类名不固定，可能是任意一个页面实例，不适合需要指定 Class 的 Method Swizzling。<br><br>解决方法是构造一个回调消息的转发者，作为代理，在转发者中收集数据，再转发给用户。下图演示对 NSURLConnection 的监控，MAM IMP 是 <code>start</code> 方法被替换后的实现，ProxyDelegate 就是消息转发者，负责将回调消息转发给 <code>delegate</code> 对象：<br><div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMURLConnectionHook.png\" width=\"600\" height=\"347\"/><br></div>  \n\n<p><code>NSProxy</code> 是 <code>Objective-C</code> 中除了 <code>NSObject</code> 之外的另一个基类，由于它实现的方法非常少，可以方便地借助消息转发机制转发未实现的消息。</p>\n<p>ProxyDelegate 的转发使用系统的消息转发机制：</p>\n<div align=left><br><img src=\"NeteaseAPM iOS SDK技术实现/ProxyDelegateInvocation.png\" width=\"647\" height=\"180\"/><br></div>  \n\n<p>CFNetwork 的监控也使用了代理模式，获取 stream 读取的数据长度：</p>\n<div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookConnectionFlow.png\" width=\"600\" height=\"429\"/><br></div>\n\n\n<h3 id=\"3-桥接模式，从面向过程到面向对象\"><a href=\"#3-桥接模式，从面向过程到面向对象\" class=\"headerlink\" title=\"3.    桥接模式，从面向过程到面向对象\"></a>3.    <span id=\"五3\">桥接模式，从面向过程到面向对象</span></h3><p>CFNetwork 是一个 C 语言实现的网络系统框架，虽然使用起来比较麻烦，但是可配置的功能更多。但由于面向过程编程难以扩展的缺点，没有办法选择性地监控和 http 有关的 <code>CFReadStreamRef</code> ，而不影响到来自文件或内存的 <code>CFReadStreamRef</code>。</p>\n<p>所幸 Objective-C 支持从面向过程到面向对象的桥接：<a href=\"http://blog.csdn.net/nlforever/article/details/12908115\"><strong>Toll-Free Bridging</strong></a>，允许某些 CoreFoundation类与对应的Objective-C 类互相转换，使我们可以在面向过程编程和面向对象编程两种编程思想中自由切换。</p>\n<p>NeteaseAPM 的策略：在系统构造 http stream 时，将一个 <code>NSInputStream</code> 的子类 ProxyStream 桥接为 <code>CFReadStreamRef</code>，返回给用户，达到单独监控 http stream 的效果。</p>\n<div align=center><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMCFHookCreate.png\" width=\"360\" height=\"178\"/><br></div>\n\n<p>使用 Toll-Free Bridging 时需要重点关注两种不同的内存管理机制的问题。例如 <code>-[NSInputStream propertyForKey]</code> 方法和 <code>CFReadStreamCopyProperty</code> 函数是桥接的，但是它们内存管理方法不同，前者是自动管理，后者是手动管理，后者在调用之后需要使用者在随后手动调用 <code>CFRelease</code>。</p>\n<p>以 ProxyStream 举例，ProxyStream 是 <code>CFReadStreamRef</code> 的代理，负责管理 http stream 的数据收集。如果用户对一个 http stream 执行如下调用：</p>\n<div align=left><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMCopyProperty.png\" width=\"563\" height=\"54\"/><br></div><br>ProxyStream的<code>propertyForKey:</code>方法会因为桥接而被调用，ProxyStream需要从original stream中获取正确的property，如果ProxyStream中这么写<br><br><div align=left><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMErrorPropertyForKey.png\" width=\"300\" height=\"72\"/><br></div>\n\n<p>那么这个方法返回的结果会被<code>CFReadStreamCopyProperty</code>随后的<code>CFRelease</code>函数错误地释放，引起内存异常。</p>\n<p>正确的书写方式应该是</p>\n<div align=left><br><img src=\"NeteaseAPM iOS SDK技术实现/NAPMRightPropertyForKey.png\" width=\"600\" height=\"75\"/><br></div>\n\n<p>ProxyStream 只需要”转发” <code>CFReadStreamCopyProperty</code> 函数给 original stream 就可以了。</p>\n<h3 id=\"4-使用-NSURLProtocol-监控-UIWebView\"><a href=\"#4-使用-NSURLProtocol-监控-UIWebView\" class=\"headerlink\" title=\"4. 使用 NSURLProtocol 监控 UIWebView\"></a>4. <span id=\"五4\">使用 NSURLProtocol 监控 UIWebView</span></h3><p><code>NSURLProtocol</code> 是监控 <code>UIWebView</code> 请求最普遍的解决方案。这里用户会产生多个 <code>NSURLProtocol</code> 会不会冲突的疑问？其实是不会的，因为即使用户注册了 <code>NSURLProtocol</code> ，拦截了 NeteaseAPM 的 <code>NSURLProtocol</code> 的请求，但用户的 <code>NSURLProtocol</code> 在发送请求时使用的的 <code>NSURLConnection</code> 或者 <code>NSURLSession</code> 还是会被 NeteaseAPM 监控到的。</p>\n<p>===================================================================</p>\n<h2 id=\"六-后续工作\"><a href=\"#六-后续工作\" class=\"headerlink\" title=\"六. 后续工作\"></a>六. <span id=\"六\">后续工作</span></h2><ul>\n<li>支持更多性能数据的收集，如内存，CPU，帧率等；</li>\n<li>支持自动诊断性能问题，如卡顿，Out of Memory 等；</li>\n</ul>\n<h2 id=\"七-引用链接\"><a href=\"#七-引用链接\" class=\"headerlink\" title=\"七. 引用链接\"></a>七. 引用链接</h2><p><a href=\"http://blog.csdn.net/yiyaaixuexi/article/details/9374411\">Objective-C的hook方案: Method Swizzling</a><br><a href=\"http://www.tanhao.me/code/160702.html/\">使用NSProxy和NSObject设计代理类的差异</a><br><a href=\"https://github.com/facebook/fishhook\">fishhook</a><br><a href=\"http://blog.csdn.net/nlforever/article/details/12908115\">Toll-free bridging介绍</a></p>"},{"title":"聊聊移动端那些混合开发框架们","date":"2016-12-01T16:00:00.000Z","list_number":true,"author":"张建伟","_content":"本文主要介绍笔者前些日子对市面上一些移动端混合编程方案的实现方式上的调研，读者可以据此了解移动端目前常见的一些混合开发框架的实现原理，欢迎读者在本文基础上做更深入的探索和调研，如有纰漏，欢迎指正。<!-- more -->\n\n本文示例代码链接: <https://github.com/jackwee/hybrid-demos>\n\n# 前言\n\n* 2008年，HTML5发布首个版本。\n\n* 2011年，Facebook开展[Spartan](http://techcrunch.com/2011/06/15/facebook-project-spartan/)项目，企图用HTML5的思想武装自己，占领iOS的浏览器，以此来与苹果抗衡。因为浏览器是相对开放的，Apple总不可能在浏览器端设置一个开关对网页内容进行限制。\n\n* 2012年，Mark Zuckerberg:\"the biggest mistake that we made as a company is betting too much on HTML5 as opposed to native.\"Facebook放弃HTML5，转投Native。\n* 2015年，Facebook发布react-native。\n\n如今，混合开发的呼声越来越高，世面上也有很多混合开发框架，采用混合开发的应用也是越来越多。\n\n以下将从什么是混合开发、为什么要做混合开发、移动端都在怎么做混合开发来做逐步介绍。\n\n--------\n\n<font color=#CC0033 size=6px>What?</font>\n\n两种或两种以上的程序设计语言的邂逅。\n\n* JNI:Java与C/C++的混合开发\n* iOS中Objective-C与C、Swift与C的混合开发\n* ReactNative中JavaScript与Native语言的混合开发\n\n本文介绍和调研的主要是移动平台上WEB(WebView、JavaScript)与Native语言的混合开发。\n\n\n<font color=#CC0033 size=6px>Why?</font>\n\n# Web & Native\n\n|对比|Web|Native|\n|:---:|:---:|:---:|\n|优势|跨平台、开发效率高、方便调试、方便部署|性能体验好、访问Low API、强大的IDE、原生的动画、系统手势|\n|存在问题|性能问题、浏览器兼容性问题、访问Low API受限、需要模拟原生动画和手势|平台依赖性强、调试不便、应用更新周期长、开发效率低|\n\n混合编程就是为了将两者的优点结合起来，做到“兼得🐟和🐻👐”。\n\n\n\n<font color=#CC0033 size=6px>How?</font>\n\n# 那些混合编程们\n\n目前移动端主流的混合开发有两个流派，一个是基于WebView做混合开发的Hybrid流派，一个是基于虚拟机做混合开发的'JavaSciptBridge'流派。\n\n1. WebViewBridge流派(Hybrid流派):基于WebView做与Native语言的混合开发\n\t* [PhoneGap](http://phonegap.com/) / [Cordova](https://cordova.apache.org)\n\t* [SuperWebView](http://www.apicloud.com/superwebview)\n\t* [5+Runtime & Native.js](http://dcloud.io/runtime.html#toDownload)\n2. 'JavaScipt Bridge'流派(JSBinding,LuaBinding,自定义消息传递):基于脚本语言本身做与Native语言的混合开发\n\t* [Titanium](http://www.appcelerator.com/mobile-app-development-products/)\n\t* [ReactNative](https://facebook.github.io/react-native/)\n\t* [samurai-native](https://github.com/hackers-painters/samurai-native)\n\n另外，还有翻译流派，如[J2ObjC](http://j2objc.org/)将Java语言翻译成Objective-C，编译流派，如[Xamarin](http://xamarin.com/)直接C#编译为二进制文件来开发iOS应用，这两种做法相对比较小众，本文并不做探讨。\n\n## PhoneGap/Cordova\n\n`PhoneGap: \"Write Once, Run Anywhere\"。`\n\n目标是让使用者编写一套代码来实现跨平台操作，它是Hybrid技术的一种实现，赋予WebView访问Native API的能力，屏蔽掉平台相关API实现跨平台开发。\n\n![](移动端混合编程/Cordova.png)\n\n上图是Cordova的架构图，其中Web App部分是前端开发部分，在WebView上执行。Cordova Plugins是Cordova所提供的用于访问本地代码的插件，这些插件具有操作本地资源的能力，如定位、陀螺仪、相机、联系人等等，此外，用户也可以自定义插件，js代码部分可以通过Cordova Native APIs来访问这些插件。那么这里对插件的调用实际是怎么实现的？\n\n我们使用一个简单的demo进行测试。\n\nNative端定义了自定义插件MyHybridPlugin，其中定义了addBookmark方法，在html页面上点击按钮，我们通过cordova调用addBookmark。\n\n```\n(1)html\n//页面上添加点击事件处理\n<button id=\"bookmarkBtn\" onclick=\"app.addBookmark()\">Add a bookmark</button>\n\n<script type=\"text/javascript\" src=\"cordova.js\"></script>\n<script type=\"text/javascript\" src=\"js/index.js\"></script>\n\n(2)JavaScript(index.js)\nvar app = {\n    addBookmark: function() {\n        ...\n        cordova.exec(win, fail, \"MyHybridPlugin\", \"addBookmark\", [bookmark]);\n    }\n\n};\n\n(3)JavaScript(cordova.js)\n//添加消息到消息队列\ncommandQueue.push(JSON.stringify(command));\n\n(4)JavaScript(cordova.js)\n//通过iframe通知native\npokeNativeViaIframe();\n\n===>\nexecIframe = document.createElement('iframe');\nexecIframe.style.display = 'none';\nexecIframe.src = 'gap://ready';\ndocument.body.appendChild(execIframe);   \n\n(5)Objective-C\n//从js消息队列中取消息内容\nwebView:shouldStartLoadWithRequest:navigationType:\n[_commandQueue fetchCommandsFromJs];\n\n(6)JavaScript(cordova.js)\n//以json方式返回消息内容，包括callbackId\nnativeFetchMessages();\n \n(7)Objective-C\n//根据json内容查找对应的class和selector，并执行相应方法\n- (BOOL)execute:(CDVInvokedUrlCommand*)command\n\n(8)Objective-C\n//回调执行结果，带上callbackId\nsendPluginResult:callbackId:\n\n(9)JavaScript(cordova.js)\n//根据callbackId回调执行结果\niOSExec.nativeCallback();\n\n```\n通过调试发现，cordova是通过将js对native的方法调用信息，封装成一个UIL，并通过iframe的形式加载该url。native端通过UIWebViewDelegate的代理方法`webView:shouldStartLoadWithRequest:navigationType:`拦截url，并解析出其中的函数签名信息，通过oc的runtime查找对应的类和方法，实现了本地方法调用，并返回本次调用对应的callbackId，cordova会根据该id查找到对应的js回调方法，实现回调给js。\n\n优点：\n\n* 跨平台\n\n缺点：\n\n* 性能问题：从上面的分析可以看出js到native的调用流程比较繁琐\n* 对native工程师的依赖：前端工程师需要native开发来提供所需插件\n\n## SuperWebView\n\n`SuperWebView:能够帮助原生APP团队解决“如何在短时间内开发出体验好、功能强的HTML5页面”的问题`\n\nSuperWebView为web程序员开发App提供一套整体的解决方案，以SDK的方式提供使用（不开源），总结一下主要包括特点：\n\n* 管理平台提供上百种模块，平台可以根据用户选取组合的模块构建生成SDK，开发者下载使用放到项目中使用\n* 支持用户自定义模块，导出给js使用，需要构建静态库，并打包成zip上传到管理平台，由平台编译生成sdk\n* 利用管理平台，可以进行资源包的热更新\n* 系统API对象提供的JS接口，可以在使用JS进行以下操作：获取系统属性、系统事件、使用进行封装了的接口\n* 提供云API来进行：操作云端数据、统计、推送、短信验证等功能\n* 提供与腾讯X5浏览器的集成（Android）\n\n下面是SuperWebView的架构图：\n\n![](移动端混合编程/superwebview.png)\n\n先看右侧部分，上面是SuperWebView提供的页面组织结构，用户可以利用API对象提供的接口创建界面，用户可以创建window（整个界面），frame（界面中的模块界面），frameGroup（一组可以左右滑动浏览的界面），UIModule（native自定义视图）；右侧下面部分是SuperWebView提供的基础服务，并提供了与Native通信的机制；左侧部分是SuperWebView平台已模块的形式提供的可以供JS使用的Native模块单元，官网上有模块管理平台提供了模块可以供开发者使用，开发者也可以根据平台标准自定义模块。\n\n\n下面是使用SuperWebView实现的模拟网易云音乐的一个demo示例：\n\n![](移动端混合编程/superwebview.gif)\n\n主页面的层级结构：\n\n![](移动端混合编程/superwebview2.png)\n\n可以看到，应用界面可以由多个APIWebView与UIView（或其子类）组合而来，但是这些组合关系并不需要web端开发者来操心，可以借助平台api对象开放的接口调用，平台接口会构建出相应界面的的组合，例如,可以使用下面这样的方式打开一个可以左右滑动的多个页面组合而成的页面，其构建的界面结果就是UIScrollView中横向放置了四个页面，可以左右滑动翻页浏览。\n\n```\napi.openFrameGroup({\n        name: 'framegroup01',\n        background: '#FFF',\n        scrollEnabled: true,\n        rect: {\n            x: 0,\n            y: firstHeaderOffset.h + firstHeaderIndexHeight,\n            w: \"auto\",\n            h: api.frameHeight - firstHeaderOffset.h - firstHeaderIndexHeight - footerPos.h\n        },\n        index: 0,\n        frames: [{\n            name: 'frame01_recommand',\n            url: './html/first_frame/frame01_recommand.html',\n            bounces: false,\n        }, {\n            name: 'frame01_list',\n            url: './html/first_frame/frame01_list.html',\n            bounces: true,\n        }, {\n            name: 'frame01_radio',\n            url: './html/first_frame/frame01_radio.html',\n            bounces: false,\n        }, {\n            name: 'frame01_rank',\n            url: './html/first_frame/frame01_rank.html',\n            bounces: false,\n        }]\n    }, function(ret) {\n        setFrameGroupStatus(ret.index);\n    });\n```\n\n我们来看看APIWebView的真面目。\n\n```\n@interface APIWebView : UZWebView\n@interface UZWebView : UIWebView\n```\n我们看到，APIWebView实际是UIWebView的子类，整个页面结构使用APIWebView嵌套的方式构建。\n\n* 通过Instruments在iPhone5s上进行内存测试，对前面云音乐demo反复操作，累计创建11个APIWebView，内存开销在35M左右(创建11个UIWebView，并加载本地类似静态页面内存开销在24M左右)。\n* 通过对APIWebView的构造方法initWithFrame:和dealloc方法进行拦截，发现在打开新页面是通过[UZWebViewController loadWindow]和[UZWebViewController openFrame:]创建多个APIWebView，再结合Native控件，构建出页面。\n\nSuperWebView的用户通过对页面结构进行拆分，利用SuperWebView提供的API来构建页面，SuperWebView所提供的API会构建出相应的页面结构，例如上面云音乐demo中的首页面，就是由2个APIWebView和一个UIScrollView嵌套组合而成。至于界面的样式，需要用户用HTML+CSS进行描述。\n\n### SuperWebView中JS与Native通信的实现原理\n\n下面分析下SuperWebView的实现JS与Native的通信机制。\n\n测试环境：iPhone5S,iOS8.3和iPhone4S,iOS7.1.1\n\n我们在JS端调用`alert(\"alert from js\");`接口，利用远程调试进行断点跟踪。\n\n```\n//alert的实现\nfunction (msg) {\n\t!function(msg){\n\t\tif(msg===null){\n\t\t\tmsg='null'\n\t\t};\n\t\tif(msg===undefined){\n\t\t\tmsg='undefined'\n\t\t};\n\t\tmsg=msg.toString();\n\t\tapi.alert({title:'index.html',msg:msg,buttons:['好']});\n\t}(msg);\n}\n```\n\n```\n//api.alert的实现\nfunction () {\n\treturn uz$e('UZAPI','alert',arguments,false,'api');\n}\n```\n\n```\n///uz$e的实现\nfunction uz$e(c, m, p, isSync, module) {\n    var param = {};\n    \n    //(1)\n    if (p.length === 1) {\n        var p0 = p[0];\n       //(1.1)\n\t\tif (Object.prototype.toString.call(p0) === \"[object Object]\") {\n            param = p0;\n        } else if (typeof p0 === \"function\") {\n            param.cbId = uz$cb.id++;\n            uz$cb.fn[param.cbId] = p0;\n        }\n    } else if (p.length === 2) {\n    \t//(1.2)\n        var p0 = p[0];\n        var p1 = p[1];\n        if (Object.prototype.toString.call(p0) === \"[object Object]\") {\n            param = p0;\n        }\n        if (typeof p1 === \"function\") {\n            param.cbId = uz$cb.id++;\n            uz$cb.fn[param.cbId] = p1;\n        }\n\t}\n\t\n\t//（2）\n    if (typeof(_apiBridgeMethod)==='function'){\n    \t //(2.1)\t\n        return _apiBridgeMethod(c, m, param, isSync, module);\n    } else if (api.useWKWebView) {\n    \t //(2.2)\t\n        var message = {};\n        message.class = c;\n        message.method = m;\n        message.param = param;\n        message.isSync = false;\n        message.module = module;\n        window.webkit.messageHandlers.api.postMessage(message);\n    } else {\n    \t //(2.3)\t\n        uz$q.c.push(module+'.'+c+'.'+m+'/?'+encodeURIComponent(JSON.stringify(param)));\n        uz$r();\n    }\n}\n```\n\n对这段代码进行分析：\n\n（1）对参数进行处理\n\n(1.1) 只有一个参数，对调用参数或者回调函数分别处理\n \n(1.2) 有两个参数，对调用参数和回调函数分别处理\n\n（2）执行函数调用\n\n(2.1) 调用_apiBridgeMethod方法，在当前测试环境下，会走2.1的逻辑，其实现如下：\n\n```\nfunction () {\n    [native code]\n}\n\n```\n可以看到_apiBridgeMethod的方法体是native code，那么是如何将native code注册给WebView的JS解释器的呢？\n\n将APICloud.a中的UZWebView.o反编译出来伪代码看到如下实现:\n\n```\n// UZWebView - (void)initJavaScriptCoreBridgeMethod\nvoid __cdecl -[UZWebView initJavaScriptCoreBridgeMethod](struct UZWebView *self, SEL a2)\n{\n  struct UZWebView *v7; // r8@1\n  void *v8; // r0@1\n  void *v9; // r5@1\n  void *v10; // r0@1\n  void *v11; // r6@1\n  void *v13; // r0@2\n  void *v14; // r6@2\n  void *v15; // r0@2\n  int v16; // r4@2\n  void *v17; // r0@2\n  void *v18; // r5@2\n  int *v19; // r4@3\n  int v23; // [sp+0h] [bp-78h]@1\n  void *v24; // [sp+4h] [bp-74h]@3\n  void *v25; // [sp+8h] [bp-70h]@3\n  void *v26; // [sp+Ch] [bp-6Ch]@3\n  int v27; // [sp+10h] [bp-68h]@3\n  int v28; // [sp+14h] [bp-64h]@3\n  int (__fastcall *v29)(__block_literal_3 *, Foundation::NSString::NSString *, Foundation::NSString::NSString *, Foundation::NSDictionary::NSDictionary *, Foundation::NSString::NSString *, int); // [sp+18h] [bp-60h]@3\n  void *v30; // [sp+1Ch] [bp-5Ch]@3\n  int v31; // [sp+20h] [bp-58h]@1\n  char v32; // [sp+24h] [bp-54h]@3\n  int *v33; // [sp+28h] [bp-50h]@3\n  char v34; // [sp+2Ch] [bp-4Ch]@1\n  int v35; // [sp+30h] [bp-48h]@2\n  void *v36; // [sp+44h] [bp-34h]@1\n  void *v37; // [sp+48h] [bp-30h]@1\n  __int64 *v38; // [sp+4Ch] [bp-2Ch]@1\n  unsigned int v39; // [sp+50h] [bp-28h]@1\n  int *v40; // [sp+54h] [bp-24h]@1\n  char v41; // [sp+60h] [bp-18h]@5\n  __int64 savedregs; // [sp+78h] [bp+0h]@1\n\n  _R4 = (unsigned int)&v31 & 0xFFFFFFF0;\n  __asm\n  {\n    VST1.64         {D8-D11}, [R4@128]!\n    VST1.64         {D12-D15}, [R4@128]\n  }\n  v7 = self;\n  v8 = objc_msgSend(&OBJC_CLASS___UIDevice, \"currentDevice\");\n  v9 = (void *)objc_retainAutoreleasedReturnValue(v8);\n  v10 = objc_msgSend(v9, \"systemVersion\");\n  v11 = (void *)objc_retainAutoreleasedReturnValue(v10);\n  _R4 = objc_msgSend(v11, \"floatValue\");\n  objc_release(v11);\n  objc_release(v9);\n  v36 = &__objc_personality_v0;\n  v37 = &GCC_except_table117;\n  v38 = &savedregs;\n  v40 = &v23;\n  v39 = (((unsigned int)&loc_13E + 2) | 1) + 42164;\n  _Unwind_SjLj_Register(&v34);\n  __asm\n  {\n    VMOV.F32        D0, #7.0\n    VMOV            D1, R4, R4\n    VCMPE.F32       S2, S0\n    VMRS            APSR_nzcv, FPSCR\n  }\n  if ( !(_NF ^ _VF) )\n  {\n    v35 = -1;\n    v13 = objc_msgSend(v7, \"webView\");\n    v35 = -1;\n    v14 = (void *)objc_retainAutoreleasedReturnValue(v13);\n    v35 = -1;\n    v15 = objc_msgSend(v7, \"jsContextKeyPath\");\n    v35 = -1;\n    v16 = objc_retainAutoreleasedReturnValue(v15);\n    v35 = -1;\n    v17 = objc_msgSend(v14, \"valueForKeyPath:\", v16);\n    v35 = -1;\n    v18 = (void *)objc_retainAutoreleasedReturnValue(v17);\n    objc_release(v16);\n    if ( v18 )\n    {\n      v25 = v14;\n      objc_initWeak(&v32, v7);\n      v26 = &_NSConcreteStackBlock;\n      v27 = -1040187392;\n      v28 = 0;\n      v29 = _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke;\n      v33 = &v31;\n      v30 = &__block_descriptor_tmp_1135;\n      objc_copyWeak(&v31, &v32);\n      v23 = objc_retainBlock(&v26);\n      v35 = 1;\n      v24 = v18;\n      objc_msgSend(v18, \"setObject:forKeyedSubscript:\");\n      v19 = v33;\n      objc_release(v23);\n      objc_destroyWeak(v19);\n      objc_destroyWeak(&v32);\n      v14 = v25;\n      v18 = v24;\n    }\n    objc_release(v18);\n    objc_release(v14);\n  }\n  _Unwind_SjLj_Unregister(&v34);\n  _R4 = &v41;\n  __asm\n  {\n    VLD1.64         {D8-D11}, [R4@128]!\n    VLD1.64         {D12-D15}, [R4@128]\n  }\n}\n```\n\n这里我们可以看到，首先是利用KVC从UZWebView获得JSContext，然后setObject:forKeyedSubscript:设置_apiBridgeMethod的值为`_43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke`，它的实现如下：\n\n\n```\nint __fastcall _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke(\n__block_literal_3 *.block_descriptor, \nFoundation::NSString::NSString *a2, \nFoundation::NSString::NSString *method, \nFoundation::NSDictionary::NSDictionary *param, \nFoundation::NSString::NSString *module, \nint a6)\n{\n  Foundation::NSDictionary::NSDictionary *v7; // r5@1\n  Foundation::NSString::NSString *v8; // r4@1\n  int v9; // r10@1\n  int v10; // r4@1\n  void *v11; // r8@1\n  int v12; // r11@1\n  void *v13; // r2@1\n  int v14; // r0@2\n  void *v15; // r0@3\n  void *v16; // ST04_4@4\n  int v17; // r5@4\n  void *v18; // r0@4\n  void *v19; // r8@4\n  void *v20; // r4@4\n  void *v21; // r0@4\n  int v22; // r6@4\n  __block_literal_3 *v24; // [sp+8h] [bp-20h]@1\n\n  v24 = .block_descriptor;\n  v7 = param;\n  v8 = method;\n  v9 = objc_retain(a2);\n  v10 = objc_retain(v8);\n  v11 = (void *)objc_retain(v7);\n  v12 = objc_retain(a6);\n  v13 = objc_msgSend(&OBJC_CLASS___NSDictionary, \"class\");\n  if ( (unsigned int)objc_msgSend(v11, \"isKindOfClass:\", v13) & 0xFF )\n  {\n    v14 = objc_retain(v11);\n  }\n  else\n  {\n    v15 = objc_msgSend(&OBJC_CLASS___NSDictionary, \"dictionaryWithObjects:forKeys:count:\");\n    v14 = objc_retainAutoreleasedReturnValue(v15);\n  }\n  v16 = v11;\n  v17 = v14;\n  v18 = objc_msgSend(&OBJC_CLASS___UZCommand, \"alloc\");\n  v19 = objc_msgSend(v18, \"initWithClassName:methodName:param:\", v9, v10, v17);\n  objc_release(v10);\n  objc_release(v9);\n  objc_msgSend(v19, \"setIsSyncMethod:\", module);\n  objc_msgSend(v19, \"setModule:\", v12);\n  objc_release(v12);\n  v20 = (void *)objc_loadWeakRetained(&v24->weakSelf);\n  v21 = objc_msgSend(v20, \"execute:\", v19);\n  v22 = objc_retainAutoreleasedReturnValue(v21);\n  objc_release(v20);\n  objc_release(v19);\n  objc_release(v17);\n  objc_release(v16);\n  return objc_autoreleaseReturnValue(v22);\n}\n\n```\n\n大概意思是，读取调用信息，根据信息创建一个UZCommand对象，再去执行UZCommand，再看execute的实现：\n\n```\n// UZWebView - (id)execute:(id) \nid __cdecl -[UZWebView execute:](struct UZWebView *self, SEL a2, id a3)\n{\n  struct UZWebView *v3; // r11@1\n  void *v4; // r6@1\n  int v5; // r5@2\n  void *v6; // r0@3\n  int v7; // r10@3\n  void *v8; // r0@3\n  void *v9; // r8@3\n  void *v10; // r0@3\n  void *v11; // r0@3\n  void *v12; // r4@3\n  void *v13; // r0@3\n  int v14; // r5@3\n  void *v15; // r0@3\n  int v16; // r0@3\n  void *v17; // r6@3\n  void *v18; // r0@3\n  void *v19; // r5@3\n  int v20; // r10@4\n  void *v21; // r0@5\n  void *v22; // r4@5\n  void *v23; // r0@5\n  void *v24; // r0@5\n  void *v25; // r6@5\n  void *v26; // r0@5\n  void *v27; // r10@5\n  void *v28; // ST10_4@5\n  void *v29; // r4@5\n  void *v30; // r0@5\n  void *v31; // r0@5\n  int v32; // r4@5\n  void *v33; // r2@6\n  void *v34; // r0@7\n  void *v35; // r0@10\n  int v36; // r8@10\n  int v37; // r6@10\n  int v38; // r11@11\n  void *v39; // r0@12\n  void *v40; // r4@12\n  void *v41; // r0@13\n  int v42; // r4@13\n  void *v43; // r0@16\n  int v44; // r4@16\n  int v46; // [sp+18h] [bp-28h]@4\n  void *v47; // [sp+1Ch] [bp-24h]@10\n  int v48; // [sp+20h] [bp-20h]@3\n  void *v49; // [sp+24h] [bp-1Ch]@3\n\n  v3 = self;\n  v4 = (void *)objc_retain(a3);\n  if ( !((unsigned int)objc_msgSend(v3, \"shouldClosed\") & 0xFF) )\n  {\n    v6 = objc_msgSend(v4, \"methodName\");\n    v7 = objc_retainAutoreleasedReturnValue(v6);\n    v8 = objc_msgSend(v4, \"className\");\n    v9 = (void *)objc_retainAutoreleasedReturnValue(v8);\n    v10 = objc_msgSend(v4, \"paramDict\");\n    v48 = objc_retainAutoreleasedReturnValue(v10);\n    v11 = objc_msgSend(v3, \"request\");\n    v12 = (void *)objc_retainAutoreleasedReturnValue(v11);\n    v13 = objc_msgSend(v12, \"URL\");\n    v14 = objc_retainAutoreleasedReturnValue(v13);\n    v49 = v4;\n    v15 = objc_msgSend(v4, \"module\");\n    v16 = objc_retainAutoreleasedReturnValue(v15);\n    objc_release(v16);\n    v17 = v9;\n    objc_release(v14);\n    objc_release(v12);\n    v18 = objc_msgSend((void *)v3->_moduleDict, \"objectForKey:\", v9);\n    v19 = (void *)objc_retainAutoreleasedReturnValue(v18);\n    if ( !v19 )\n    {\n      v46 = v7;\n      v20 = NSClassFromString(v9);\n      if ( v20\n        || (v21 = objc_msgSend(&OBJC_CLASS___NSBundle, \"mainBundle\"),\n            v22 = (void *)objc_retainAutoreleasedReturnValue(v21),\n            v23 = objc_msgSend(v22, \"infoDictionary\"),\n            v24 = (void *)objc_retainAutoreleasedReturnValue(v23),\n            v25 = v24,\n            v26 = objc_msgSend(v24, \"stringValueForKey:defaultValue:\", CFSTR(\"CFBundleExecutable\"), &stru_12864),\n            v27 = (void *)objc_retainAutoreleasedReturnValue(v26),\n            v28 = v27,\n            objc_release(v25),\n            objc_release(v22),\n            v29 = objc_msgSend(v27, \"length\"),\n            v17 = v9,\n            v19 = 0,\n            v30 = objc_msgSend(v9, \"length\"),\n            v31 = objc_msgSend(&OBJC_CLASS___NSString, \"stringWithFormat:\", CFSTR(\"_TtC%lu%@%lu%@\"), v29, v27, v30, v9),\n            v32 = objc_retainAutoreleasedReturnValue(v31),\n            v20 = NSClassFromString(v32),\n            objc_release(v32),\n            objc_release(v28),\n            v20) )\n      {\n        v33 = objc_msgSend(&OBJC_CLASS___UZModule, \"class\");\n        if ( (unsigned int)objc_msgSend((void *)v20, \"isSubclassOfClass:\", v33) & 0xFF )\n        {\n          v34 = objc_msgSend((void *)v20, \"alloc\");\n          v19 = objc_msgSend(v34, \"initWithUZWebView:\", v3);\n        }\n      }\n      if ( !v19 )\n      {\n        v43 = objc_msgSend(&OBJC_CLASS___NSString, \"stringWithFormat:\", CFSTR(\"ERROR: Module '%@' not found\"), v17);\n        v44 = objc_retainAutoreleasedReturnValue(v43);\n        objc_msgSend(v3, \"sendErrorEvent:\", v44);\n        NSLog(CFSTR(\"%@\"), v44);\n        objc_release(v44);\n        v5 = 0;\n        v7 = v46;\n        v38 = v48;\n        goto LABEL_17;\n      }\n      objc_msgSend((void *)v3->_moduleDict, \"setObject:forKey:\", v19, v17);\n      v7 = v46;\n    }\n    v47 = v17;\n    v35 = objc_msgSend(&OBJC_CLASS___NSString, \"stringWithFormat:\", CFSTR(\"%@:\"), v7);\n    v36 = objc_retainAutoreleasedReturnValue(v35);\n    v37 = NSSelectorFromString();\n    if ( (unsigned int)objc_msgSend(v19, \"respondsToSelector:\", v37) & 0xFF )\n    {\n      v38 = v48;\n      if ( (unsigned int)objc_msgSend(v49, \"isSyncMethod\") & 0xFF )\n      {\n        v39 = objc_msgSend(v19, \"performSelector:withObject:\", v37, v48);\n        v40 = v19;\n        v5 = objc_retainAutoreleasedReturnValue(v39);\n        objc_release(v36);\n        objc_release(v40);\n        v17 = v47;\nLABEL_17:\n        objc_release(v38);\n        objc_release(v17);\n        objc_release(v7);\n        v4 = v49;\n        goto LABEL_18;\n      }\n      objc_msgSend(v19, \"performSelectorOnMainThread:withObject:waitUntilDone:\", v37, v48, 0);\n      v17 = v47;\n    }\n    else\n    {\n      v17 = v47;\n      v41 = objc_msgSend(\n              &OBJC_CLASS___NSString,\n              \"stringWithFormat:\",\n              CFSTR(\"ERROR: Method '%@' not defined in Module '%@'\"),\n              v7,\n              v47);\n      v42 = objc_retainAutoreleasedReturnValue(v41);\n      objc_msgSend(v3, \"sendErrorEvent:\", v42);\n      NSLog(CFSTR(\"%@\"), v42);\n      objc_release(v42);\n      v38 = v48;\n    }\n    objc_release(v36);\n    objc_release(v19);\n    v5 = 0;\n    goto LABEL_17;\n  }\n  v5 = 0;\nLABEL_18:\n  objc_release(v4);\n  return (id)objc_autoreleaseReturnValue(v5);\n}\n```\n\n主要流程是从UZCommand中读出模块，方法，参数等信息，根据类名创建了实例，然后调用初始化构造函数initWithUZWebView（这里和官网介绍[如何自定义模块](http://docs.apicloud.com/APICloud/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/module-dev-guide-for-ios)中的说明是一致的）,然后会判断是同步调用还是异步调用，同步调用则直接执行`performSelector:withObject:`，异步调用执行`performSelectorOnMainThread:withObject:waitUntilDone:`，至此，完成了JS到native方法的调用。\n\n(2.2)如果使用了WKWebView，则通过发送信息的方式将调用信息发给Native端。\n\n不过，目前SuperWebView暂未支持WKWebView，没有开放api和文档出来。\n\n(2.3)uz$q和uz$r的实现如下\n\n```\n//uz$q\n{c: Array[0], flag: true}\n\n//uz$r\nfunction uz$r() {\n    if(uz$q.flag && uz$q.c.length>0){\n        uz$q.flag = false;\n        window.location = 'uz://' + uz$q.c[0];\n\t}\n}\n```\n\n这里是将调用信息拼接成一个URL，scheme采用uz:，赋值给window.location赋值对当前页面重定向，这里应该是采用UIWebView的代理方式实现与Native端通信，会调用到`webView:shouldStartLoadWithRequest:navigationType:`代理方法中去，这种就是JSBridge的方式了。\n\n\n补充说明一点，从Native回调到JS端的方式是，通过`stringByEvaluatingJavaScriptFromString:`的方式，通知js端，并把callbackID作为参数回传过去。\n\n### 关于SuperWebView所指的混合渲染的说明\n\n看到混合渲染，第一理解是，SuperWebView支持将Native的View直接fix在UIWebView内部做渲染，这样做就需要修改webview的渲染机制，并且还要支持将css的解析映射到native view中去，通过官方文档和使用教程，并没有看到相关介绍。目前我的理解是，将Native的View作为子View添加到UIWebView中去。为了验证这一点，我们使用官网提供个UISlider模块来写示例代码，在JS中使用如下：\n\n```\nvar uislider = api.require('UISlider');\n            uislider.open({\n                animation: true,\n                orientation: 'horizontal',\n                rect: {\n                    x: 10,\n                    y: 100,\n                    size: 300\n                },\n                bubble: {\n                    direction: 'top',\n                    state: 'always',\n                    w: 80,\n                    h: 30,\n                    size: 14,\n                    color: '#888',\n                    bg: 'widget://res/slider/bubble.png',\n                    prefix: '温度：',\n                    suffix: '摄氏度'\n                },\n                handler: {\n                    w: 10,\n                    h: 8,\n                    bg: 'widget://res/slider/handler.png'\n                },\n                bar: {\n                    h: 4,\n                    bg: 'widget://res/slider/background.png',\n                    active: 'widget://res/slider/bar-active.png'\n                },\n                value: {\n                    min: 16,\n                    max: 32,\n                    step: 0.5,\n                    init: 26\n                },\n                fixedOn: api.frameName,\n                fixed: false\n            }, function(ret, err) {\n                if (ret) {\n                    alert(JSON.stringify(ret));\n                } else {\n                    alert(JSON.stringify(err));\n                }\n            });\n\n```\n\n打开的视图效果如下：\n\n![](./superwebview3.png)\n\n我们看到UISlider是悬浮在WebView之上的，那么我们可以猜测，其是通过在native构建并添加到WebView上的，这一点可以通过反编译了UISlider的目标文件，可以看到open方法的实现里面多次调用了addSubView方法。\n\n\n优点：\n\n* 性能好\n* 提供方便的api进行页面组合\n* 模块化平台，让更多的人为前端工程师服务\n* 管理平台：热更新，云数据等\n\n缺点：\n\n* 样式需要前端开发者去模拟native的样式\n* 有些系统级的动画暂不支持，如导航栏渐变动画\n\n\n## 5+Runtime & Native.js\n\n* 5+Runtime是对HTML5+规范的实现，除了支持标准HTML5外，还扩展了JavaScript对象plus，使得js可以调用各种浏览器无法实现或实现不佳的系统能力，设备能力如摄像头、陀螺仪、文件系统等，业务能力如上传下载、二维码、地图、支付、语音输入、消息推送等。编写一次，可跨平台运行。\n* 大量的手机OS的原生API无法被HTML5使用，Native.js把原生API封装成了js对象，通过js可以直接调ios和android的原生API。这部分就不再跨平台，写法分别是plus.ios和plus.android。\n* Native.js不是一个js库，不需要下载引入到页面的script中，也不像nodejs那样有单独的运行环境，Native.js的运行环境是集成在5+runtime里的。\n\n使用方式：\n\n* 对于web端开发者，使用HBuilder IDE，它集成了5+Runtime和Native.js，可以创建移动项目来开发App\n* 对于Native端开发者，可以从平台下载SDK集成到项目中使用\n\n看到5+runtime说是[开源](http://weibo.com/p/1001603806548597059383)了,不过在[开源项目](https://github.com/dcloudio/H5P.Core)中并未找到iOS native的代码实现，其中还是以静态库的形式提供，不过在pdr.js文件中，看到了plus.tools和plus.bridge的实现，这两个实现在后文中会使用到。\n\n\n### Native.js通信方式实现分析\n\n下面以使用iOS中的UIAlertView为示例。\n\niOS端使用UIAlertView的代码如下：\n\n```\n#import <UIKit/UIKit.h>\n//...\n// 创建UIAlertView类的实例对象\nUIAlertView *view = [UIAlertView alloc];\n// 设置提示对话上的内容\n[view initWithTitle:@\"自定义标题\" // 提示框标题\n    message:@\"使用NJS的原生弹出框，可自定义弹出框的标题、按钮\" // 提示框上显示的内容\n    delegate:nil // 点击提示框后的通知代理对象，nil类似js的null，意为不设置\n    cancelButtonTitle:@\"确定(或者其他字符)\" // 提示框上取消按钮的文字\n    otherButtonTitles:nil]; // 提示框上其它按钮的文字，设置为nil表示不显示\n// 调用show方法显示提示对话框，在OC中使用[]语法调用对象的方法\n[view show];\n```\n\nJS端使用UIAlertView的方式如下：\n\n```\n\t// 创建UIAlertView类的实例对象\n\tvar view = new UIAlertView();\n\t// 设置提示对话上的内容\n\tview.initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles(\"自定义标题\" // 提示框标题\n\t\t, \"使用NJS的原生弹出框，可自定义弹出框的标题、按钮\" // 提示框上显示的内容\n\t\t, null // 操作提示框后的通知代理对象，暂不设置\n\t\t, \"确定(或者其他字符)\" // 提示框上取消按钮的文字\n\t\t, null ); // 提示框上其它按钮的文字，设置为null表示不显示\n\t// 调用show方法显示提示对话框\n\tview.show();\n\n```\n\n其中UIAlertView、initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles和show的实现如下：\n\n```\nwindow.plus.ios.UIAlertView = function(create) {\n        this.__UUID__ = window.plus.tools.UUID('JSB');\n        this.__TYPE__ = 'JSBObject';\n        var args = window.plus.ios.__Tool.process(arguments);\n        if ( create && plus.tools.IOS == plus.tools.platform ) {\n        \n        } else {\n            window.plus.bridge.execSync('Invocation', '__Instance', [this.__UUID__, 'UIAlertView', args]);\n        }\n    };\n    \n```\n\n```\nplus.ios.UIAlertView.prototype.initWithTitlemessagedelegatedefaultButtoncancelButtonotherButtons = function () {\n        var ret = null;\n        try {\n            var args = window.plus.ios.__Tool.process(arguments);\n            ret = window.plus.bridge.execSync('Invocation', '__exec', [this.__UUID__, 'initWithTitle:message:delegate:defaultButton:cancelButton:otherButtons:', args]);\n            ret = plus.ios.__Tool.New(ret, false);\n        } catch (e) {\n            throw e;\n        }\n        return ret;\n    };\n   \n```\n\n\n```\nplus.ios.UIAlertView.prototype.show = function () {\n        var ret = null;\n        try {\n            var args = window.plus.ios.__Tool.process(arguments);\n            ret = window.plus.bridge.execSync('Invocation', '__exec', [this.__UUID__, 'show', args]);\n            ret = plus.ios.__Tool.New(ret, false);\n        } catch (e) {\n            throw e;\n        }\n        return ret;\n    };\n\n```\n\n可以看到，我们创建的UIAlertView是一个JS对象，这个对象是当我们使用`UIAlertView = plus.ios.importClass(\"UIAlertView\");`时动态创建的JS对象，与Native的UIAlertView相对应，我们称该JS对象为NJS对象。我们对NJS对象UIAlertView进行的方法调用，最终会执行`window.plus.bridge.execSync`，我们需要看下它的实现，在此之前，关于通过NJS对象访问Native对象，先做一些说明。\n\n* 首次导入Native类对象时，Native.js会动态创建一个JS对象与之相对应，JS对象包括相应的构造函数、方法、父类(prototype)等信息。\n* 由于是动态创建对应的JS对象，这里有一定的性能损耗，[官方文档](http://ask.dcloud.net.cn/docs/#http://ask.dcloud.net.cn/article/88)中性能优化一节建议页面打开后触发的“plusready”事件中进行类对象的导入操作，这样提前导入了我们需要导入的类对象，是我们在后面逻辑中使用时保证其已经导入，这种方式只是将导入时机提前，并不是消除了导入带来的损耗。所以官方也不建议我们在一个页面中导入过多的类对象，这样会影响性能。\n* 数据类型转换：在NJS中调用Native API或从Native API返回数据到NJS时会自动转换数据类型。\n* Native类对象的方法会在JS对象中有份映射，方法名是native方法名去掉‘冒号’之后的名称（字母大小写不变）。\n* 对于映射的JS对象，可以通过“.”调用方式来访问native对象的属性，但这种方式获得的值是Native层对象被映射为NJS对象那一刻的属性值，如果需要实时获取和设置native对象属性值，需要使用plusGetAttribute和plusSetAttribute方法，但这种方式效率比较低。\n* Objective-C和Java中类如果存在继承自基类，在NJS中对应的对象会根据继承关系递归将所有基类的公有方法一一换成NJS对象的方法，所有基类的公有属性也可以通过其plusGetAttribute、plusSetAttribute方法访问。\n* 由于Objective-C中类没有静态变量，而是通过定义全局变量来实现，目前NJS中无法访问全局变量的值。对于全局常量，在NJS中也无法访问。\n\n\n继续之前的window.plus.bridge.execSync方法调用，其方法实现如下：\n\n```\nfunction (service,action,args,fn){\n    var json,sync,ret;\n    if(T.IOS==T.platform){\n        try{\n            if(json=T.stringify([[window.__HtMl_Id__,service,action,null,args]]),\n                sync=B.synExecXhr,\n                sync.open(\"post\",\"http://localhost:13131/cmds\",!1),\n                sync.setRequestHeader(\"Content-Type\",\"multipart/form-data\"),\n                sync.send(json),\n                fn)\n                return fn(sync.responseText)\n        }catch(e){\n            console.log(\"sf:\"+action+\"-\"+service)\n        }\n        return window.eval(sync.responseText)\n    }\n    return T.ANDROID==T.platform?\n        (ret=window.prompt(T.stringify(args),\"pdr:\"+T.stringify([service,action,!1])),fn?fn(ret):eval(ret))\n        :void 0\n}\n\n```\n\n其中：\n\n```\nT=plus.tools,\nB=plus.bridge\n\n```\n\nsynExecXhr的全称是“同步调用XML HTTP Request”，前面我们提到了plus.bridge的实现中我们可以看到：\n\n```\nsynExecXhr: new XMLHttpRequest()\n```\n\n可以看到，synExecXh实际是一个XMLHttpRequest对象，通过它最后将调用信息以http请求的方式发出去。我们在Native端利用oc-runtime hook住UIAlertView的构造函数，添加断点，可以看到调用栈如下图所示：\n\n![](5+.png)\n\n可以看到，JS调用到Native端通过DCAsycSocket以这种进程间通信的方式来实现，并且在非主线程完成。至此，我们可以得知，native.js中js与native端的通信是通过本地socket同步通信的方式完成的，完成调用之后，调用结果会以字符串的形式保存在`sync.responseText`中，js端再通过evaluate其中的字符串来得到返回结果。\n\n小结：5+runtime还是基于WebView来做事，属于hybrid流派，通过本地socket通信方式来实现JS与Native的混合调用，支持动态导入native类对象，进行实例化、方法调用、属性访问等操作，与一般的hybrid技术不同的是，不需要native工程师来提供模块或者插件来支持扩展js的能力，web工程是可以参考native的方法调用类似的方式（只需要简单的修改），实现对native对象的访问。同时5+runtime还提供了一些跨平台的通用组件，如摄像头、陀螺仪、文件系统等。使用native.js技术所需要注意的问题就是性能问题，动态导入和访问native对象以及数据类型转化需要付出一定的性能损耗代价，官方给出了一些建议来进行性能优化。另外，值得一提的是DCloud公司还用HTML5做了一套模拟Native UI的开源项目MUI，有兴趣可以参考[这里](https://github.com/dcloudio/mui).\n\n\n优点：\n\n * web端可以直接访问native的api，调用接口参考\n * 提供一套native样式库：MUI\n\n 缺点：\n\n * 与native交互性能有点弱\n\n## Titanium\n\nTitanium:\"Write in JavaScript, run native everywhere\".\n\nTitanium与PhoneGap不同，并不是基于WebView来做跨平台开发，属于JavaSciptBridge流派，关于它与PhoneGap的对比可以参考[这篇文章](http://www.appcelerator.com/blog/2012/05/comparing-titanium-and-phonegap/)。值得一提的是，Titanium的上层语言并没有采用HTML+CSS+ JavaScript，而是XML+JSON+JavaScript，这增加了一定的学习成本。\n\n## React Native\n\nReactNative:\"learn once，write anywhere\".\n\nReactNative和Titanium的思路很像，也抛弃了WebView，属于JavaSciptBridge流派。ReactNative用JavaScript编写程序，渲染的界面全部都是Natvie的。[React](https://facebook.github.io/react/)是前端的知名开发库，程序代码通过操作Virturl DOM来编写程序，React runtime负责操作和更新真正的DOM节点，而这个更新是通过diff做增量更新，这提高性能，ReactNative沿用了React的编程模型和更新模型。\n\nReactNative的JS运行在与应用主线程独立的线程，通过异步操作与Natvie接口通信，线程模型可以参考下图：\n\n![](移动端混合编程/reactnative.png)\n\nJS解释器可以运行于手机中的独立线程，也可以远程调试时运行在浏览器中，另外，I/O操作、图片解码、布局信息计算等其他一些消耗CPU的操作也可以放到独立线程中，iOS应用主线程用来操作UI控件和Native API访问，JS线程与UI主线程之间通过ReactNative桥接进行异步通信，实现JS与Objective-C之间的相互调用。\n\n![](移动端混合编程/reactnative2.png)\n\n### React Native通信机制源码分析\n\n源码分析基于React Native v0.23.1,不过下载了目前的最新版0.38.0调试了，实现方式大同小异。\n\nReact Native 的思路就是将Native方法导出给JS用，使得用户可以用JS编写程序，而采用原生控件构建构建应用。\nReact Native 导出以模块（Module）为单位，在程序启动时，加载需要注册到js中的module，挂到js解释器的__fbBatchedBridgeConfig变量上，格式如下：\n\n```\n{\"remoteModuleConfig\":[\n\n[\"RCTStatusBarManager\",\n\t[\"getHeight\",\"setStyle\",\"setHidden\",\"setNetworkActivityIndicatorVisible\"]],\n[\"RCTSourceCode\",\n\t{\"scriptURL\":\"http:\\/\\/localhost:8081\\/index.ios.bundle?platform=ios&dev=true&hot=true\"},\n\t[\"getScriptText\"],[0]]\n]\n```\nReact Native还在不断的迭代开发中，不同版本的实现方式可能不同，例如，在[React Native通信机制详解](http://blog.cnbang.net/tech/2698/)一文中介绍，Natvie模块的注册方式是通过在利用编译指令将需要导出的模块存储到执行文件的二进制DATA端，程序启动时再从中读取导出的模块信息，我使用的源码是v0.23.1版本，可以看到，需要bridge的模块需要使用`RCTRegisterModule`宏，其展开如下：\n\n```\n#define RCT_EXPORT_MODULE(js_name) \\\nRCT_EXTERN void RCTRegisterModule(Class); \\\n+ (NSString *)moduleName { return @#js_name; } \\\n+ (void)load { RCTRegisterModule(self); }\n```\n可以看到，bridge的模块在load方法中进行注册，注册的模块保存在RCTBridge.m的`static NSMutableArray<Class> *RCTModuleClasses;`全局静态变量中。模块中需要bridge的方法使用`RCT_EXPORT_METHOD`宏，默认情况下，使用OC方法的第一个分号之前的部分作为JS中的调用名称，例如模块ModuleName中，需要导出的方法`- (void)doSomething:(NSString *)aString withA:(NSInteger)a andB:(NSInteger)b`，需要写成\n\n```\nRCT_EXPORT_METHOD(doSomething:(NSString *)aString\n                   withA:(NSInteger)a\n                   andB:(NSInteger)b)\n { ... }\n```\n最终JS的调用形式是`NativeModules.ModuleName.doSomething`。\n\n\n应用启动时，会创建一个CADisplayLink添加到线程（真机上是JS线程，模拟器上是主线程）的runloop中，周期性的调用JS的callFunctionReturnFlushedQueue方法，这个方法的作用就是从一个MessageQueue中取出消息内容。JS调用OC方法，会将调用的信息（moduleID、methodID、params）保存在这个MessageQueue中。\n\n\n这里需要说明一下：测试发现，在模拟器中，JS线程与Native端使用RCTSRWebSocketExecutor来进行通信，在真机上，使用RCTJSCExecutor来执行js脚本，在RCTJSCExecutor中可以看到对它的说明**Uses a JavaScriptCore context as the execution engine.**。\n\n回到刚才的话题，调用callFunctionReturnFlushedQueue之后，会从MessageQueue取出调用信息，已json字符串的形式返回给native端，native端通过RCTJSONParse接口parse出调用信息，信息包括模块id,方法id,参数,以及可能的回调id，格式如下：\n\n```\n<__NSCFArray 0x7f8bd1610e60>(\n\n//moduleIDs\n<__NSCFArray 0x7f8bd16c4ae0>(\n56,\n33,\n33,\n34\n)\n,\n\n//methodIDs\n<__NSCFArray 0x7f8bd16f0400>(\n1,\n5,\n4,\n0\n)\n,\n\n//params\n<__NSCFArray 0x7f8bd16396c0>(\n<__NSCFArray 0x7f8bd16f7d60>(\nws://localhost:8097/devtools,\n<null>,\n<null>,\n280\n)\n,\n<__NSCFArray 0x7f8bd163d350>(\n29,\nRCTView,\n1,\n<null>\n)\n,\n<__NSCFArray 0x7f8bd162e670>(\n7,\n<null>,\n<null>,\n<__NSCFArray 0x7f8bd16e4c90>(\n29\n)\n,\n<__NSCFArray 0x7f8bd16f0d90>(\n5\n)\n,\n<__NSCFArray 0x7f8bd1621a10>(\n5\n)\n)\n,\n<__NSCFArray 0x7f8bd16c7670>(\n5,\n2,\n3\n)\n\n)\n,\n//callID\n1171\n)\n\n```\n\n我们先来看下JS部分是如何创建这个队列以及将这些消息调用信息保存在队列中的。\n\n```\n//BatchedBridge.js\nconst BatchedBridge = new MessageQueue(\n  __fbBatchedBridgeConfig.remoteModuleConfig,\n  __fbBatchedBridgeConfig.localModulesConfig,\n);\n\n```\n前面提到过__fbBatchedBridgeConfig.remoteModuleConfig是Native端注册的模块，__fbBatchedBridgeConfig.localModulesConfig是JS本地模块。\n\n```\n//MessageQueue.js\nconstructor(remoteModules, localModules) {\n    this.RemoteModules = {};\n\n    this._callableModules = {};\n    this._queue = [[], [], [], 0];\n    this._moduleTable = {};\n    this._methodTable = {};\n    this._callbacks = [];\n    this._callbackID = 0;\n    this._callID = 0;\n    this._lastFlush = 0;\n    this._eventLoopStartTime = new Date().getTime();\n\n    [\n      'invokeCallbackAndReturnFlushedQueue',\n      'callFunctionReturnFlushedQueue',\n      'flushedQueue',\n    ].forEach((fn) => this[fn] = this[fn].bind(this));\n\n    let modulesConfig = this._genModulesConfig(remoteModules);\n    \n    //构建模块信息\n    this._genModules(modulesConfig);\n    localModules && this._genLookupTables(\n      this._genModulesConfig(localModules),this._moduleTable, this._methodTable\n    );\n\n    this._debugInfo = {};\n    this._remoteModuleTable = {};\n    this._remoteMethodTable = {};\n    this._genLookupTables(\n      modulesConfig, this._remoteModuleTable, this._remoteMethodTable\n    );\n  }\n```\n里面调用this._genModules(modulesConfig);，最后会调到_genModule。\n\n```\n//config是module信息，包括模块名，导出方法名列表等，moduleID模块对应的id（这个ID就是模块在remoteModules数组中的索引）\n_genModule(config, moduleID) {\n    if (!config) {\n      return;\n    }\n\n    let moduleName, constants, methods, asyncMethods;\n    if (moduleHasConstants(config)) {\n      [moduleName, constants, methods, asyncMethods] = config;\n    } else {\n      [moduleName, methods, asyncMethods] = config;\n    }\n\n    let module = {};\n    methods && methods.forEach((methodName, methodID) => {\n      const methodType =\n        asyncMethods && arrayContains(asyncMethods, methodID) ?\n          MethodTypes.remoteAsync : MethodTypes.remote;\n      //构建方法信息\n      module[methodName] = this._genMethod(moduleID, methodID, methodType);\n    });\n    Object.assign(module, constants);\n\n    if (!constants && !methods && !asyncMethods) {\n      module.moduleID = moduleID;\n    }\n\n\t//构建的module信息保存在RemoteModules中\n    this.RemoteModules[moduleName] = module;\n    return module;\n  }\n```\n\n调用this._genMethod构建方法信息。\n\n```\n//module：模块ID,method：方法ID（是方法在方法名列表中的索引），type：\"remote，remoteAsync\"，区分是同步调用还是异步调用，异步调用用Promise实现\n  _genMethod(module, method, type) {\n    let fn = null;\n    let self = this;\n    if (type === MethodTypes.remoteAsync) {\n      fn = function(...args) {\n        return new Promise((resolve, reject) => {\n          self.__nativeCall(\n            module,\n            method,\n            args,\n            (data) => {\n              resolve(data);\n            },\n            (errorData) => {\n              var error = createErrorFromErrorData(errorData);\n              reject(error);\n            });\n        });\n      };\n    } else {\n      fn = function(...args) {\n        let lastArg = args.length > 0 ? args[args.length - 1] : null;\n        let secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n        let hasSuccCB = typeof lastArg === 'function';\n        let hasErrorCB = typeof secondLastArg === 'function';\n        hasErrorCB && invariant(\n          hasSuccCB,\n          'Cannot have a non-function arg after a function arg.'\n        );\n        let numCBs = hasSuccCB + hasErrorCB;\n        let onSucc = hasSuccCB ? lastArg : null;\n        let onFail = hasErrorCB ? secondLastArg : null;\n        args = args.slice(0, args.length - numCBs);\n        return self.__nativeCall(module, method, args, onFail, onSucc);\n      };\n    }\n    fn.type = type;\n    return fn;\n  }\n\n```\n\n这里我们可以看到，__nativeCall的调用被包装在一个function中，这个function作为first-classed Value被返回，已<key,value>的形式保存在module信息中。我们开看到，native调用的成功和失败回调函数也是在这里传入。\n\n至此，Native方法的调用映射表构建完成。下面是JS端网络接口的例子。\n\n```\nvar RCTNetworkingNative = require('NativeModules').Networking;\n\n/**\n * This class is a wrapper around the native RCTNetworking module.\n */\nclass RCTNetworking {\n\n  static sendRequest(query, callback) {\n    RCTNetworkingNative.sendRequest(query, callback);\n  }\n\n  static abortRequest(requestId) {\n    RCTNetworkingNative.cancelRequest(requestId);\n  }\n\n}\n\nmodule.exports = RCTNetworking;\n```\n\n可以看到，RCTNetworking最终调用的是Native映射表中的本地方法。\n\n\n我们继续来看__nativeCall的实现，这里很重要。\n\n```\n  __nativeCall(module, method, params, onFail, onSucc) {\n  \n  \t//(1)\n    if (onFail || onSucc) {\n      // eventually delete old debug info\n      (this._callbackID > (1 << 5)) &&\n        (this._debugInfo[this._callbackID >> 5] = null);\n\n      this._debugInfo[this._callbackID >> 1] = [module, method];\n      onFail && params.push(this._callbackID);\n      this._callbacks[this._callbackID++] = onFail;\n      onSucc && params.push(this._callbackID);\n      this._callbacks[this._callbackID++] = onSucc;\n    }\n\n    global.nativeTraceBeginAsyncFlow &&\n      global.nativeTraceBeginAsyncFlow(TRACE_TAG_REACT_APPS, 'native', this._callID);\n    this._callID++;\n\n\t//（2）\n    this._queue[MODULE_IDS].push(module);\n    this._queue[METHOD_IDS].push(method);\n    this._queue[PARAMS].push(params);\n\n\t//(3)\n    var now = new Date().getTime();\n    if (global.nativeFlushQueueImmediate &&\n        now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {\n      global.nativeFlushQueueImmediate(this._queue);\n      this._queue = [[], [], [], this._callID];\n      this._lastFlush = now;\n    }\n    Systrace.counterEvent('pending_js_to_native_queue', this._queue[0].length);\n    if (__DEV__ && SPY_MODE && isFinite(module)) {\n      console.log('JS->N : ' + this._remoteModuleTable[module] + '.' +\n        this._remoteMethodTable[module][method] + '(' + JSON.stringify(params) + ')');\n    }\n  }\n```\n\n代码说明：\n（1）往params中添加回调回调方法对应的id，可以看到，回调id保存在params数组最后，还会记录debug信息。\n（2）将native调用信息添加到MessageQueue，可以看到，MessageQueue的格式是`this._queue = [[], [], [], this._callID];`，moduleID、methodID和params分别被加入到MessageQueue中不同数组中，所以就看到了前面我们打印出来的Native端收到的数据格式。\n（3）如果是要求立即调用并且超时，则会调用global.nativeFlushQueueImmediate接口。这里我查找了下代码，js端和native端并没有为global.nativeFlushQueueImmediate，可见一般不会进入这个流程，一般还是使用前面介绍的Native定时驱动的方式来获取MessageQueue中的调用信息。但是，既然有这个值，说明是支持js主动调用到native端的，那又是如何实现的呢？\n\n在RCTJSCExecutor.m文件中的setUp方法，我们看到这样一段代码：\n\n```\n[self addSynchronousHookWithName:@\"nativeFlushQueueImmediate\" usingBlock:^(NSArray<NSArray *> *calls){\n    RCTJSCExecutor *strongSelf = weakSelf;\n    if (!strongSelf.valid || !calls) {\n      return;\n    }\n\n    RCT_PROFILE_BEGIN_EVENT(0, @\"nativeFlushQueueImmediate\", nil);\n    [strongSelf->_bridge handleBuffer:calls batchEnded:NO];\n    RCT_PROFILE_END_EVENT(0, @\"js_call\", nil);\n  }];\n\n```\n\n再看addSynchronousHookWithName的实现：\n\n```\n- (void)addSynchronousHookWithName:(NSString *)name usingBlock:(id)block\n{\n  __weak RCTJSCExecutor *weakSelf = self;\n  [self executeBlockOnJavaScriptQueue:^{\n    weakSelf.context.context[name] = block;\n  }];\n}\n\n```\n我们发现，这里是将native的方法挂到js解释器的全局上下文上，这样js端就可以直接调用这些native方法。除了nativeFlushQueueImmediate以外，还有其他一些全局方法。\n\n至此，我们看到了JS端如何调用组织数据发送给Native端，那Native端拿到数据之后是如何处理的呢？\n\n我跟踪了JS调用创建UIView的过程(通过hook UIView的initWithFrame方法，加断点进行测试)，其导出的Native方法在RCTUIManager.m中，方法签名如下：\n\n```\ncreateView:(nonnull NSNumber *)reactTag\n                  viewName:(NSString *)viewName\n                  rootTag:(__unused NSNumber *)rootTag\n                  props:(NSDictionary *)props\n```\n\n创建UIView的流程如下：\nNative端接收到数据，传给RCTBatchedBridge.m中的handleBuffer函数处理，从中解析出多组信息，每组信息包括模块id,方法id,参数,以及可能的回调id，用匿名block将每组信息包起来（这里我们取个名叫block1），放到moduleID所对应的RCTModuleData的methodQueue中异步执行，RCTModuleData是对module示例的包装，methodQueue是由module实例返回，由于iOS对UI的操作一般需要放在这线程，所以可以看到，UI相关的module的method的queue的实现返回的都是主线程：\n\n```\n//RCTActionSheet.m\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_get_main_queue();\n}\n\n```\n\n同时，还会往methodQueue中添加匿名block（这里我们取个名叫block2）的异步操作。block1执行时，首先根据moduleID在全局表中查找到对应的Module（RCTModuleData，ModuleData的创建会根据前面提到的RCTModuleClasses中的Class一一对应创建，保存在RCTBatchedBridge.m中的`NSArray<RCTModuleData *> *_moduleDataByID;`中），然后再根据methodID在Module中找到相应的方法RCTBridgeMethod（RCTBridgeMethod是对native方法的封装，内部会持有一个NSInvocation），为内部的_invocation设置参数并调用。这时实际调用的就是我们导出的Natvie方法了（也就是前面的createView: viewName:rootTag:props:），他会将创建UI的操作再次封装成一个个block（这里我们取个名叫block3），放到一个集合`NSMutableArray<dispatch_block_t> *_pendingUIBlocks;`中，当block2执行时，会从_pendingUIBlocks中逐个取出block3并执行，从而创建出相应的Natvie UI。\n\n如果调用Natvie之后，JS端需要CallBack被调用，会将CallBackID通过参数传给Native，Native函数执行完成之后，会通过发送json字符串的形式发送给JS调用结果，其中会带上CallBackID以及此次发送消息的ID。\n\n\n在查看ReactNative源码之前，本以为JS与OC之前的通信是通过利用JavaScriptCore进行JSBinding这种静态绑定的方式，查看源码之后才发现不是这样。通过上面对源码的分析，可以看到，RN自己实现以一套通信模式，JS与OC之间的调用采用动态查找的方式来实现，JS和Native工作于独立的线程，线程间根据一套基于ID映射协议的方式来进行通信，这样的动态查找的方式通信成本会高一些，为什么没有用JSBinding的方式，个人理解主要有一下两点原因。\n\n 1. ReactNative 的目标是跨平台，并不是所有平台都采用JavaScriptCore引擎，另外，iOS7之前 JavaScriptCore也没有开发出来。\n 2. ReactNative 的 JS 代码工作在独立线程（非主线程），如果采用静态绑定的方式，无法或者很难保证对UI的操作工作在主线程。\n\n### 性能测试\n\n(1)Native\n\n![](移动端混合编程/p-native.gif)\n\n\n(2)ReactNative\n\n![](移动端混合编程/p-rn.gif)\n\n\n性能测试采用 RN v0.38.0，测试环境：iphone6,iOS9.3.2，测试用例，点击‘GO’按钮，push(带动画)一个新页面，新页面包含一个列表，首屏展示6项，向上滑动，总共展示20项，列表使用的数据是本地数据。测试数据如下，其中\n\n* 响应时间：从点击button开始构建页面，到页面完全构建完成（viewDidAppear）的时间\n* 页面构建内存开销：从点击button开始构建页面，到页面构建完成内存的增量\n* 页面滚动之后内存开销：向下滑动，加载所有的cell之后的内存增量\n\n\n\n|测试数据|响应时间(ms)|页面构建内存开销(MB)|页面滚动之后内存开销(MB)|\n|:--:|:--:|:--:|:--:|\n|React Native|831|2.56|0.50|\n|Native|555|1.29|1.36|\n\n从体验上点击响应的顺滑程度明显native要顺滑很多，从上面的gif图中也可以看出。另外，内存开销上RN首屏列表开销明显高于Native。这里需要补充说明：React Native的ListView并不是使用UITableView实现，而是自己采用UIView实现的，这一点可以从视图层级中看出，如下图：\n\n![](移动端混合编程/reactnative-scrollview.png)\n\nListView的缓存策略也是自己做的，从[这里](https://github.com/facebook/react-native/issues/499)得知，React Native的ListView的\"Cell\"每次都是重新创建，之所以这么做原因是RN认为UITableView\n的复用存在“脏数据”的问题，而且，在现在的手机设备上，创建新的cell已经足够快。当\"Cell\"划出屏幕，相应的“Cell”会被从view tree上取下来，但并不会销毁，只有当内存警告或者列表项太多时，会有Cell的销毁工作，下次使用，再重新构建出来。\n\n其实，ListView在RN中无法用UITableView实现，原因是，如前面所介绍，JS对Native的调用是异步操作，而且消息派发的驱动是Native端做的，试想一下，如果采用UITableView来做，在列表页快速滚动的时候，JS端是不能立刻同步获取下一个Cell来展示的。RN现在的实现方式是用ScrollView来实现，并且会预先创建若干个Cell来用户快速滑动时，下一个Cell的展示。测试发现，对于DataSource有20个数据，首屏只能显示6个cell的情况下，Native端首屏会创建6个cell，总共会创建7个（缓速的滑动）；React Native首屏会创建17个cell（用于快速滑动展示而预创建），总共会创建20个。\n\n优点：\n\n* JS与native的异步通信，脚本不会卡住主线程\n* 原生的控件+原生的体验\n* 热调试能力\n\n缺点：\n\n* JS与native的异步通信\n* 门槛较高\n* 仅面向React前端开发\n\n## samurai-native\n\nsamurai-native的思路跟ReactNatvie的思路是一样的，也是将native的接口导给web端使用，而界面的渲染采用natvie控件，它与RN区别主要有两点：\n\n(1)表达语法是HTML+CSS;\n\n(2)标签名称与Native的View的名称对应，RN中由于对标签进行了抽象，有些标签与Native类名称上并不能对应，React Native书写一个tableview cell如下，可以看出，和原生的写法的命名有差异。\n\n```\n<TouchableHighlight onPress={() => this.rowPressed(rowData.guid)}\n                underlayColor='#dddddd'>\n              <View>\n                <View style={styles.rowContainer}>\n                  <Image style={styles.thumb} source={{ uri: rowData.img_url }} />\n                  <View  style={styles.textContainer}>\n                    <Text style={styles.price}>£{price}</Text>\n                    <Text style={styles.title}\n                          numberOfLines={1}>{rowData.title}</Text>\n                  </View>\n                </View>\n                <View style={styles.separator}/>\n              </View>\n            </TouchableHighlight>\n```\n\n关于samurai-native的介绍可以参考他在infoq上的[演讲](http://www.infoq.com/cn/presentations/semi-hybrid-app-framework)。\n\n\n\n\n\n\n\n","source":"_posts/ios/移动端混合编程/移动端混合编程.md","raw":"---\ntitle: 聊聊移动端那些混合开发框架们\n\ndate: 2016-12-02\n\ncategory: ios\n\nlist_number: true \n\nauthor: 张建伟\n\ntags: \n- 混合开发框架\n\n---\n本文主要介绍笔者前些日子对市面上一些移动端混合编程方案的实现方式上的调研，读者可以据此了解移动端目前常见的一些混合开发框架的实现原理，欢迎读者在本文基础上做更深入的探索和调研，如有纰漏，欢迎指正。<!-- more -->\n\n本文示例代码链接: <https://github.com/jackwee/hybrid-demos>\n\n# 前言\n\n* 2008年，HTML5发布首个版本。\n\n* 2011年，Facebook开展[Spartan](http://techcrunch.com/2011/06/15/facebook-project-spartan/)项目，企图用HTML5的思想武装自己，占领iOS的浏览器，以此来与苹果抗衡。因为浏览器是相对开放的，Apple总不可能在浏览器端设置一个开关对网页内容进行限制。\n\n* 2012年，Mark Zuckerberg:\"the biggest mistake that we made as a company is betting too much on HTML5 as opposed to native.\"Facebook放弃HTML5，转投Native。\n* 2015年，Facebook发布react-native。\n\n如今，混合开发的呼声越来越高，世面上也有很多混合开发框架，采用混合开发的应用也是越来越多。\n\n以下将从什么是混合开发、为什么要做混合开发、移动端都在怎么做混合开发来做逐步介绍。\n\n--------\n\n<font color=#CC0033 size=6px>What?</font>\n\n两种或两种以上的程序设计语言的邂逅。\n\n* JNI:Java与C/C++的混合开发\n* iOS中Objective-C与C、Swift与C的混合开发\n* ReactNative中JavaScript与Native语言的混合开发\n\n本文介绍和调研的主要是移动平台上WEB(WebView、JavaScript)与Native语言的混合开发。\n\n\n<font color=#CC0033 size=6px>Why?</font>\n\n# Web & Native\n\n|对比|Web|Native|\n|:---:|:---:|:---:|\n|优势|跨平台、开发效率高、方便调试、方便部署|性能体验好、访问Low API、强大的IDE、原生的动画、系统手势|\n|存在问题|性能问题、浏览器兼容性问题、访问Low API受限、需要模拟原生动画和手势|平台依赖性强、调试不便、应用更新周期长、开发效率低|\n\n混合编程就是为了将两者的优点结合起来，做到“兼得🐟和🐻👐”。\n\n\n\n<font color=#CC0033 size=6px>How?</font>\n\n# 那些混合编程们\n\n目前移动端主流的混合开发有两个流派，一个是基于WebView做混合开发的Hybrid流派，一个是基于虚拟机做混合开发的'JavaSciptBridge'流派。\n\n1. WebViewBridge流派(Hybrid流派):基于WebView做与Native语言的混合开发\n\t* [PhoneGap](http://phonegap.com/) / [Cordova](https://cordova.apache.org)\n\t* [SuperWebView](http://www.apicloud.com/superwebview)\n\t* [5+Runtime & Native.js](http://dcloud.io/runtime.html#toDownload)\n2. 'JavaScipt Bridge'流派(JSBinding,LuaBinding,自定义消息传递):基于脚本语言本身做与Native语言的混合开发\n\t* [Titanium](http://www.appcelerator.com/mobile-app-development-products/)\n\t* [ReactNative](https://facebook.github.io/react-native/)\n\t* [samurai-native](https://github.com/hackers-painters/samurai-native)\n\n另外，还有翻译流派，如[J2ObjC](http://j2objc.org/)将Java语言翻译成Objective-C，编译流派，如[Xamarin](http://xamarin.com/)直接C#编译为二进制文件来开发iOS应用，这两种做法相对比较小众，本文并不做探讨。\n\n## PhoneGap/Cordova\n\n`PhoneGap: \"Write Once, Run Anywhere\"。`\n\n目标是让使用者编写一套代码来实现跨平台操作，它是Hybrid技术的一种实现，赋予WebView访问Native API的能力，屏蔽掉平台相关API实现跨平台开发。\n\n![](移动端混合编程/Cordova.png)\n\n上图是Cordova的架构图，其中Web App部分是前端开发部分，在WebView上执行。Cordova Plugins是Cordova所提供的用于访问本地代码的插件，这些插件具有操作本地资源的能力，如定位、陀螺仪、相机、联系人等等，此外，用户也可以自定义插件，js代码部分可以通过Cordova Native APIs来访问这些插件。那么这里对插件的调用实际是怎么实现的？\n\n我们使用一个简单的demo进行测试。\n\nNative端定义了自定义插件MyHybridPlugin，其中定义了addBookmark方法，在html页面上点击按钮，我们通过cordova调用addBookmark。\n\n```\n(1)html\n//页面上添加点击事件处理\n<button id=\"bookmarkBtn\" onclick=\"app.addBookmark()\">Add a bookmark</button>\n\n<script type=\"text/javascript\" src=\"cordova.js\"></script>\n<script type=\"text/javascript\" src=\"js/index.js\"></script>\n\n(2)JavaScript(index.js)\nvar app = {\n    addBookmark: function() {\n        ...\n        cordova.exec(win, fail, \"MyHybridPlugin\", \"addBookmark\", [bookmark]);\n    }\n\n};\n\n(3)JavaScript(cordova.js)\n//添加消息到消息队列\ncommandQueue.push(JSON.stringify(command));\n\n(4)JavaScript(cordova.js)\n//通过iframe通知native\npokeNativeViaIframe();\n\n===>\nexecIframe = document.createElement('iframe');\nexecIframe.style.display = 'none';\nexecIframe.src = 'gap://ready';\ndocument.body.appendChild(execIframe);   \n\n(5)Objective-C\n//从js消息队列中取消息内容\nwebView:shouldStartLoadWithRequest:navigationType:\n[_commandQueue fetchCommandsFromJs];\n\n(6)JavaScript(cordova.js)\n//以json方式返回消息内容，包括callbackId\nnativeFetchMessages();\n \n(7)Objective-C\n//根据json内容查找对应的class和selector，并执行相应方法\n- (BOOL)execute:(CDVInvokedUrlCommand*)command\n\n(8)Objective-C\n//回调执行结果，带上callbackId\nsendPluginResult:callbackId:\n\n(9)JavaScript(cordova.js)\n//根据callbackId回调执行结果\niOSExec.nativeCallback();\n\n```\n通过调试发现，cordova是通过将js对native的方法调用信息，封装成一个UIL，并通过iframe的形式加载该url。native端通过UIWebViewDelegate的代理方法`webView:shouldStartLoadWithRequest:navigationType:`拦截url，并解析出其中的函数签名信息，通过oc的runtime查找对应的类和方法，实现了本地方法调用，并返回本次调用对应的callbackId，cordova会根据该id查找到对应的js回调方法，实现回调给js。\n\n优点：\n\n* 跨平台\n\n缺点：\n\n* 性能问题：从上面的分析可以看出js到native的调用流程比较繁琐\n* 对native工程师的依赖：前端工程师需要native开发来提供所需插件\n\n## SuperWebView\n\n`SuperWebView:能够帮助原生APP团队解决“如何在短时间内开发出体验好、功能强的HTML5页面”的问题`\n\nSuperWebView为web程序员开发App提供一套整体的解决方案，以SDK的方式提供使用（不开源），总结一下主要包括特点：\n\n* 管理平台提供上百种模块，平台可以根据用户选取组合的模块构建生成SDK，开发者下载使用放到项目中使用\n* 支持用户自定义模块，导出给js使用，需要构建静态库，并打包成zip上传到管理平台，由平台编译生成sdk\n* 利用管理平台，可以进行资源包的热更新\n* 系统API对象提供的JS接口，可以在使用JS进行以下操作：获取系统属性、系统事件、使用进行封装了的接口\n* 提供云API来进行：操作云端数据、统计、推送、短信验证等功能\n* 提供与腾讯X5浏览器的集成（Android）\n\n下面是SuperWebView的架构图：\n\n![](移动端混合编程/superwebview.png)\n\n先看右侧部分，上面是SuperWebView提供的页面组织结构，用户可以利用API对象提供的接口创建界面，用户可以创建window（整个界面），frame（界面中的模块界面），frameGroup（一组可以左右滑动浏览的界面），UIModule（native自定义视图）；右侧下面部分是SuperWebView提供的基础服务，并提供了与Native通信的机制；左侧部分是SuperWebView平台已模块的形式提供的可以供JS使用的Native模块单元，官网上有模块管理平台提供了模块可以供开发者使用，开发者也可以根据平台标准自定义模块。\n\n\n下面是使用SuperWebView实现的模拟网易云音乐的一个demo示例：\n\n![](移动端混合编程/superwebview.gif)\n\n主页面的层级结构：\n\n![](移动端混合编程/superwebview2.png)\n\n可以看到，应用界面可以由多个APIWebView与UIView（或其子类）组合而来，但是这些组合关系并不需要web端开发者来操心，可以借助平台api对象开放的接口调用，平台接口会构建出相应界面的的组合，例如,可以使用下面这样的方式打开一个可以左右滑动的多个页面组合而成的页面，其构建的界面结果就是UIScrollView中横向放置了四个页面，可以左右滑动翻页浏览。\n\n```\napi.openFrameGroup({\n        name: 'framegroup01',\n        background: '#FFF',\n        scrollEnabled: true,\n        rect: {\n            x: 0,\n            y: firstHeaderOffset.h + firstHeaderIndexHeight,\n            w: \"auto\",\n            h: api.frameHeight - firstHeaderOffset.h - firstHeaderIndexHeight - footerPos.h\n        },\n        index: 0,\n        frames: [{\n            name: 'frame01_recommand',\n            url: './html/first_frame/frame01_recommand.html',\n            bounces: false,\n        }, {\n            name: 'frame01_list',\n            url: './html/first_frame/frame01_list.html',\n            bounces: true,\n        }, {\n            name: 'frame01_radio',\n            url: './html/first_frame/frame01_radio.html',\n            bounces: false,\n        }, {\n            name: 'frame01_rank',\n            url: './html/first_frame/frame01_rank.html',\n            bounces: false,\n        }]\n    }, function(ret) {\n        setFrameGroupStatus(ret.index);\n    });\n```\n\n我们来看看APIWebView的真面目。\n\n```\n@interface APIWebView : UZWebView\n@interface UZWebView : UIWebView\n```\n我们看到，APIWebView实际是UIWebView的子类，整个页面结构使用APIWebView嵌套的方式构建。\n\n* 通过Instruments在iPhone5s上进行内存测试，对前面云音乐demo反复操作，累计创建11个APIWebView，内存开销在35M左右(创建11个UIWebView，并加载本地类似静态页面内存开销在24M左右)。\n* 通过对APIWebView的构造方法initWithFrame:和dealloc方法进行拦截，发现在打开新页面是通过[UZWebViewController loadWindow]和[UZWebViewController openFrame:]创建多个APIWebView，再结合Native控件，构建出页面。\n\nSuperWebView的用户通过对页面结构进行拆分，利用SuperWebView提供的API来构建页面，SuperWebView所提供的API会构建出相应的页面结构，例如上面云音乐demo中的首页面，就是由2个APIWebView和一个UIScrollView嵌套组合而成。至于界面的样式，需要用户用HTML+CSS进行描述。\n\n### SuperWebView中JS与Native通信的实现原理\n\n下面分析下SuperWebView的实现JS与Native的通信机制。\n\n测试环境：iPhone5S,iOS8.3和iPhone4S,iOS7.1.1\n\n我们在JS端调用`alert(\"alert from js\");`接口，利用远程调试进行断点跟踪。\n\n```\n//alert的实现\nfunction (msg) {\n\t!function(msg){\n\t\tif(msg===null){\n\t\t\tmsg='null'\n\t\t};\n\t\tif(msg===undefined){\n\t\t\tmsg='undefined'\n\t\t};\n\t\tmsg=msg.toString();\n\t\tapi.alert({title:'index.html',msg:msg,buttons:['好']});\n\t}(msg);\n}\n```\n\n```\n//api.alert的实现\nfunction () {\n\treturn uz$e('UZAPI','alert',arguments,false,'api');\n}\n```\n\n```\n///uz$e的实现\nfunction uz$e(c, m, p, isSync, module) {\n    var param = {};\n    \n    //(1)\n    if (p.length === 1) {\n        var p0 = p[0];\n       //(1.1)\n\t\tif (Object.prototype.toString.call(p0) === \"[object Object]\") {\n            param = p0;\n        } else if (typeof p0 === \"function\") {\n            param.cbId = uz$cb.id++;\n            uz$cb.fn[param.cbId] = p0;\n        }\n    } else if (p.length === 2) {\n    \t//(1.2)\n        var p0 = p[0];\n        var p1 = p[1];\n        if (Object.prototype.toString.call(p0) === \"[object Object]\") {\n            param = p0;\n        }\n        if (typeof p1 === \"function\") {\n            param.cbId = uz$cb.id++;\n            uz$cb.fn[param.cbId] = p1;\n        }\n\t}\n\t\n\t//（2）\n    if (typeof(_apiBridgeMethod)==='function'){\n    \t //(2.1)\t\n        return _apiBridgeMethod(c, m, param, isSync, module);\n    } else if (api.useWKWebView) {\n    \t //(2.2)\t\n        var message = {};\n        message.class = c;\n        message.method = m;\n        message.param = param;\n        message.isSync = false;\n        message.module = module;\n        window.webkit.messageHandlers.api.postMessage(message);\n    } else {\n    \t //(2.3)\t\n        uz$q.c.push(module+'.'+c+'.'+m+'/?'+encodeURIComponent(JSON.stringify(param)));\n        uz$r();\n    }\n}\n```\n\n对这段代码进行分析：\n\n（1）对参数进行处理\n\n(1.1) 只有一个参数，对调用参数或者回调函数分别处理\n \n(1.2) 有两个参数，对调用参数和回调函数分别处理\n\n（2）执行函数调用\n\n(2.1) 调用_apiBridgeMethod方法，在当前测试环境下，会走2.1的逻辑，其实现如下：\n\n```\nfunction () {\n    [native code]\n}\n\n```\n可以看到_apiBridgeMethod的方法体是native code，那么是如何将native code注册给WebView的JS解释器的呢？\n\n将APICloud.a中的UZWebView.o反编译出来伪代码看到如下实现:\n\n```\n// UZWebView - (void)initJavaScriptCoreBridgeMethod\nvoid __cdecl -[UZWebView initJavaScriptCoreBridgeMethod](struct UZWebView *self, SEL a2)\n{\n  struct UZWebView *v7; // r8@1\n  void *v8; // r0@1\n  void *v9; // r5@1\n  void *v10; // r0@1\n  void *v11; // r6@1\n  void *v13; // r0@2\n  void *v14; // r6@2\n  void *v15; // r0@2\n  int v16; // r4@2\n  void *v17; // r0@2\n  void *v18; // r5@2\n  int *v19; // r4@3\n  int v23; // [sp+0h] [bp-78h]@1\n  void *v24; // [sp+4h] [bp-74h]@3\n  void *v25; // [sp+8h] [bp-70h]@3\n  void *v26; // [sp+Ch] [bp-6Ch]@3\n  int v27; // [sp+10h] [bp-68h]@3\n  int v28; // [sp+14h] [bp-64h]@3\n  int (__fastcall *v29)(__block_literal_3 *, Foundation::NSString::NSString *, Foundation::NSString::NSString *, Foundation::NSDictionary::NSDictionary *, Foundation::NSString::NSString *, int); // [sp+18h] [bp-60h]@3\n  void *v30; // [sp+1Ch] [bp-5Ch]@3\n  int v31; // [sp+20h] [bp-58h]@1\n  char v32; // [sp+24h] [bp-54h]@3\n  int *v33; // [sp+28h] [bp-50h]@3\n  char v34; // [sp+2Ch] [bp-4Ch]@1\n  int v35; // [sp+30h] [bp-48h]@2\n  void *v36; // [sp+44h] [bp-34h]@1\n  void *v37; // [sp+48h] [bp-30h]@1\n  __int64 *v38; // [sp+4Ch] [bp-2Ch]@1\n  unsigned int v39; // [sp+50h] [bp-28h]@1\n  int *v40; // [sp+54h] [bp-24h]@1\n  char v41; // [sp+60h] [bp-18h]@5\n  __int64 savedregs; // [sp+78h] [bp+0h]@1\n\n  _R4 = (unsigned int)&v31 & 0xFFFFFFF0;\n  __asm\n  {\n    VST1.64         {D8-D11}, [R4@128]!\n    VST1.64         {D12-D15}, [R4@128]\n  }\n  v7 = self;\n  v8 = objc_msgSend(&OBJC_CLASS___UIDevice, \"currentDevice\");\n  v9 = (void *)objc_retainAutoreleasedReturnValue(v8);\n  v10 = objc_msgSend(v9, \"systemVersion\");\n  v11 = (void *)objc_retainAutoreleasedReturnValue(v10);\n  _R4 = objc_msgSend(v11, \"floatValue\");\n  objc_release(v11);\n  objc_release(v9);\n  v36 = &__objc_personality_v0;\n  v37 = &GCC_except_table117;\n  v38 = &savedregs;\n  v40 = &v23;\n  v39 = (((unsigned int)&loc_13E + 2) | 1) + 42164;\n  _Unwind_SjLj_Register(&v34);\n  __asm\n  {\n    VMOV.F32        D0, #7.0\n    VMOV            D1, R4, R4\n    VCMPE.F32       S2, S0\n    VMRS            APSR_nzcv, FPSCR\n  }\n  if ( !(_NF ^ _VF) )\n  {\n    v35 = -1;\n    v13 = objc_msgSend(v7, \"webView\");\n    v35 = -1;\n    v14 = (void *)objc_retainAutoreleasedReturnValue(v13);\n    v35 = -1;\n    v15 = objc_msgSend(v7, \"jsContextKeyPath\");\n    v35 = -1;\n    v16 = objc_retainAutoreleasedReturnValue(v15);\n    v35 = -1;\n    v17 = objc_msgSend(v14, \"valueForKeyPath:\", v16);\n    v35 = -1;\n    v18 = (void *)objc_retainAutoreleasedReturnValue(v17);\n    objc_release(v16);\n    if ( v18 )\n    {\n      v25 = v14;\n      objc_initWeak(&v32, v7);\n      v26 = &_NSConcreteStackBlock;\n      v27 = -1040187392;\n      v28 = 0;\n      v29 = _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke;\n      v33 = &v31;\n      v30 = &__block_descriptor_tmp_1135;\n      objc_copyWeak(&v31, &v32);\n      v23 = objc_retainBlock(&v26);\n      v35 = 1;\n      v24 = v18;\n      objc_msgSend(v18, \"setObject:forKeyedSubscript:\");\n      v19 = v33;\n      objc_release(v23);\n      objc_destroyWeak(v19);\n      objc_destroyWeak(&v32);\n      v14 = v25;\n      v18 = v24;\n    }\n    objc_release(v18);\n    objc_release(v14);\n  }\n  _Unwind_SjLj_Unregister(&v34);\n  _R4 = &v41;\n  __asm\n  {\n    VLD1.64         {D8-D11}, [R4@128]!\n    VLD1.64         {D12-D15}, [R4@128]\n  }\n}\n```\n\n这里我们可以看到，首先是利用KVC从UZWebView获得JSContext，然后setObject:forKeyedSubscript:设置_apiBridgeMethod的值为`_43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke`，它的实现如下：\n\n\n```\nint __fastcall _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke(\n__block_literal_3 *.block_descriptor, \nFoundation::NSString::NSString *a2, \nFoundation::NSString::NSString *method, \nFoundation::NSDictionary::NSDictionary *param, \nFoundation::NSString::NSString *module, \nint a6)\n{\n  Foundation::NSDictionary::NSDictionary *v7; // r5@1\n  Foundation::NSString::NSString *v8; // r4@1\n  int v9; // r10@1\n  int v10; // r4@1\n  void *v11; // r8@1\n  int v12; // r11@1\n  void *v13; // r2@1\n  int v14; // r0@2\n  void *v15; // r0@3\n  void *v16; // ST04_4@4\n  int v17; // r5@4\n  void *v18; // r0@4\n  void *v19; // r8@4\n  void *v20; // r4@4\n  void *v21; // r0@4\n  int v22; // r6@4\n  __block_literal_3 *v24; // [sp+8h] [bp-20h]@1\n\n  v24 = .block_descriptor;\n  v7 = param;\n  v8 = method;\n  v9 = objc_retain(a2);\n  v10 = objc_retain(v8);\n  v11 = (void *)objc_retain(v7);\n  v12 = objc_retain(a6);\n  v13 = objc_msgSend(&OBJC_CLASS___NSDictionary, \"class\");\n  if ( (unsigned int)objc_msgSend(v11, \"isKindOfClass:\", v13) & 0xFF )\n  {\n    v14 = objc_retain(v11);\n  }\n  else\n  {\n    v15 = objc_msgSend(&OBJC_CLASS___NSDictionary, \"dictionaryWithObjects:forKeys:count:\");\n    v14 = objc_retainAutoreleasedReturnValue(v15);\n  }\n  v16 = v11;\n  v17 = v14;\n  v18 = objc_msgSend(&OBJC_CLASS___UZCommand, \"alloc\");\n  v19 = objc_msgSend(v18, \"initWithClassName:methodName:param:\", v9, v10, v17);\n  objc_release(v10);\n  objc_release(v9);\n  objc_msgSend(v19, \"setIsSyncMethod:\", module);\n  objc_msgSend(v19, \"setModule:\", v12);\n  objc_release(v12);\n  v20 = (void *)objc_loadWeakRetained(&v24->weakSelf);\n  v21 = objc_msgSend(v20, \"execute:\", v19);\n  v22 = objc_retainAutoreleasedReturnValue(v21);\n  objc_release(v20);\n  objc_release(v19);\n  objc_release(v17);\n  objc_release(v16);\n  return objc_autoreleaseReturnValue(v22);\n}\n\n```\n\n大概意思是，读取调用信息，根据信息创建一个UZCommand对象，再去执行UZCommand，再看execute的实现：\n\n```\n// UZWebView - (id)execute:(id) \nid __cdecl -[UZWebView execute:](struct UZWebView *self, SEL a2, id a3)\n{\n  struct UZWebView *v3; // r11@1\n  void *v4; // r6@1\n  int v5; // r5@2\n  void *v6; // r0@3\n  int v7; // r10@3\n  void *v8; // r0@3\n  void *v9; // r8@3\n  void *v10; // r0@3\n  void *v11; // r0@3\n  void *v12; // r4@3\n  void *v13; // r0@3\n  int v14; // r5@3\n  void *v15; // r0@3\n  int v16; // r0@3\n  void *v17; // r6@3\n  void *v18; // r0@3\n  void *v19; // r5@3\n  int v20; // r10@4\n  void *v21; // r0@5\n  void *v22; // r4@5\n  void *v23; // r0@5\n  void *v24; // r0@5\n  void *v25; // r6@5\n  void *v26; // r0@5\n  void *v27; // r10@5\n  void *v28; // ST10_4@5\n  void *v29; // r4@5\n  void *v30; // r0@5\n  void *v31; // r0@5\n  int v32; // r4@5\n  void *v33; // r2@6\n  void *v34; // r0@7\n  void *v35; // r0@10\n  int v36; // r8@10\n  int v37; // r6@10\n  int v38; // r11@11\n  void *v39; // r0@12\n  void *v40; // r4@12\n  void *v41; // r0@13\n  int v42; // r4@13\n  void *v43; // r0@16\n  int v44; // r4@16\n  int v46; // [sp+18h] [bp-28h]@4\n  void *v47; // [sp+1Ch] [bp-24h]@10\n  int v48; // [sp+20h] [bp-20h]@3\n  void *v49; // [sp+24h] [bp-1Ch]@3\n\n  v3 = self;\n  v4 = (void *)objc_retain(a3);\n  if ( !((unsigned int)objc_msgSend(v3, \"shouldClosed\") & 0xFF) )\n  {\n    v6 = objc_msgSend(v4, \"methodName\");\n    v7 = objc_retainAutoreleasedReturnValue(v6);\n    v8 = objc_msgSend(v4, \"className\");\n    v9 = (void *)objc_retainAutoreleasedReturnValue(v8);\n    v10 = objc_msgSend(v4, \"paramDict\");\n    v48 = objc_retainAutoreleasedReturnValue(v10);\n    v11 = objc_msgSend(v3, \"request\");\n    v12 = (void *)objc_retainAutoreleasedReturnValue(v11);\n    v13 = objc_msgSend(v12, \"URL\");\n    v14 = objc_retainAutoreleasedReturnValue(v13);\n    v49 = v4;\n    v15 = objc_msgSend(v4, \"module\");\n    v16 = objc_retainAutoreleasedReturnValue(v15);\n    objc_release(v16);\n    v17 = v9;\n    objc_release(v14);\n    objc_release(v12);\n    v18 = objc_msgSend((void *)v3->_moduleDict, \"objectForKey:\", v9);\n    v19 = (void *)objc_retainAutoreleasedReturnValue(v18);\n    if ( !v19 )\n    {\n      v46 = v7;\n      v20 = NSClassFromString(v9);\n      if ( v20\n        || (v21 = objc_msgSend(&OBJC_CLASS___NSBundle, \"mainBundle\"),\n            v22 = (void *)objc_retainAutoreleasedReturnValue(v21),\n            v23 = objc_msgSend(v22, \"infoDictionary\"),\n            v24 = (void *)objc_retainAutoreleasedReturnValue(v23),\n            v25 = v24,\n            v26 = objc_msgSend(v24, \"stringValueForKey:defaultValue:\", CFSTR(\"CFBundleExecutable\"), &stru_12864),\n            v27 = (void *)objc_retainAutoreleasedReturnValue(v26),\n            v28 = v27,\n            objc_release(v25),\n            objc_release(v22),\n            v29 = objc_msgSend(v27, \"length\"),\n            v17 = v9,\n            v19 = 0,\n            v30 = objc_msgSend(v9, \"length\"),\n            v31 = objc_msgSend(&OBJC_CLASS___NSString, \"stringWithFormat:\", CFSTR(\"_TtC%lu%@%lu%@\"), v29, v27, v30, v9),\n            v32 = objc_retainAutoreleasedReturnValue(v31),\n            v20 = NSClassFromString(v32),\n            objc_release(v32),\n            objc_release(v28),\n            v20) )\n      {\n        v33 = objc_msgSend(&OBJC_CLASS___UZModule, \"class\");\n        if ( (unsigned int)objc_msgSend((void *)v20, \"isSubclassOfClass:\", v33) & 0xFF )\n        {\n          v34 = objc_msgSend((void *)v20, \"alloc\");\n          v19 = objc_msgSend(v34, \"initWithUZWebView:\", v3);\n        }\n      }\n      if ( !v19 )\n      {\n        v43 = objc_msgSend(&OBJC_CLASS___NSString, \"stringWithFormat:\", CFSTR(\"ERROR: Module '%@' not found\"), v17);\n        v44 = objc_retainAutoreleasedReturnValue(v43);\n        objc_msgSend(v3, \"sendErrorEvent:\", v44);\n        NSLog(CFSTR(\"%@\"), v44);\n        objc_release(v44);\n        v5 = 0;\n        v7 = v46;\n        v38 = v48;\n        goto LABEL_17;\n      }\n      objc_msgSend((void *)v3->_moduleDict, \"setObject:forKey:\", v19, v17);\n      v7 = v46;\n    }\n    v47 = v17;\n    v35 = objc_msgSend(&OBJC_CLASS___NSString, \"stringWithFormat:\", CFSTR(\"%@:\"), v7);\n    v36 = objc_retainAutoreleasedReturnValue(v35);\n    v37 = NSSelectorFromString();\n    if ( (unsigned int)objc_msgSend(v19, \"respondsToSelector:\", v37) & 0xFF )\n    {\n      v38 = v48;\n      if ( (unsigned int)objc_msgSend(v49, \"isSyncMethod\") & 0xFF )\n      {\n        v39 = objc_msgSend(v19, \"performSelector:withObject:\", v37, v48);\n        v40 = v19;\n        v5 = objc_retainAutoreleasedReturnValue(v39);\n        objc_release(v36);\n        objc_release(v40);\n        v17 = v47;\nLABEL_17:\n        objc_release(v38);\n        objc_release(v17);\n        objc_release(v7);\n        v4 = v49;\n        goto LABEL_18;\n      }\n      objc_msgSend(v19, \"performSelectorOnMainThread:withObject:waitUntilDone:\", v37, v48, 0);\n      v17 = v47;\n    }\n    else\n    {\n      v17 = v47;\n      v41 = objc_msgSend(\n              &OBJC_CLASS___NSString,\n              \"stringWithFormat:\",\n              CFSTR(\"ERROR: Method '%@' not defined in Module '%@'\"),\n              v7,\n              v47);\n      v42 = objc_retainAutoreleasedReturnValue(v41);\n      objc_msgSend(v3, \"sendErrorEvent:\", v42);\n      NSLog(CFSTR(\"%@\"), v42);\n      objc_release(v42);\n      v38 = v48;\n    }\n    objc_release(v36);\n    objc_release(v19);\n    v5 = 0;\n    goto LABEL_17;\n  }\n  v5 = 0;\nLABEL_18:\n  objc_release(v4);\n  return (id)objc_autoreleaseReturnValue(v5);\n}\n```\n\n主要流程是从UZCommand中读出模块，方法，参数等信息，根据类名创建了实例，然后调用初始化构造函数initWithUZWebView（这里和官网介绍[如何自定义模块](http://docs.apicloud.com/APICloud/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/module-dev-guide-for-ios)中的说明是一致的）,然后会判断是同步调用还是异步调用，同步调用则直接执行`performSelector:withObject:`，异步调用执行`performSelectorOnMainThread:withObject:waitUntilDone:`，至此，完成了JS到native方法的调用。\n\n(2.2)如果使用了WKWebView，则通过发送信息的方式将调用信息发给Native端。\n\n不过，目前SuperWebView暂未支持WKWebView，没有开放api和文档出来。\n\n(2.3)uz$q和uz$r的实现如下\n\n```\n//uz$q\n{c: Array[0], flag: true}\n\n//uz$r\nfunction uz$r() {\n    if(uz$q.flag && uz$q.c.length>0){\n        uz$q.flag = false;\n        window.location = 'uz://' + uz$q.c[0];\n\t}\n}\n```\n\n这里是将调用信息拼接成一个URL，scheme采用uz:，赋值给window.location赋值对当前页面重定向，这里应该是采用UIWebView的代理方式实现与Native端通信，会调用到`webView:shouldStartLoadWithRequest:navigationType:`代理方法中去，这种就是JSBridge的方式了。\n\n\n补充说明一点，从Native回调到JS端的方式是，通过`stringByEvaluatingJavaScriptFromString:`的方式，通知js端，并把callbackID作为参数回传过去。\n\n### 关于SuperWebView所指的混合渲染的说明\n\n看到混合渲染，第一理解是，SuperWebView支持将Native的View直接fix在UIWebView内部做渲染，这样做就需要修改webview的渲染机制，并且还要支持将css的解析映射到native view中去，通过官方文档和使用教程，并没有看到相关介绍。目前我的理解是，将Native的View作为子View添加到UIWebView中去。为了验证这一点，我们使用官网提供个UISlider模块来写示例代码，在JS中使用如下：\n\n```\nvar uislider = api.require('UISlider');\n            uislider.open({\n                animation: true,\n                orientation: 'horizontal',\n                rect: {\n                    x: 10,\n                    y: 100,\n                    size: 300\n                },\n                bubble: {\n                    direction: 'top',\n                    state: 'always',\n                    w: 80,\n                    h: 30,\n                    size: 14,\n                    color: '#888',\n                    bg: 'widget://res/slider/bubble.png',\n                    prefix: '温度：',\n                    suffix: '摄氏度'\n                },\n                handler: {\n                    w: 10,\n                    h: 8,\n                    bg: 'widget://res/slider/handler.png'\n                },\n                bar: {\n                    h: 4,\n                    bg: 'widget://res/slider/background.png',\n                    active: 'widget://res/slider/bar-active.png'\n                },\n                value: {\n                    min: 16,\n                    max: 32,\n                    step: 0.5,\n                    init: 26\n                },\n                fixedOn: api.frameName,\n                fixed: false\n            }, function(ret, err) {\n                if (ret) {\n                    alert(JSON.stringify(ret));\n                } else {\n                    alert(JSON.stringify(err));\n                }\n            });\n\n```\n\n打开的视图效果如下：\n\n![](./superwebview3.png)\n\n我们看到UISlider是悬浮在WebView之上的，那么我们可以猜测，其是通过在native构建并添加到WebView上的，这一点可以通过反编译了UISlider的目标文件，可以看到open方法的实现里面多次调用了addSubView方法。\n\n\n优点：\n\n* 性能好\n* 提供方便的api进行页面组合\n* 模块化平台，让更多的人为前端工程师服务\n* 管理平台：热更新，云数据等\n\n缺点：\n\n* 样式需要前端开发者去模拟native的样式\n* 有些系统级的动画暂不支持，如导航栏渐变动画\n\n\n## 5+Runtime & Native.js\n\n* 5+Runtime是对HTML5+规范的实现，除了支持标准HTML5外，还扩展了JavaScript对象plus，使得js可以调用各种浏览器无法实现或实现不佳的系统能力，设备能力如摄像头、陀螺仪、文件系统等，业务能力如上传下载、二维码、地图、支付、语音输入、消息推送等。编写一次，可跨平台运行。\n* 大量的手机OS的原生API无法被HTML5使用，Native.js把原生API封装成了js对象，通过js可以直接调ios和android的原生API。这部分就不再跨平台，写法分别是plus.ios和plus.android。\n* Native.js不是一个js库，不需要下载引入到页面的script中，也不像nodejs那样有单独的运行环境，Native.js的运行环境是集成在5+runtime里的。\n\n使用方式：\n\n* 对于web端开发者，使用HBuilder IDE，它集成了5+Runtime和Native.js，可以创建移动项目来开发App\n* 对于Native端开发者，可以从平台下载SDK集成到项目中使用\n\n看到5+runtime说是[开源](http://weibo.com/p/1001603806548597059383)了,不过在[开源项目](https://github.com/dcloudio/H5P.Core)中并未找到iOS native的代码实现，其中还是以静态库的形式提供，不过在pdr.js文件中，看到了plus.tools和plus.bridge的实现，这两个实现在后文中会使用到。\n\n\n### Native.js通信方式实现分析\n\n下面以使用iOS中的UIAlertView为示例。\n\niOS端使用UIAlertView的代码如下：\n\n```\n#import <UIKit/UIKit.h>\n//...\n// 创建UIAlertView类的实例对象\nUIAlertView *view = [UIAlertView alloc];\n// 设置提示对话上的内容\n[view initWithTitle:@\"自定义标题\" // 提示框标题\n    message:@\"使用NJS的原生弹出框，可自定义弹出框的标题、按钮\" // 提示框上显示的内容\n    delegate:nil // 点击提示框后的通知代理对象，nil类似js的null，意为不设置\n    cancelButtonTitle:@\"确定(或者其他字符)\" // 提示框上取消按钮的文字\n    otherButtonTitles:nil]; // 提示框上其它按钮的文字，设置为nil表示不显示\n// 调用show方法显示提示对话框，在OC中使用[]语法调用对象的方法\n[view show];\n```\n\nJS端使用UIAlertView的方式如下：\n\n```\n\t// 创建UIAlertView类的实例对象\n\tvar view = new UIAlertView();\n\t// 设置提示对话上的内容\n\tview.initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles(\"自定义标题\" // 提示框标题\n\t\t, \"使用NJS的原生弹出框，可自定义弹出框的标题、按钮\" // 提示框上显示的内容\n\t\t, null // 操作提示框后的通知代理对象，暂不设置\n\t\t, \"确定(或者其他字符)\" // 提示框上取消按钮的文字\n\t\t, null ); // 提示框上其它按钮的文字，设置为null表示不显示\n\t// 调用show方法显示提示对话框\n\tview.show();\n\n```\n\n其中UIAlertView、initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles和show的实现如下：\n\n```\nwindow.plus.ios.UIAlertView = function(create) {\n        this.__UUID__ = window.plus.tools.UUID('JSB');\n        this.__TYPE__ = 'JSBObject';\n        var args = window.plus.ios.__Tool.process(arguments);\n        if ( create && plus.tools.IOS == plus.tools.platform ) {\n        \n        } else {\n            window.plus.bridge.execSync('Invocation', '__Instance', [this.__UUID__, 'UIAlertView', args]);\n        }\n    };\n    \n```\n\n```\nplus.ios.UIAlertView.prototype.initWithTitlemessagedelegatedefaultButtoncancelButtonotherButtons = function () {\n        var ret = null;\n        try {\n            var args = window.plus.ios.__Tool.process(arguments);\n            ret = window.plus.bridge.execSync('Invocation', '__exec', [this.__UUID__, 'initWithTitle:message:delegate:defaultButton:cancelButton:otherButtons:', args]);\n            ret = plus.ios.__Tool.New(ret, false);\n        } catch (e) {\n            throw e;\n        }\n        return ret;\n    };\n   \n```\n\n\n```\nplus.ios.UIAlertView.prototype.show = function () {\n        var ret = null;\n        try {\n            var args = window.plus.ios.__Tool.process(arguments);\n            ret = window.plus.bridge.execSync('Invocation', '__exec', [this.__UUID__, 'show', args]);\n            ret = plus.ios.__Tool.New(ret, false);\n        } catch (e) {\n            throw e;\n        }\n        return ret;\n    };\n\n```\n\n可以看到，我们创建的UIAlertView是一个JS对象，这个对象是当我们使用`UIAlertView = plus.ios.importClass(\"UIAlertView\");`时动态创建的JS对象，与Native的UIAlertView相对应，我们称该JS对象为NJS对象。我们对NJS对象UIAlertView进行的方法调用，最终会执行`window.plus.bridge.execSync`，我们需要看下它的实现，在此之前，关于通过NJS对象访问Native对象，先做一些说明。\n\n* 首次导入Native类对象时，Native.js会动态创建一个JS对象与之相对应，JS对象包括相应的构造函数、方法、父类(prototype)等信息。\n* 由于是动态创建对应的JS对象，这里有一定的性能损耗，[官方文档](http://ask.dcloud.net.cn/docs/#http://ask.dcloud.net.cn/article/88)中性能优化一节建议页面打开后触发的“plusready”事件中进行类对象的导入操作，这样提前导入了我们需要导入的类对象，是我们在后面逻辑中使用时保证其已经导入，这种方式只是将导入时机提前，并不是消除了导入带来的损耗。所以官方也不建议我们在一个页面中导入过多的类对象，这样会影响性能。\n* 数据类型转换：在NJS中调用Native API或从Native API返回数据到NJS时会自动转换数据类型。\n* Native类对象的方法会在JS对象中有份映射，方法名是native方法名去掉‘冒号’之后的名称（字母大小写不变）。\n* 对于映射的JS对象，可以通过“.”调用方式来访问native对象的属性，但这种方式获得的值是Native层对象被映射为NJS对象那一刻的属性值，如果需要实时获取和设置native对象属性值，需要使用plusGetAttribute和plusSetAttribute方法，但这种方式效率比较低。\n* Objective-C和Java中类如果存在继承自基类，在NJS中对应的对象会根据继承关系递归将所有基类的公有方法一一换成NJS对象的方法，所有基类的公有属性也可以通过其plusGetAttribute、plusSetAttribute方法访问。\n* 由于Objective-C中类没有静态变量，而是通过定义全局变量来实现，目前NJS中无法访问全局变量的值。对于全局常量，在NJS中也无法访问。\n\n\n继续之前的window.plus.bridge.execSync方法调用，其方法实现如下：\n\n```\nfunction (service,action,args,fn){\n    var json,sync,ret;\n    if(T.IOS==T.platform){\n        try{\n            if(json=T.stringify([[window.__HtMl_Id__,service,action,null,args]]),\n                sync=B.synExecXhr,\n                sync.open(\"post\",\"http://localhost:13131/cmds\",!1),\n                sync.setRequestHeader(\"Content-Type\",\"multipart/form-data\"),\n                sync.send(json),\n                fn)\n                return fn(sync.responseText)\n        }catch(e){\n            console.log(\"sf:\"+action+\"-\"+service)\n        }\n        return window.eval(sync.responseText)\n    }\n    return T.ANDROID==T.platform?\n        (ret=window.prompt(T.stringify(args),\"pdr:\"+T.stringify([service,action,!1])),fn?fn(ret):eval(ret))\n        :void 0\n}\n\n```\n\n其中：\n\n```\nT=plus.tools,\nB=plus.bridge\n\n```\n\nsynExecXhr的全称是“同步调用XML HTTP Request”，前面我们提到了plus.bridge的实现中我们可以看到：\n\n```\nsynExecXhr: new XMLHttpRequest()\n```\n\n可以看到，synExecXh实际是一个XMLHttpRequest对象，通过它最后将调用信息以http请求的方式发出去。我们在Native端利用oc-runtime hook住UIAlertView的构造函数，添加断点，可以看到调用栈如下图所示：\n\n![](5+.png)\n\n可以看到，JS调用到Native端通过DCAsycSocket以这种进程间通信的方式来实现，并且在非主线程完成。至此，我们可以得知，native.js中js与native端的通信是通过本地socket同步通信的方式完成的，完成调用之后，调用结果会以字符串的形式保存在`sync.responseText`中，js端再通过evaluate其中的字符串来得到返回结果。\n\n小结：5+runtime还是基于WebView来做事，属于hybrid流派，通过本地socket通信方式来实现JS与Native的混合调用，支持动态导入native类对象，进行实例化、方法调用、属性访问等操作，与一般的hybrid技术不同的是，不需要native工程师来提供模块或者插件来支持扩展js的能力，web工程是可以参考native的方法调用类似的方式（只需要简单的修改），实现对native对象的访问。同时5+runtime还提供了一些跨平台的通用组件，如摄像头、陀螺仪、文件系统等。使用native.js技术所需要注意的问题就是性能问题，动态导入和访问native对象以及数据类型转化需要付出一定的性能损耗代价，官方给出了一些建议来进行性能优化。另外，值得一提的是DCloud公司还用HTML5做了一套模拟Native UI的开源项目MUI，有兴趣可以参考[这里](https://github.com/dcloudio/mui).\n\n\n优点：\n\n * web端可以直接访问native的api，调用接口参考\n * 提供一套native样式库：MUI\n\n 缺点：\n\n * 与native交互性能有点弱\n\n## Titanium\n\nTitanium:\"Write in JavaScript, run native everywhere\".\n\nTitanium与PhoneGap不同，并不是基于WebView来做跨平台开发，属于JavaSciptBridge流派，关于它与PhoneGap的对比可以参考[这篇文章](http://www.appcelerator.com/blog/2012/05/comparing-titanium-and-phonegap/)。值得一提的是，Titanium的上层语言并没有采用HTML+CSS+ JavaScript，而是XML+JSON+JavaScript，这增加了一定的学习成本。\n\n## React Native\n\nReactNative:\"learn once，write anywhere\".\n\nReactNative和Titanium的思路很像，也抛弃了WebView，属于JavaSciptBridge流派。ReactNative用JavaScript编写程序，渲染的界面全部都是Natvie的。[React](https://facebook.github.io/react/)是前端的知名开发库，程序代码通过操作Virturl DOM来编写程序，React runtime负责操作和更新真正的DOM节点，而这个更新是通过diff做增量更新，这提高性能，ReactNative沿用了React的编程模型和更新模型。\n\nReactNative的JS运行在与应用主线程独立的线程，通过异步操作与Natvie接口通信，线程模型可以参考下图：\n\n![](移动端混合编程/reactnative.png)\n\nJS解释器可以运行于手机中的独立线程，也可以远程调试时运行在浏览器中，另外，I/O操作、图片解码、布局信息计算等其他一些消耗CPU的操作也可以放到独立线程中，iOS应用主线程用来操作UI控件和Native API访问，JS线程与UI主线程之间通过ReactNative桥接进行异步通信，实现JS与Objective-C之间的相互调用。\n\n![](移动端混合编程/reactnative2.png)\n\n### React Native通信机制源码分析\n\n源码分析基于React Native v0.23.1,不过下载了目前的最新版0.38.0调试了，实现方式大同小异。\n\nReact Native 的思路就是将Native方法导出给JS用，使得用户可以用JS编写程序，而采用原生控件构建构建应用。\nReact Native 导出以模块（Module）为单位，在程序启动时，加载需要注册到js中的module，挂到js解释器的__fbBatchedBridgeConfig变量上，格式如下：\n\n```\n{\"remoteModuleConfig\":[\n\n[\"RCTStatusBarManager\",\n\t[\"getHeight\",\"setStyle\",\"setHidden\",\"setNetworkActivityIndicatorVisible\"]],\n[\"RCTSourceCode\",\n\t{\"scriptURL\":\"http:\\/\\/localhost:8081\\/index.ios.bundle?platform=ios&dev=true&hot=true\"},\n\t[\"getScriptText\"],[0]]\n]\n```\nReact Native还在不断的迭代开发中，不同版本的实现方式可能不同，例如，在[React Native通信机制详解](http://blog.cnbang.net/tech/2698/)一文中介绍，Natvie模块的注册方式是通过在利用编译指令将需要导出的模块存储到执行文件的二进制DATA端，程序启动时再从中读取导出的模块信息，我使用的源码是v0.23.1版本，可以看到，需要bridge的模块需要使用`RCTRegisterModule`宏，其展开如下：\n\n```\n#define RCT_EXPORT_MODULE(js_name) \\\nRCT_EXTERN void RCTRegisterModule(Class); \\\n+ (NSString *)moduleName { return @#js_name; } \\\n+ (void)load { RCTRegisterModule(self); }\n```\n可以看到，bridge的模块在load方法中进行注册，注册的模块保存在RCTBridge.m的`static NSMutableArray<Class> *RCTModuleClasses;`全局静态变量中。模块中需要bridge的方法使用`RCT_EXPORT_METHOD`宏，默认情况下，使用OC方法的第一个分号之前的部分作为JS中的调用名称，例如模块ModuleName中，需要导出的方法`- (void)doSomething:(NSString *)aString withA:(NSInteger)a andB:(NSInteger)b`，需要写成\n\n```\nRCT_EXPORT_METHOD(doSomething:(NSString *)aString\n                   withA:(NSInteger)a\n                   andB:(NSInteger)b)\n { ... }\n```\n最终JS的调用形式是`NativeModules.ModuleName.doSomething`。\n\n\n应用启动时，会创建一个CADisplayLink添加到线程（真机上是JS线程，模拟器上是主线程）的runloop中，周期性的调用JS的callFunctionReturnFlushedQueue方法，这个方法的作用就是从一个MessageQueue中取出消息内容。JS调用OC方法，会将调用的信息（moduleID、methodID、params）保存在这个MessageQueue中。\n\n\n这里需要说明一下：测试发现，在模拟器中，JS线程与Native端使用RCTSRWebSocketExecutor来进行通信，在真机上，使用RCTJSCExecutor来执行js脚本，在RCTJSCExecutor中可以看到对它的说明**Uses a JavaScriptCore context as the execution engine.**。\n\n回到刚才的话题，调用callFunctionReturnFlushedQueue之后，会从MessageQueue取出调用信息，已json字符串的形式返回给native端，native端通过RCTJSONParse接口parse出调用信息，信息包括模块id,方法id,参数,以及可能的回调id，格式如下：\n\n```\n<__NSCFArray 0x7f8bd1610e60>(\n\n//moduleIDs\n<__NSCFArray 0x7f8bd16c4ae0>(\n56,\n33,\n33,\n34\n)\n,\n\n//methodIDs\n<__NSCFArray 0x7f8bd16f0400>(\n1,\n5,\n4,\n0\n)\n,\n\n//params\n<__NSCFArray 0x7f8bd16396c0>(\n<__NSCFArray 0x7f8bd16f7d60>(\nws://localhost:8097/devtools,\n<null>,\n<null>,\n280\n)\n,\n<__NSCFArray 0x7f8bd163d350>(\n29,\nRCTView,\n1,\n<null>\n)\n,\n<__NSCFArray 0x7f8bd162e670>(\n7,\n<null>,\n<null>,\n<__NSCFArray 0x7f8bd16e4c90>(\n29\n)\n,\n<__NSCFArray 0x7f8bd16f0d90>(\n5\n)\n,\n<__NSCFArray 0x7f8bd1621a10>(\n5\n)\n)\n,\n<__NSCFArray 0x7f8bd16c7670>(\n5,\n2,\n3\n)\n\n)\n,\n//callID\n1171\n)\n\n```\n\n我们先来看下JS部分是如何创建这个队列以及将这些消息调用信息保存在队列中的。\n\n```\n//BatchedBridge.js\nconst BatchedBridge = new MessageQueue(\n  __fbBatchedBridgeConfig.remoteModuleConfig,\n  __fbBatchedBridgeConfig.localModulesConfig,\n);\n\n```\n前面提到过__fbBatchedBridgeConfig.remoteModuleConfig是Native端注册的模块，__fbBatchedBridgeConfig.localModulesConfig是JS本地模块。\n\n```\n//MessageQueue.js\nconstructor(remoteModules, localModules) {\n    this.RemoteModules = {};\n\n    this._callableModules = {};\n    this._queue = [[], [], [], 0];\n    this._moduleTable = {};\n    this._methodTable = {};\n    this._callbacks = [];\n    this._callbackID = 0;\n    this._callID = 0;\n    this._lastFlush = 0;\n    this._eventLoopStartTime = new Date().getTime();\n\n    [\n      'invokeCallbackAndReturnFlushedQueue',\n      'callFunctionReturnFlushedQueue',\n      'flushedQueue',\n    ].forEach((fn) => this[fn] = this[fn].bind(this));\n\n    let modulesConfig = this._genModulesConfig(remoteModules);\n    \n    //构建模块信息\n    this._genModules(modulesConfig);\n    localModules && this._genLookupTables(\n      this._genModulesConfig(localModules),this._moduleTable, this._methodTable\n    );\n\n    this._debugInfo = {};\n    this._remoteModuleTable = {};\n    this._remoteMethodTable = {};\n    this._genLookupTables(\n      modulesConfig, this._remoteModuleTable, this._remoteMethodTable\n    );\n  }\n```\n里面调用this._genModules(modulesConfig);，最后会调到_genModule。\n\n```\n//config是module信息，包括模块名，导出方法名列表等，moduleID模块对应的id（这个ID就是模块在remoteModules数组中的索引）\n_genModule(config, moduleID) {\n    if (!config) {\n      return;\n    }\n\n    let moduleName, constants, methods, asyncMethods;\n    if (moduleHasConstants(config)) {\n      [moduleName, constants, methods, asyncMethods] = config;\n    } else {\n      [moduleName, methods, asyncMethods] = config;\n    }\n\n    let module = {};\n    methods && methods.forEach((methodName, methodID) => {\n      const methodType =\n        asyncMethods && arrayContains(asyncMethods, methodID) ?\n          MethodTypes.remoteAsync : MethodTypes.remote;\n      //构建方法信息\n      module[methodName] = this._genMethod(moduleID, methodID, methodType);\n    });\n    Object.assign(module, constants);\n\n    if (!constants && !methods && !asyncMethods) {\n      module.moduleID = moduleID;\n    }\n\n\t//构建的module信息保存在RemoteModules中\n    this.RemoteModules[moduleName] = module;\n    return module;\n  }\n```\n\n调用this._genMethod构建方法信息。\n\n```\n//module：模块ID,method：方法ID（是方法在方法名列表中的索引），type：\"remote，remoteAsync\"，区分是同步调用还是异步调用，异步调用用Promise实现\n  _genMethod(module, method, type) {\n    let fn = null;\n    let self = this;\n    if (type === MethodTypes.remoteAsync) {\n      fn = function(...args) {\n        return new Promise((resolve, reject) => {\n          self.__nativeCall(\n            module,\n            method,\n            args,\n            (data) => {\n              resolve(data);\n            },\n            (errorData) => {\n              var error = createErrorFromErrorData(errorData);\n              reject(error);\n            });\n        });\n      };\n    } else {\n      fn = function(...args) {\n        let lastArg = args.length > 0 ? args[args.length - 1] : null;\n        let secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n        let hasSuccCB = typeof lastArg === 'function';\n        let hasErrorCB = typeof secondLastArg === 'function';\n        hasErrorCB && invariant(\n          hasSuccCB,\n          'Cannot have a non-function arg after a function arg.'\n        );\n        let numCBs = hasSuccCB + hasErrorCB;\n        let onSucc = hasSuccCB ? lastArg : null;\n        let onFail = hasErrorCB ? secondLastArg : null;\n        args = args.slice(0, args.length - numCBs);\n        return self.__nativeCall(module, method, args, onFail, onSucc);\n      };\n    }\n    fn.type = type;\n    return fn;\n  }\n\n```\n\n这里我们可以看到，__nativeCall的调用被包装在一个function中，这个function作为first-classed Value被返回，已<key,value>的形式保存在module信息中。我们开看到，native调用的成功和失败回调函数也是在这里传入。\n\n至此，Native方法的调用映射表构建完成。下面是JS端网络接口的例子。\n\n```\nvar RCTNetworkingNative = require('NativeModules').Networking;\n\n/**\n * This class is a wrapper around the native RCTNetworking module.\n */\nclass RCTNetworking {\n\n  static sendRequest(query, callback) {\n    RCTNetworkingNative.sendRequest(query, callback);\n  }\n\n  static abortRequest(requestId) {\n    RCTNetworkingNative.cancelRequest(requestId);\n  }\n\n}\n\nmodule.exports = RCTNetworking;\n```\n\n可以看到，RCTNetworking最终调用的是Native映射表中的本地方法。\n\n\n我们继续来看__nativeCall的实现，这里很重要。\n\n```\n  __nativeCall(module, method, params, onFail, onSucc) {\n  \n  \t//(1)\n    if (onFail || onSucc) {\n      // eventually delete old debug info\n      (this._callbackID > (1 << 5)) &&\n        (this._debugInfo[this._callbackID >> 5] = null);\n\n      this._debugInfo[this._callbackID >> 1] = [module, method];\n      onFail && params.push(this._callbackID);\n      this._callbacks[this._callbackID++] = onFail;\n      onSucc && params.push(this._callbackID);\n      this._callbacks[this._callbackID++] = onSucc;\n    }\n\n    global.nativeTraceBeginAsyncFlow &&\n      global.nativeTraceBeginAsyncFlow(TRACE_TAG_REACT_APPS, 'native', this._callID);\n    this._callID++;\n\n\t//（2）\n    this._queue[MODULE_IDS].push(module);\n    this._queue[METHOD_IDS].push(method);\n    this._queue[PARAMS].push(params);\n\n\t//(3)\n    var now = new Date().getTime();\n    if (global.nativeFlushQueueImmediate &&\n        now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {\n      global.nativeFlushQueueImmediate(this._queue);\n      this._queue = [[], [], [], this._callID];\n      this._lastFlush = now;\n    }\n    Systrace.counterEvent('pending_js_to_native_queue', this._queue[0].length);\n    if (__DEV__ && SPY_MODE && isFinite(module)) {\n      console.log('JS->N : ' + this._remoteModuleTable[module] + '.' +\n        this._remoteMethodTable[module][method] + '(' + JSON.stringify(params) + ')');\n    }\n  }\n```\n\n代码说明：\n（1）往params中添加回调回调方法对应的id，可以看到，回调id保存在params数组最后，还会记录debug信息。\n（2）将native调用信息添加到MessageQueue，可以看到，MessageQueue的格式是`this._queue = [[], [], [], this._callID];`，moduleID、methodID和params分别被加入到MessageQueue中不同数组中，所以就看到了前面我们打印出来的Native端收到的数据格式。\n（3）如果是要求立即调用并且超时，则会调用global.nativeFlushQueueImmediate接口。这里我查找了下代码，js端和native端并没有为global.nativeFlushQueueImmediate，可见一般不会进入这个流程，一般还是使用前面介绍的Native定时驱动的方式来获取MessageQueue中的调用信息。但是，既然有这个值，说明是支持js主动调用到native端的，那又是如何实现的呢？\n\n在RCTJSCExecutor.m文件中的setUp方法，我们看到这样一段代码：\n\n```\n[self addSynchronousHookWithName:@\"nativeFlushQueueImmediate\" usingBlock:^(NSArray<NSArray *> *calls){\n    RCTJSCExecutor *strongSelf = weakSelf;\n    if (!strongSelf.valid || !calls) {\n      return;\n    }\n\n    RCT_PROFILE_BEGIN_EVENT(0, @\"nativeFlushQueueImmediate\", nil);\n    [strongSelf->_bridge handleBuffer:calls batchEnded:NO];\n    RCT_PROFILE_END_EVENT(0, @\"js_call\", nil);\n  }];\n\n```\n\n再看addSynchronousHookWithName的实现：\n\n```\n- (void)addSynchronousHookWithName:(NSString *)name usingBlock:(id)block\n{\n  __weak RCTJSCExecutor *weakSelf = self;\n  [self executeBlockOnJavaScriptQueue:^{\n    weakSelf.context.context[name] = block;\n  }];\n}\n\n```\n我们发现，这里是将native的方法挂到js解释器的全局上下文上，这样js端就可以直接调用这些native方法。除了nativeFlushQueueImmediate以外，还有其他一些全局方法。\n\n至此，我们看到了JS端如何调用组织数据发送给Native端，那Native端拿到数据之后是如何处理的呢？\n\n我跟踪了JS调用创建UIView的过程(通过hook UIView的initWithFrame方法，加断点进行测试)，其导出的Native方法在RCTUIManager.m中，方法签名如下：\n\n```\ncreateView:(nonnull NSNumber *)reactTag\n                  viewName:(NSString *)viewName\n                  rootTag:(__unused NSNumber *)rootTag\n                  props:(NSDictionary *)props\n```\n\n创建UIView的流程如下：\nNative端接收到数据，传给RCTBatchedBridge.m中的handleBuffer函数处理，从中解析出多组信息，每组信息包括模块id,方法id,参数,以及可能的回调id，用匿名block将每组信息包起来（这里我们取个名叫block1），放到moduleID所对应的RCTModuleData的methodQueue中异步执行，RCTModuleData是对module示例的包装，methodQueue是由module实例返回，由于iOS对UI的操作一般需要放在这线程，所以可以看到，UI相关的module的method的queue的实现返回的都是主线程：\n\n```\n//RCTActionSheet.m\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_get_main_queue();\n}\n\n```\n\n同时，还会往methodQueue中添加匿名block（这里我们取个名叫block2）的异步操作。block1执行时，首先根据moduleID在全局表中查找到对应的Module（RCTModuleData，ModuleData的创建会根据前面提到的RCTModuleClasses中的Class一一对应创建，保存在RCTBatchedBridge.m中的`NSArray<RCTModuleData *> *_moduleDataByID;`中），然后再根据methodID在Module中找到相应的方法RCTBridgeMethod（RCTBridgeMethod是对native方法的封装，内部会持有一个NSInvocation），为内部的_invocation设置参数并调用。这时实际调用的就是我们导出的Natvie方法了（也就是前面的createView: viewName:rootTag:props:），他会将创建UI的操作再次封装成一个个block（这里我们取个名叫block3），放到一个集合`NSMutableArray<dispatch_block_t> *_pendingUIBlocks;`中，当block2执行时，会从_pendingUIBlocks中逐个取出block3并执行，从而创建出相应的Natvie UI。\n\n如果调用Natvie之后，JS端需要CallBack被调用，会将CallBackID通过参数传给Native，Native函数执行完成之后，会通过发送json字符串的形式发送给JS调用结果，其中会带上CallBackID以及此次发送消息的ID。\n\n\n在查看ReactNative源码之前，本以为JS与OC之前的通信是通过利用JavaScriptCore进行JSBinding这种静态绑定的方式，查看源码之后才发现不是这样。通过上面对源码的分析，可以看到，RN自己实现以一套通信模式，JS与OC之间的调用采用动态查找的方式来实现，JS和Native工作于独立的线程，线程间根据一套基于ID映射协议的方式来进行通信，这样的动态查找的方式通信成本会高一些，为什么没有用JSBinding的方式，个人理解主要有一下两点原因。\n\n 1. ReactNative 的目标是跨平台，并不是所有平台都采用JavaScriptCore引擎，另外，iOS7之前 JavaScriptCore也没有开发出来。\n 2. ReactNative 的 JS 代码工作在独立线程（非主线程），如果采用静态绑定的方式，无法或者很难保证对UI的操作工作在主线程。\n\n### 性能测试\n\n(1)Native\n\n![](移动端混合编程/p-native.gif)\n\n\n(2)ReactNative\n\n![](移动端混合编程/p-rn.gif)\n\n\n性能测试采用 RN v0.38.0，测试环境：iphone6,iOS9.3.2，测试用例，点击‘GO’按钮，push(带动画)一个新页面，新页面包含一个列表，首屏展示6项，向上滑动，总共展示20项，列表使用的数据是本地数据。测试数据如下，其中\n\n* 响应时间：从点击button开始构建页面，到页面完全构建完成（viewDidAppear）的时间\n* 页面构建内存开销：从点击button开始构建页面，到页面构建完成内存的增量\n* 页面滚动之后内存开销：向下滑动，加载所有的cell之后的内存增量\n\n\n\n|测试数据|响应时间(ms)|页面构建内存开销(MB)|页面滚动之后内存开销(MB)|\n|:--:|:--:|:--:|:--:|\n|React Native|831|2.56|0.50|\n|Native|555|1.29|1.36|\n\n从体验上点击响应的顺滑程度明显native要顺滑很多，从上面的gif图中也可以看出。另外，内存开销上RN首屏列表开销明显高于Native。这里需要补充说明：React Native的ListView并不是使用UITableView实现，而是自己采用UIView实现的，这一点可以从视图层级中看出，如下图：\n\n![](移动端混合编程/reactnative-scrollview.png)\n\nListView的缓存策略也是自己做的，从[这里](https://github.com/facebook/react-native/issues/499)得知，React Native的ListView的\"Cell\"每次都是重新创建，之所以这么做原因是RN认为UITableView\n的复用存在“脏数据”的问题，而且，在现在的手机设备上，创建新的cell已经足够快。当\"Cell\"划出屏幕，相应的“Cell”会被从view tree上取下来，但并不会销毁，只有当内存警告或者列表项太多时，会有Cell的销毁工作，下次使用，再重新构建出来。\n\n其实，ListView在RN中无法用UITableView实现，原因是，如前面所介绍，JS对Native的调用是异步操作，而且消息派发的驱动是Native端做的，试想一下，如果采用UITableView来做，在列表页快速滚动的时候，JS端是不能立刻同步获取下一个Cell来展示的。RN现在的实现方式是用ScrollView来实现，并且会预先创建若干个Cell来用户快速滑动时，下一个Cell的展示。测试发现，对于DataSource有20个数据，首屏只能显示6个cell的情况下，Native端首屏会创建6个cell，总共会创建7个（缓速的滑动）；React Native首屏会创建17个cell（用于快速滑动展示而预创建），总共会创建20个。\n\n优点：\n\n* JS与native的异步通信，脚本不会卡住主线程\n* 原生的控件+原生的体验\n* 热调试能力\n\n缺点：\n\n* JS与native的异步通信\n* 门槛较高\n* 仅面向React前端开发\n\n## samurai-native\n\nsamurai-native的思路跟ReactNatvie的思路是一样的，也是将native的接口导给web端使用，而界面的渲染采用natvie控件，它与RN区别主要有两点：\n\n(1)表达语法是HTML+CSS;\n\n(2)标签名称与Native的View的名称对应，RN中由于对标签进行了抽象，有些标签与Native类名称上并不能对应，React Native书写一个tableview cell如下，可以看出，和原生的写法的命名有差异。\n\n```\n<TouchableHighlight onPress={() => this.rowPressed(rowData.guid)}\n                underlayColor='#dddddd'>\n              <View>\n                <View style={styles.rowContainer}>\n                  <Image style={styles.thumb} source={{ uri: rowData.img_url }} />\n                  <View  style={styles.textContainer}>\n                    <Text style={styles.price}>£{price}</Text>\n                    <Text style={styles.title}\n                          numberOfLines={1}>{rowData.title}</Text>\n                  </View>\n                </View>\n                <View style={styles.separator}/>\n              </View>\n            </TouchableHighlight>\n```\n\n关于samurai-native的介绍可以参考他在infoq上的[演讲](http://www.infoq.com/cn/presentations/semi-hybrid-app-framework)。\n\n\n\n\n\n\n\n","slug":"ios/移动端混合编程/移动端混合编程","published":1,"updated":"2017-01-05T05:42:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixk0c24q000k7ekkq0t492es","content":"<p>本文主要介绍笔者前些日子对市面上一些移动端混合编程方案的实现方式上的调研，读者可以据此了解移动端目前常见的一些混合开发框架的实现原理，欢迎读者在本文基础上做更深入的探索和调研，如有纰漏，欢迎指正。<a id=\"more\"></a></p>\n<p>本文示例代码链接: <a href=\"https://github.com/jackwee/hybrid-demos\" target=\"_blank\" rel=\"external\">https://github.com/jackwee/hybrid-demos</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li><p>2008年，HTML5发布首个版本。</p>\n</li>\n<li><p>2011年，Facebook开展<a href=\"http://techcrunch.com/2011/06/15/facebook-project-spartan/\" target=\"_blank\" rel=\"external\">Spartan</a>项目，企图用HTML5的思想武装自己，占领iOS的浏览器，以此来与苹果抗衡。因为浏览器是相对开放的，Apple总不可能在浏览器端设置一个开关对网页内容进行限制。</p>\n</li>\n<li><p>2012年，Mark Zuckerberg:”the biggest mistake that we made as a company is betting too much on HTML5 as opposed to native.”Facebook放弃HTML5，转投Native。</p>\n</li>\n<li>2015年，Facebook发布react-native。</li>\n</ul>\n<p>如今，混合开发的呼声越来越高，世面上也有很多混合开发框架，采用混合开发的应用也是越来越多。</p>\n<p>以下将从什么是混合开发、为什么要做混合开发、移动端都在怎么做混合开发来做逐步介绍。</p>\n<hr>\n<font color=\"#CC0033\" size=\"6px\">What?</font>\n\n<p>两种或两种以上的程序设计语言的邂逅。</p>\n<ul>\n<li>JNI:Java与C/C++的混合开发</li>\n<li>iOS中Objective-C与C、Swift与C的混合开发</li>\n<li>ReactNative中JavaScript与Native语言的混合开发</li>\n</ul>\n<p>本文介绍和调研的主要是移动平台上WEB(WebView、JavaScript)与Native语言的混合开发。</p>\n<font color=\"#CC0033\" size=\"6px\">Why?</font>\n\n<h1 id=\"Web-amp-Native\"><a href=\"#Web-amp-Native\" class=\"headerlink\" title=\"Web &amp; Native\"></a>Web &amp; Native</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对比</th>\n<th style=\"text-align:center\">Web</th>\n<th style=\"text-align:center\">Native</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">优势</td>\n<td style=\"text-align:center\">跨平台、开发效率高、方便调试、方便部署</td>\n<td style=\"text-align:center\">性能体验好、访问Low API、强大的IDE、原生的动画、系统手势</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">存在问题</td>\n<td style=\"text-align:center\">性能问题、浏览器兼容性问题、访问Low API受限、需要模拟原生动画和手势</td>\n<td style=\"text-align:center\">平台依赖性强、调试不便、应用更新周期长、开发效率低</td>\n</tr>\n</tbody>\n</table>\n<p>混合编程就是为了将两者的优点结合起来，做到“兼得🐟和🐻👐”。</p>\n<font color=\"#CC0033\" size=\"6px\">How?</font>\n\n<h1 id=\"那些混合编程们\"><a href=\"#那些混合编程们\" class=\"headerlink\" title=\"那些混合编程们\"></a>那些混合编程们</h1><p>目前移动端主流的混合开发有两个流派，一个是基于WebView做混合开发的Hybrid流派，一个是基于虚拟机做混合开发的’JavaSciptBridge’流派。</p>\n<ol>\n<li>WebViewBridge流派(Hybrid流派):基于WebView做与Native语言的混合开发<ul>\n<li><a href=\"http://phonegap.com/\" target=\"_blank\" rel=\"external\">PhoneGap</a> / <a href=\"https://cordova.apache.org\" target=\"_blank\" rel=\"external\">Cordova</a></li>\n<li><a href=\"http://www.apicloud.com/superwebview\" target=\"_blank\" rel=\"external\">SuperWebView</a></li>\n<li><a href=\"http://dcloud.io/runtime.html#toDownload\" target=\"_blank\" rel=\"external\">5+Runtime &amp; Native.js</a></li>\n</ul>\n</li>\n<li>‘JavaScipt Bridge’流派(JSBinding,LuaBinding,自定义消息传递):基于脚本语言本身做与Native语言的混合开发<ul>\n<li><a href=\"http://www.appcelerator.com/mobile-app-development-products/\" target=\"_blank\" rel=\"external\">Titanium</a></li>\n<li><a href=\"https://facebook.github.io/react-native/\" target=\"_blank\" rel=\"external\">ReactNative</a></li>\n<li><a href=\"https://github.com/hackers-painters/samurai-native\" target=\"_blank\" rel=\"external\">samurai-native</a></li>\n</ul>\n</li>\n</ol>\n<p>另外，还有翻译流派，如<a href=\"http://j2objc.org/\" target=\"_blank\" rel=\"external\">J2ObjC</a>将Java语言翻译成Objective-C，编译流派，如<a href=\"http://xamarin.com/\" target=\"_blank\" rel=\"external\">Xamarin</a>直接C#编译为二进制文件来开发iOS应用，这两种做法相对比较小众，本文并不做探讨。</p>\n<h2 id=\"PhoneGap-Cordova\"><a href=\"#PhoneGap-Cordova\" class=\"headerlink\" title=\"PhoneGap/Cordova\"></a>PhoneGap/Cordova</h2><p><code>PhoneGap: &quot;Write Once, Run Anywhere&quot;。</code></p>\n<p>目标是让使用者编写一套代码来实现跨平台操作，它是Hybrid技术的一种实现，赋予WebView访问Native API的能力，屏蔽掉平台相关API实现跨平台开发。</p>\n<p><img src=\"移动端混合编程/Cordova.png\" alt=\"\"></p>\n<p>上图是Cordova的架构图，其中Web App部分是前端开发部分，在WebView上执行。Cordova Plugins是Cordova所提供的用于访问本地代码的插件，这些插件具有操作本地资源的能力，如定位、陀螺仪、相机、联系人等等，此外，用户也可以自定义插件，js代码部分可以通过Cordova Native APIs来访问这些插件。那么这里对插件的调用实际是怎么实现的？</p>\n<p>我们使用一个简单的demo进行测试。</p>\n<p>Native端定义了自定义插件MyHybridPlugin，其中定义了addBookmark方法，在html页面上点击按钮，我们通过cordova调用addBookmark。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1)html</div><div class=\"line\">//页面上添加点击事件处理</div><div class=\"line\">&lt;button id=&quot;bookmarkBtn&quot; onclick=&quot;app.addBookmark()&quot;&gt;Add a bookmark&lt;/button&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">(2)JavaScript(index.js)</div><div class=\"line\">var app = &#123;</div><div class=\"line\">    addBookmark: function() &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        cordova.exec(win, fail, &quot;MyHybridPlugin&quot;, &quot;addBookmark&quot;, [bookmark]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">(3)JavaScript(cordova.js)</div><div class=\"line\">//添加消息到消息队列</div><div class=\"line\">commandQueue.push(JSON.stringify(command));</div><div class=\"line\"></div><div class=\"line\">(4)JavaScript(cordova.js)</div><div class=\"line\">//通过iframe通知native</div><div class=\"line\">pokeNativeViaIframe();</div><div class=\"line\"></div><div class=\"line\">===&gt;</div><div class=\"line\">execIframe = document.createElement(&apos;iframe&apos;);</div><div class=\"line\">execIframe.style.display = &apos;none&apos;;</div><div class=\"line\">execIframe.src = &apos;gap://ready&apos;;</div><div class=\"line\">document.body.appendChild(execIframe);   </div><div class=\"line\"></div><div class=\"line\">(5)Objective-C</div><div class=\"line\">//从js消息队列中取消息内容</div><div class=\"line\">webView:shouldStartLoadWithRequest:navigationType:</div><div class=\"line\">[_commandQueue fetchCommandsFromJs];</div><div class=\"line\"></div><div class=\"line\">(6)JavaScript(cordova.js)</div><div class=\"line\">//以json方式返回消息内容，包括callbackId</div><div class=\"line\">nativeFetchMessages();</div><div class=\"line\"> </div><div class=\"line\">(7)Objective-C</div><div class=\"line\">//根据json内容查找对应的class和selector，并执行相应方法</div><div class=\"line\">- (BOOL)execute:(CDVInvokedUrlCommand*)command</div><div class=\"line\"></div><div class=\"line\">(8)Objective-C</div><div class=\"line\">//回调执行结果，带上callbackId</div><div class=\"line\">sendPluginResult:callbackId:</div><div class=\"line\"></div><div class=\"line\">(9)JavaScript(cordova.js)</div><div class=\"line\">//根据callbackId回调执行结果</div><div class=\"line\">iOSExec.nativeCallback();</div></pre></td></tr></table></figure>\n<p>通过调试发现，cordova是通过将js对native的方法调用信息，封装成一个UIL，并通过iframe的形式加载该url。native端通过UIWebViewDelegate的代理方法<code>webView:shouldStartLoadWithRequest:navigationType:</code>拦截url，并解析出其中的函数签名信息，通过oc的runtime查找对应的类和方法，实现了本地方法调用，并返回本次调用对应的callbackId，cordova会根据该id查找到对应的js回调方法，实现回调给js。</p>\n<p>优点：</p>\n<ul>\n<li>跨平台</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>性能问题：从上面的分析可以看出js到native的调用流程比较繁琐</li>\n<li>对native工程师的依赖：前端工程师需要native开发来提供所需插件</li>\n</ul>\n<h2 id=\"SuperWebView\"><a href=\"#SuperWebView\" class=\"headerlink\" title=\"SuperWebView\"></a>SuperWebView</h2><p><code>SuperWebView:能够帮助原生APP团队解决“如何在短时间内开发出体验好、功能强的HTML5页面”的问题</code></p>\n<p>SuperWebView为web程序员开发App提供一套整体的解决方案，以SDK的方式提供使用（不开源），总结一下主要包括特点：</p>\n<ul>\n<li>管理平台提供上百种模块，平台可以根据用户选取组合的模块构建生成SDK，开发者下载使用放到项目中使用</li>\n<li>支持用户自定义模块，导出给js使用，需要构建静态库，并打包成zip上传到管理平台，由平台编译生成sdk</li>\n<li>利用管理平台，可以进行资源包的热更新</li>\n<li>系统API对象提供的JS接口，可以在使用JS进行以下操作：获取系统属性、系统事件、使用进行封装了的接口</li>\n<li>提供云API来进行：操作云端数据、统计、推送、短信验证等功能</li>\n<li>提供与腾讯X5浏览器的集成（Android）</li>\n</ul>\n<p>下面是SuperWebView的架构图：</p>\n<p><img src=\"移动端混合编程/superwebview.png\" alt=\"\"></p>\n<p>先看右侧部分，上面是SuperWebView提供的页面组织结构，用户可以利用API对象提供的接口创建界面，用户可以创建window（整个界面），frame（界面中的模块界面），frameGroup（一组可以左右滑动浏览的界面），UIModule（native自定义视图）；右侧下面部分是SuperWebView提供的基础服务，并提供了与Native通信的机制；左侧部分是SuperWebView平台已模块的形式提供的可以供JS使用的Native模块单元，官网上有模块管理平台提供了模块可以供开发者使用，开发者也可以根据平台标准自定义模块。</p>\n<p>下面是使用SuperWebView实现的模拟网易云音乐的一个demo示例：</p>\n<p><img src=\"移动端混合编程/superwebview.gif\" alt=\"\"></p>\n<p>主页面的层级结构：</p>\n<p><img src=\"移动端混合编程/superwebview2.png\" alt=\"\"></p>\n<p>可以看到，应用界面可以由多个APIWebView与UIView（或其子类）组合而来，但是这些组合关系并不需要web端开发者来操心，可以借助平台api对象开放的接口调用，平台接口会构建出相应界面的的组合，例如,可以使用下面这样的方式打开一个可以左右滑动的多个页面组合而成的页面，其构建的界面结果就是UIScrollView中横向放置了四个页面，可以左右滑动翻页浏览。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">api.openFrameGroup(&#123;</div><div class=\"line\">        name: &apos;framegroup01&apos;,</div><div class=\"line\">        background: &apos;#FFF&apos;,</div><div class=\"line\">        scrollEnabled: true,</div><div class=\"line\">        rect: &#123;</div><div class=\"line\">            x: 0,</div><div class=\"line\">            y: firstHeaderOffset.h + firstHeaderIndexHeight,</div><div class=\"line\">            w: &quot;auto&quot;,</div><div class=\"line\">            h: api.frameHeight - firstHeaderOffset.h - firstHeaderIndexHeight - footerPos.h</div><div class=\"line\">        &#125;,</div><div class=\"line\">        index: 0,</div><div class=\"line\">        frames: [&#123;</div><div class=\"line\">            name: &apos;frame01_recommand&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_recommand.html&apos;,</div><div class=\"line\">            bounces: false,</div><div class=\"line\">        &#125;, &#123;</div><div class=\"line\">            name: &apos;frame01_list&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_list.html&apos;,</div><div class=\"line\">            bounces: true,</div><div class=\"line\">        &#125;, &#123;</div><div class=\"line\">            name: &apos;frame01_radio&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_radio.html&apos;,</div><div class=\"line\">            bounces: false,</div><div class=\"line\">        &#125;, &#123;</div><div class=\"line\">            name: &apos;frame01_rank&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_rank.html&apos;,</div><div class=\"line\">            bounces: false,</div><div class=\"line\">        &#125;]</div><div class=\"line\">    &#125;, function(ret) &#123;</div><div class=\"line\">        setFrameGroupStatus(ret.index);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>我们来看看APIWebView的真面目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface APIWebView : UZWebView</div><div class=\"line\">@interface UZWebView : UIWebView</div></pre></td></tr></table></figure>\n<p>我们看到，APIWebView实际是UIWebView的子类，整个页面结构使用APIWebView嵌套的方式构建。</p>\n<ul>\n<li>通过Instruments在iPhone5s上进行内存测试，对前面云音乐demo反复操作，累计创建11个APIWebView，内存开销在35M左右(创建11个UIWebView，并加载本地类似静态页面内存开销在24M左右)。</li>\n<li>通过对APIWebView的构造方法initWithFrame:和dealloc方法进行拦截，发现在打开新页面是通过[UZWebViewController loadWindow]和[UZWebViewController openFrame:]创建多个APIWebView，再结合Native控件，构建出页面。</li>\n</ul>\n<p>SuperWebView的用户通过对页面结构进行拆分，利用SuperWebView提供的API来构建页面，SuperWebView所提供的API会构建出相应的页面结构，例如上面云音乐demo中的首页面，就是由2个APIWebView和一个UIScrollView嵌套组合而成。至于界面的样式，需要用户用HTML+CSS进行描述。</p>\n<h3 id=\"SuperWebView中JS与Native通信的实现原理\"><a href=\"#SuperWebView中JS与Native通信的实现原理\" class=\"headerlink\" title=\"SuperWebView中JS与Native通信的实现原理\"></a>SuperWebView中JS与Native通信的实现原理</h3><p>下面分析下SuperWebView的实现JS与Native的通信机制。</p>\n<p>测试环境：iPhone5S,iOS8.3和iPhone4S,iOS7.1.1</p>\n<p>我们在JS端调用<code>alert(&quot;alert from js&quot;);</code>接口，利用远程调试进行断点跟踪。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//alert的实现</div><div class=\"line\">function (msg) &#123;</div><div class=\"line\">\t!function(msg)&#123;</div><div class=\"line\">\t\tif(msg===null)&#123;</div><div class=\"line\">\t\t\tmsg=&apos;null&apos;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tif(msg===undefined)&#123;</div><div class=\"line\">\t\t\tmsg=&apos;undefined&apos;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tmsg=msg.toString();</div><div class=\"line\">\t\tapi.alert(&#123;title:&apos;index.html&apos;,msg:msg,buttons:[&apos;好&apos;]&#125;);</div><div class=\"line\">\t&#125;(msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//api.alert的实现</div><div class=\"line\">function () &#123;</div><div class=\"line\">\treturn uz$e(&apos;UZAPI&apos;,&apos;alert&apos;,arguments,false,&apos;api&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">///uz$e的实现</div><div class=\"line\">function uz$e(c, m, p, isSync, module) &#123;</div><div class=\"line\">    var param = &#123;&#125;;</div><div class=\"line\">    </div><div class=\"line\">    //(1)</div><div class=\"line\">    if (p.length === 1) &#123;</div><div class=\"line\">        var p0 = p[0];</div><div class=\"line\">       //(1.1)</div><div class=\"line\">\t\tif (Object.prototype.toString.call(p0) === &quot;[object Object]&quot;) &#123;</div><div class=\"line\">            param = p0;</div><div class=\"line\">        &#125; else if (typeof p0 === &quot;function&quot;) &#123;</div><div class=\"line\">            param.cbId = uz$cb.id++;</div><div class=\"line\">            uz$cb.fn[param.cbId] = p0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else if (p.length === 2) &#123;</div><div class=\"line\">    \t//(1.2)</div><div class=\"line\">        var p0 = p[0];</div><div class=\"line\">        var p1 = p[1];</div><div class=\"line\">        if (Object.prototype.toString.call(p0) === &quot;[object Object]&quot;) &#123;</div><div class=\"line\">            param = p0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (typeof p1 === &quot;function&quot;) &#123;</div><div class=\"line\">            param.cbId = uz$cb.id++;</div><div class=\"line\">            uz$cb.fn[param.cbId] = p1;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//（2）</div><div class=\"line\">    if (typeof(_apiBridgeMethod)===&apos;function&apos;)&#123;</div><div class=\"line\">    \t //(2.1)\t</div><div class=\"line\">        return _apiBridgeMethod(c, m, param, isSync, module);</div><div class=\"line\">    &#125; else if (api.useWKWebView) &#123;</div><div class=\"line\">    \t //(2.2)\t</div><div class=\"line\">        var message = &#123;&#125;;</div><div class=\"line\">        message.class = c;</div><div class=\"line\">        message.method = m;</div><div class=\"line\">        message.param = param;</div><div class=\"line\">        message.isSync = false;</div><div class=\"line\">        message.module = module;</div><div class=\"line\">        window.webkit.messageHandlers.api.postMessage(message);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    \t //(2.3)\t</div><div class=\"line\">        uz$q.c.push(module+&apos;.&apos;+c+&apos;.&apos;+m+&apos;/?&apos;+encodeURIComponent(JSON.stringify(param)));</div><div class=\"line\">        uz$r();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对这段代码进行分析：</p>\n<p>（1）对参数进行处理</p>\n<p>(1.1) 只有一个参数，对调用参数或者回调函数分别处理</p>\n<p>(1.2) 有两个参数，对调用参数和回调函数分别处理</p>\n<p>（2）执行函数调用</p>\n<p>(2.1) 调用_apiBridgeMethod方法，在当前测试环境下，会走2.1的逻辑，其实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function () &#123;</div><div class=\"line\">    [native code]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到_apiBridgeMethod的方法体是native code，那么是如何将native code注册给WebView的JS解释器的呢？</p>\n<p>将APICloud.a中的UZWebView.o反编译出来伪代码看到如下实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">// UZWebView - (void)initJavaScriptCoreBridgeMethod</div><div class=\"line\">void __cdecl -[UZWebView initJavaScriptCoreBridgeMethod](struct UZWebView *self, SEL a2)</div><div class=\"line\">&#123;</div><div class=\"line\">  struct UZWebView *v7; // r8@1</div><div class=\"line\">  void *v8; // r0@1</div><div class=\"line\">  void *v9; // r5@1</div><div class=\"line\">  void *v10; // r0@1</div><div class=\"line\">  void *v11; // r6@1</div><div class=\"line\">  void *v13; // r0@2</div><div class=\"line\">  void *v14; // r6@2</div><div class=\"line\">  void *v15; // r0@2</div><div class=\"line\">  int v16; // r4@2</div><div class=\"line\">  void *v17; // r0@2</div><div class=\"line\">  void *v18; // r5@2</div><div class=\"line\">  int *v19; // r4@3</div><div class=\"line\">  int v23; // [sp+0h] [bp-78h]@1</div><div class=\"line\">  void *v24; // [sp+4h] [bp-74h]@3</div><div class=\"line\">  void *v25; // [sp+8h] [bp-70h]@3</div><div class=\"line\">  void *v26; // [sp+Ch] [bp-6Ch]@3</div><div class=\"line\">  int v27; // [sp+10h] [bp-68h]@3</div><div class=\"line\">  int v28; // [sp+14h] [bp-64h]@3</div><div class=\"line\">  int (__fastcall *v29)(__block_literal_3 *, Foundation::NSString::NSString *, Foundation::NSString::NSString *, Foundation::NSDictionary::NSDictionary *, Foundation::NSString::NSString *, int); // [sp+18h] [bp-60h]@3</div><div class=\"line\">  void *v30; // [sp+1Ch] [bp-5Ch]@3</div><div class=\"line\">  int v31; // [sp+20h] [bp-58h]@1</div><div class=\"line\">  char v32; // [sp+24h] [bp-54h]@3</div><div class=\"line\">  int *v33; // [sp+28h] [bp-50h]@3</div><div class=\"line\">  char v34; // [sp+2Ch] [bp-4Ch]@1</div><div class=\"line\">  int v35; // [sp+30h] [bp-48h]@2</div><div class=\"line\">  void *v36; // [sp+44h] [bp-34h]@1</div><div class=\"line\">  void *v37; // [sp+48h] [bp-30h]@1</div><div class=\"line\">  __int64 *v38; // [sp+4Ch] [bp-2Ch]@1</div><div class=\"line\">  unsigned int v39; // [sp+50h] [bp-28h]@1</div><div class=\"line\">  int *v40; // [sp+54h] [bp-24h]@1</div><div class=\"line\">  char v41; // [sp+60h] [bp-18h]@5</div><div class=\"line\">  __int64 savedregs; // [sp+78h] [bp+0h]@1</div><div class=\"line\"></div><div class=\"line\">  _R4 = (unsigned int)&amp;v31 &amp; 0xFFFFFFF0;</div><div class=\"line\">  __asm</div><div class=\"line\">  &#123;</div><div class=\"line\">    VST1.64         &#123;D8-D11&#125;, [R4@128]!</div><div class=\"line\">    VST1.64         &#123;D12-D15&#125;, [R4@128]</div><div class=\"line\">  &#125;</div><div class=\"line\">  v7 = self;</div><div class=\"line\">  v8 = objc_msgSend(&amp;OBJC_CLASS___UIDevice, &quot;currentDevice&quot;);</div><div class=\"line\">  v9 = (void *)objc_retainAutoreleasedReturnValue(v8);</div><div class=\"line\">  v10 = objc_msgSend(v9, &quot;systemVersion&quot;);</div><div class=\"line\">  v11 = (void *)objc_retainAutoreleasedReturnValue(v10);</div><div class=\"line\">  _R4 = objc_msgSend(v11, &quot;floatValue&quot;);</div><div class=\"line\">  objc_release(v11);</div><div class=\"line\">  objc_release(v9);</div><div class=\"line\">  v36 = &amp;__objc_personality_v0;</div><div class=\"line\">  v37 = &amp;GCC_except_table117;</div><div class=\"line\">  v38 = &amp;savedregs;</div><div class=\"line\">  v40 = &amp;v23;</div><div class=\"line\">  v39 = (((unsigned int)&amp;loc_13E + 2) | 1) + 42164;</div><div class=\"line\">  _Unwind_SjLj_Register(&amp;v34);</div><div class=\"line\">  __asm</div><div class=\"line\">  &#123;</div><div class=\"line\">    VMOV.F32        D0, #7.0</div><div class=\"line\">    VMOV            D1, R4, R4</div><div class=\"line\">    VCMPE.F32       S2, S0</div><div class=\"line\">    VMRS            APSR_nzcv, FPSCR</div><div class=\"line\">  &#125;</div><div class=\"line\">  if ( !(_NF ^ _VF) )</div><div class=\"line\">  &#123;</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v13 = objc_msgSend(v7, &quot;webView&quot;);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v14 = (void *)objc_retainAutoreleasedReturnValue(v13);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v15 = objc_msgSend(v7, &quot;jsContextKeyPath&quot;);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v16 = objc_retainAutoreleasedReturnValue(v15);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v17 = objc_msgSend(v14, &quot;valueForKeyPath:&quot;, v16);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v18 = (void *)objc_retainAutoreleasedReturnValue(v17);</div><div class=\"line\">    objc_release(v16);</div><div class=\"line\">    if ( v18 )</div><div class=\"line\">    &#123;</div><div class=\"line\">      v25 = v14;</div><div class=\"line\">      objc_initWeak(&amp;v32, v7);</div><div class=\"line\">      v26 = &amp;_NSConcreteStackBlock;</div><div class=\"line\">      v27 = -1040187392;</div><div class=\"line\">      v28 = 0;</div><div class=\"line\">      v29 = _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke;</div><div class=\"line\">      v33 = &amp;v31;</div><div class=\"line\">      v30 = &amp;__block_descriptor_tmp_1135;</div><div class=\"line\">      objc_copyWeak(&amp;v31, &amp;v32);</div><div class=\"line\">      v23 = objc_retainBlock(&amp;v26);</div><div class=\"line\">      v35 = 1;</div><div class=\"line\">      v24 = v18;</div><div class=\"line\">      objc_msgSend(v18, &quot;setObject:forKeyedSubscript:&quot;);</div><div class=\"line\">      v19 = v33;</div><div class=\"line\">      objc_release(v23);</div><div class=\"line\">      objc_destroyWeak(v19);</div><div class=\"line\">      objc_destroyWeak(&amp;v32);</div><div class=\"line\">      v14 = v25;</div><div class=\"line\">      v18 = v24;</div><div class=\"line\">    &#125;</div><div class=\"line\">    objc_release(v18);</div><div class=\"line\">    objc_release(v14);</div><div class=\"line\">  &#125;</div><div class=\"line\">  _Unwind_SjLj_Unregister(&amp;v34);</div><div class=\"line\">  _R4 = &amp;v41;</div><div class=\"line\">  __asm</div><div class=\"line\">  &#123;</div><div class=\"line\">    VLD1.64         &#123;D8-D11&#125;, [R4@128]!</div><div class=\"line\">    VLD1.64         &#123;D12-D15&#125;, [R4@128]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们可以看到，首先是利用KVC从UZWebView获得JSContext，然后setObject:forKeyedSubscript:设置_apiBridgeMethod的值为<code>_43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke</code>，它的实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">int __fastcall _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke(</div><div class=\"line\">__block_literal_3 *.block_descriptor, </div><div class=\"line\">Foundation::NSString::NSString *a2, </div><div class=\"line\">Foundation::NSString::NSString *method, </div><div class=\"line\">Foundation::NSDictionary::NSDictionary *param, </div><div class=\"line\">Foundation::NSString::NSString *module, </div><div class=\"line\">int a6)</div><div class=\"line\">&#123;</div><div class=\"line\">  Foundation::NSDictionary::NSDictionary *v7; // r5@1</div><div class=\"line\">  Foundation::NSString::NSString *v8; // r4@1</div><div class=\"line\">  int v9; // r10@1</div><div class=\"line\">  int v10; // r4@1</div><div class=\"line\">  void *v11; // r8@1</div><div class=\"line\">  int v12; // r11@1</div><div class=\"line\">  void *v13; // r2@1</div><div class=\"line\">  int v14; // r0@2</div><div class=\"line\">  void *v15; // r0@3</div><div class=\"line\">  void *v16; // ST04_4@4</div><div class=\"line\">  int v17; // r5@4</div><div class=\"line\">  void *v18; // r0@4</div><div class=\"line\">  void *v19; // r8@4</div><div class=\"line\">  void *v20; // r4@4</div><div class=\"line\">  void *v21; // r0@4</div><div class=\"line\">  int v22; // r6@4</div><div class=\"line\">  __block_literal_3 *v24; // [sp+8h] [bp-20h]@1</div><div class=\"line\"></div><div class=\"line\">  v24 = .block_descriptor;</div><div class=\"line\">  v7 = param;</div><div class=\"line\">  v8 = method;</div><div class=\"line\">  v9 = objc_retain(a2);</div><div class=\"line\">  v10 = objc_retain(v8);</div><div class=\"line\">  v11 = (void *)objc_retain(v7);</div><div class=\"line\">  v12 = objc_retain(a6);</div><div class=\"line\">  v13 = objc_msgSend(&amp;OBJC_CLASS___NSDictionary, &quot;class&quot;);</div><div class=\"line\">  if ( (unsigned int)objc_msgSend(v11, &quot;isKindOfClass:&quot;, v13) &amp; 0xFF )</div><div class=\"line\">  &#123;</div><div class=\"line\">    v14 = objc_retain(v11);</div><div class=\"line\">  &#125;</div><div class=\"line\">  else</div><div class=\"line\">  &#123;</div><div class=\"line\">    v15 = objc_msgSend(&amp;OBJC_CLASS___NSDictionary, &quot;dictionaryWithObjects:forKeys:count:&quot;);</div><div class=\"line\">    v14 = objc_retainAutoreleasedReturnValue(v15);</div><div class=\"line\">  &#125;</div><div class=\"line\">  v16 = v11;</div><div class=\"line\">  v17 = v14;</div><div class=\"line\">  v18 = objc_msgSend(&amp;OBJC_CLASS___UZCommand, &quot;alloc&quot;);</div><div class=\"line\">  v19 = objc_msgSend(v18, &quot;initWithClassName:methodName:param:&quot;, v9, v10, v17);</div><div class=\"line\">  objc_release(v10);</div><div class=\"line\">  objc_release(v9);</div><div class=\"line\">  objc_msgSend(v19, &quot;setIsSyncMethod:&quot;, module);</div><div class=\"line\">  objc_msgSend(v19, &quot;setModule:&quot;, v12);</div><div class=\"line\">  objc_release(v12);</div><div class=\"line\">  v20 = (void *)objc_loadWeakRetained(&amp;v24-&gt;weakSelf);</div><div class=\"line\">  v21 = objc_msgSend(v20, &quot;execute:&quot;, v19);</div><div class=\"line\">  v22 = objc_retainAutoreleasedReturnValue(v21);</div><div class=\"line\">  objc_release(v20);</div><div class=\"line\">  objc_release(v19);</div><div class=\"line\">  objc_release(v17);</div><div class=\"line\">  objc_release(v16);</div><div class=\"line\">  return objc_autoreleaseReturnValue(v22);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大概意思是，读取调用信息，根据信息创建一个UZCommand对象，再去执行UZCommand，再看execute的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div></pre></td><td class=\"code\"><pre><div class=\"line\">// UZWebView - (id)execute:(id) </div><div class=\"line\">id __cdecl -[UZWebView execute:](struct UZWebView *self, SEL a2, id a3)</div><div class=\"line\">&#123;</div><div class=\"line\">  struct UZWebView *v3; // r11@1</div><div class=\"line\">  void *v4; // r6@1</div><div class=\"line\">  int v5; // r5@2</div><div class=\"line\">  void *v6; // r0@3</div><div class=\"line\">  int v7; // r10@3</div><div class=\"line\">  void *v8; // r0@3</div><div class=\"line\">  void *v9; // r8@3</div><div class=\"line\">  void *v10; // r0@3</div><div class=\"line\">  void *v11; // r0@3</div><div class=\"line\">  void *v12; // r4@3</div><div class=\"line\">  void *v13; // r0@3</div><div class=\"line\">  int v14; // r5@3</div><div class=\"line\">  void *v15; // r0@3</div><div class=\"line\">  int v16; // r0@3</div><div class=\"line\">  void *v17; // r6@3</div><div class=\"line\">  void *v18; // r0@3</div><div class=\"line\">  void *v19; // r5@3</div><div class=\"line\">  int v20; // r10@4</div><div class=\"line\">  void *v21; // r0@5</div><div class=\"line\">  void *v22; // r4@5</div><div class=\"line\">  void *v23; // r0@5</div><div class=\"line\">  void *v24; // r0@5</div><div class=\"line\">  void *v25; // r6@5</div><div class=\"line\">  void *v26; // r0@5</div><div class=\"line\">  void *v27; // r10@5</div><div class=\"line\">  void *v28; // ST10_4@5</div><div class=\"line\">  void *v29; // r4@5</div><div class=\"line\">  void *v30; // r0@5</div><div class=\"line\">  void *v31; // r0@5</div><div class=\"line\">  int v32; // r4@5</div><div class=\"line\">  void *v33; // r2@6</div><div class=\"line\">  void *v34; // r0@7</div><div class=\"line\">  void *v35; // r0@10</div><div class=\"line\">  int v36; // r8@10</div><div class=\"line\">  int v37; // r6@10</div><div class=\"line\">  int v38; // r11@11</div><div class=\"line\">  void *v39; // r0@12</div><div class=\"line\">  void *v40; // r4@12</div><div class=\"line\">  void *v41; // r0@13</div><div class=\"line\">  int v42; // r4@13</div><div class=\"line\">  void *v43; // r0@16</div><div class=\"line\">  int v44; // r4@16</div><div class=\"line\">  int v46; // [sp+18h] [bp-28h]@4</div><div class=\"line\">  void *v47; // [sp+1Ch] [bp-24h]@10</div><div class=\"line\">  int v48; // [sp+20h] [bp-20h]@3</div><div class=\"line\">  void *v49; // [sp+24h] [bp-1Ch]@3</div><div class=\"line\"></div><div class=\"line\">  v3 = self;</div><div class=\"line\">  v4 = (void *)objc_retain(a3);</div><div class=\"line\">  if ( !((unsigned int)objc_msgSend(v3, &quot;shouldClosed&quot;) &amp; 0xFF) )</div><div class=\"line\">  &#123;</div><div class=\"line\">    v6 = objc_msgSend(v4, &quot;methodName&quot;);</div><div class=\"line\">    v7 = objc_retainAutoreleasedReturnValue(v6);</div><div class=\"line\">    v8 = objc_msgSend(v4, &quot;className&quot;);</div><div class=\"line\">    v9 = (void *)objc_retainAutoreleasedReturnValue(v8);</div><div class=\"line\">    v10 = objc_msgSend(v4, &quot;paramDict&quot;);</div><div class=\"line\">    v48 = objc_retainAutoreleasedReturnValue(v10);</div><div class=\"line\">    v11 = objc_msgSend(v3, &quot;request&quot;);</div><div class=\"line\">    v12 = (void *)objc_retainAutoreleasedReturnValue(v11);</div><div class=\"line\">    v13 = objc_msgSend(v12, &quot;URL&quot;);</div><div class=\"line\">    v14 = objc_retainAutoreleasedReturnValue(v13);</div><div class=\"line\">    v49 = v4;</div><div class=\"line\">    v15 = objc_msgSend(v4, &quot;module&quot;);</div><div class=\"line\">    v16 = objc_retainAutoreleasedReturnValue(v15);</div><div class=\"line\">    objc_release(v16);</div><div class=\"line\">    v17 = v9;</div><div class=\"line\">    objc_release(v14);</div><div class=\"line\">    objc_release(v12);</div><div class=\"line\">    v18 = objc_msgSend((void *)v3-&gt;_moduleDict, &quot;objectForKey:&quot;, v9);</div><div class=\"line\">    v19 = (void *)objc_retainAutoreleasedReturnValue(v18);</div><div class=\"line\">    if ( !v19 )</div><div class=\"line\">    &#123;</div><div class=\"line\">      v46 = v7;</div><div class=\"line\">      v20 = NSClassFromString(v9);</div><div class=\"line\">      if ( v20</div><div class=\"line\">        || (v21 = objc_msgSend(&amp;OBJC_CLASS___NSBundle, &quot;mainBundle&quot;),</div><div class=\"line\">            v22 = (void *)objc_retainAutoreleasedReturnValue(v21),</div><div class=\"line\">            v23 = objc_msgSend(v22, &quot;infoDictionary&quot;),</div><div class=\"line\">            v24 = (void *)objc_retainAutoreleasedReturnValue(v23),</div><div class=\"line\">            v25 = v24,</div><div class=\"line\">            v26 = objc_msgSend(v24, &quot;stringValueForKey:defaultValue:&quot;, CFSTR(&quot;CFBundleExecutable&quot;), &amp;stru_12864),</div><div class=\"line\">            v27 = (void *)objc_retainAutoreleasedReturnValue(v26),</div><div class=\"line\">            v28 = v27,</div><div class=\"line\">            objc_release(v25),</div><div class=\"line\">            objc_release(v22),</div><div class=\"line\">            v29 = objc_msgSend(v27, &quot;length&quot;),</div><div class=\"line\">            v17 = v9,</div><div class=\"line\">            v19 = 0,</div><div class=\"line\">            v30 = objc_msgSend(v9, &quot;length&quot;),</div><div class=\"line\">            v31 = objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;_TtC%lu%@%lu%@&quot;), v29, v27, v30, v9),</div><div class=\"line\">            v32 = objc_retainAutoreleasedReturnValue(v31),</div><div class=\"line\">            v20 = NSClassFromString(v32),</div><div class=\"line\">            objc_release(v32),</div><div class=\"line\">            objc_release(v28),</div><div class=\"line\">            v20) )</div><div class=\"line\">      &#123;</div><div class=\"line\">        v33 = objc_msgSend(&amp;OBJC_CLASS___UZModule, &quot;class&quot;);</div><div class=\"line\">        if ( (unsigned int)objc_msgSend((void *)v20, &quot;isSubclassOfClass:&quot;, v33) &amp; 0xFF )</div><div class=\"line\">        &#123;</div><div class=\"line\">          v34 = objc_msgSend((void *)v20, &quot;alloc&quot;);</div><div class=\"line\">          v19 = objc_msgSend(v34, &quot;initWithUZWebView:&quot;, v3);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      if ( !v19 )</div><div class=\"line\">      &#123;</div><div class=\"line\">        v43 = objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;ERROR: Module &apos;%@&apos; not found&quot;), v17);</div><div class=\"line\">        v44 = objc_retainAutoreleasedReturnValue(v43);</div><div class=\"line\">        objc_msgSend(v3, &quot;sendErrorEvent:&quot;, v44);</div><div class=\"line\">        NSLog(CFSTR(&quot;%@&quot;), v44);</div><div class=\"line\">        objc_release(v44);</div><div class=\"line\">        v5 = 0;</div><div class=\"line\">        v7 = v46;</div><div class=\"line\">        v38 = v48;</div><div class=\"line\">        goto LABEL_17;</div><div class=\"line\">      &#125;</div><div class=\"line\">      objc_msgSend((void *)v3-&gt;_moduleDict, &quot;setObject:forKey:&quot;, v19, v17);</div><div class=\"line\">      v7 = v46;</div><div class=\"line\">    &#125;</div><div class=\"line\">    v47 = v17;</div><div class=\"line\">    v35 = objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;%@:&quot;), v7);</div><div class=\"line\">    v36 = objc_retainAutoreleasedReturnValue(v35);</div><div class=\"line\">    v37 = NSSelectorFromString();</div><div class=\"line\">    if ( (unsigned int)objc_msgSend(v19, &quot;respondsToSelector:&quot;, v37) &amp; 0xFF )</div><div class=\"line\">    &#123;</div><div class=\"line\">      v38 = v48;</div><div class=\"line\">      if ( (unsigned int)objc_msgSend(v49, &quot;isSyncMethod&quot;) &amp; 0xFF )</div><div class=\"line\">      &#123;</div><div class=\"line\">        v39 = objc_msgSend(v19, &quot;performSelector:withObject:&quot;, v37, v48);</div><div class=\"line\">        v40 = v19;</div><div class=\"line\">        v5 = objc_retainAutoreleasedReturnValue(v39);</div><div class=\"line\">        objc_release(v36);</div><div class=\"line\">        objc_release(v40);</div><div class=\"line\">        v17 = v47;</div><div class=\"line\">LABEL_17:</div><div class=\"line\">        objc_release(v38);</div><div class=\"line\">        objc_release(v17);</div><div class=\"line\">        objc_release(v7);</div><div class=\"line\">        v4 = v49;</div><div class=\"line\">        goto LABEL_18;</div><div class=\"line\">      &#125;</div><div class=\"line\">      objc_msgSend(v19, &quot;performSelectorOnMainThread:withObject:waitUntilDone:&quot;, v37, v48, 0);</div><div class=\"line\">      v17 = v47;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">      v17 = v47;</div><div class=\"line\">      v41 = objc_msgSend(</div><div class=\"line\">              &amp;OBJC_CLASS___NSString,</div><div class=\"line\">              &quot;stringWithFormat:&quot;,</div><div class=\"line\">              CFSTR(&quot;ERROR: Method &apos;%@&apos; not defined in Module &apos;%@&apos;&quot;),</div><div class=\"line\">              v7,</div><div class=\"line\">              v47);</div><div class=\"line\">      v42 = objc_retainAutoreleasedReturnValue(v41);</div><div class=\"line\">      objc_msgSend(v3, &quot;sendErrorEvent:&quot;, v42);</div><div class=\"line\">      NSLog(CFSTR(&quot;%@&quot;), v42);</div><div class=\"line\">      objc_release(v42);</div><div class=\"line\">      v38 = v48;</div><div class=\"line\">    &#125;</div><div class=\"line\">    objc_release(v36);</div><div class=\"line\">    objc_release(v19);</div><div class=\"line\">    v5 = 0;</div><div class=\"line\">    goto LABEL_17;</div><div class=\"line\">  &#125;</div><div class=\"line\">  v5 = 0;</div><div class=\"line\">LABEL_18:</div><div class=\"line\">  objc_release(v4);</div><div class=\"line\">  return (id)objc_autoreleaseReturnValue(v5);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要流程是从UZCommand中读出模块，方法，参数等信息，根据类名创建了实例，然后调用初始化构造函数initWithUZWebView（这里和官网介绍<a href=\"http://docs.apicloud.com/APICloud/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/module-dev-guide-for-ios\" target=\"_blank\" rel=\"external\">如何自定义模块</a>中的说明是一致的）,然后会判断是同步调用还是异步调用，同步调用则直接执行<code>performSelector:withObject:</code>，异步调用执行<code>performSelectorOnMainThread:withObject:waitUntilDone:</code>，至此，完成了JS到native方法的调用。</p>\n<p>(2.2)如果使用了WKWebView，则通过发送信息的方式将调用信息发给Native端。</p>\n<p>不过，目前SuperWebView暂未支持WKWebView，没有开放api和文档出来。</p>\n<p>(2.3)uz$q和uz$r的实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//uz$q</div><div class=\"line\">&#123;c: Array[0], flag: true&#125;</div><div class=\"line\"></div><div class=\"line\">//uz$r</div><div class=\"line\">function uz$r() &#123;</div><div class=\"line\">    if(uz$q.flag &amp;&amp; uz$q.c.length&gt;0)&#123;</div><div class=\"line\">        uz$q.flag = false;</div><div class=\"line\">        window.location = &apos;uz://&apos; + uz$q.c[0];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里是将调用信息拼接成一个URL，scheme采用uz:，赋值给window.location赋值对当前页面重定向，这里应该是采用UIWebView的代理方式实现与Native端通信，会调用到<code>webView:shouldStartLoadWithRequest:navigationType:</code>代理方法中去，这种就是JSBridge的方式了。</p>\n<p>补充说明一点，从Native回调到JS端的方式是，通过<code>stringByEvaluatingJavaScriptFromString:</code>的方式，通知js端，并把callbackID作为参数回传过去。</p>\n<h3 id=\"关于SuperWebView所指的混合渲染的说明\"><a href=\"#关于SuperWebView所指的混合渲染的说明\" class=\"headerlink\" title=\"关于SuperWebView所指的混合渲染的说明\"></a>关于SuperWebView所指的混合渲染的说明</h3><p>看到混合渲染，第一理解是，SuperWebView支持将Native的View直接fix在UIWebView内部做渲染，这样做就需要修改webview的渲染机制，并且还要支持将css的解析映射到native view中去，通过官方文档和使用教程，并没有看到相关介绍。目前我的理解是，将Native的View作为子View添加到UIWebView中去。为了验证这一点，我们使用官网提供个UISlider模块来写示例代码，在JS中使用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">var uislider = api.require(&apos;UISlider&apos;);</div><div class=\"line\">            uislider.open(&#123;</div><div class=\"line\">                animation: true,</div><div class=\"line\">                orientation: &apos;horizontal&apos;,</div><div class=\"line\">                rect: &#123;</div><div class=\"line\">                    x: 10,</div><div class=\"line\">                    y: 100,</div><div class=\"line\">                    size: 300</div><div class=\"line\">                &#125;,</div><div class=\"line\">                bubble: &#123;</div><div class=\"line\">                    direction: &apos;top&apos;,</div><div class=\"line\">                    state: &apos;always&apos;,</div><div class=\"line\">                    w: 80,</div><div class=\"line\">                    h: 30,</div><div class=\"line\">                    size: 14,</div><div class=\"line\">                    color: &apos;#888&apos;,</div><div class=\"line\">                    bg: &apos;widget://res/slider/bubble.png&apos;,</div><div class=\"line\">                    prefix: &apos;温度：&apos;,</div><div class=\"line\">                    suffix: &apos;摄氏度&apos;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                handler: &#123;</div><div class=\"line\">                    w: 10,</div><div class=\"line\">                    h: 8,</div><div class=\"line\">                    bg: &apos;widget://res/slider/handler.png&apos;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                bar: &#123;</div><div class=\"line\">                    h: 4,</div><div class=\"line\">                    bg: &apos;widget://res/slider/background.png&apos;,</div><div class=\"line\">                    active: &apos;widget://res/slider/bar-active.png&apos;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                value: &#123;</div><div class=\"line\">                    min: 16,</div><div class=\"line\">                    max: 32,</div><div class=\"line\">                    step: 0.5,</div><div class=\"line\">                    init: 26</div><div class=\"line\">                &#125;,</div><div class=\"line\">                fixedOn: api.frameName,</div><div class=\"line\">                fixed: false</div><div class=\"line\">            &#125;, function(ret, err) &#123;</div><div class=\"line\">                if (ret) &#123;</div><div class=\"line\">                    alert(JSON.stringify(ret));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    alert(JSON.stringify(err));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure>\n<p>打开的视图效果如下：</p>\n<p><img src=\"./superwebview3.png\" alt=\"\"></p>\n<p>我们看到UISlider是悬浮在WebView之上的，那么我们可以猜测，其是通过在native构建并添加到WebView上的，这一点可以通过反编译了UISlider的目标文件，可以看到open方法的实现里面多次调用了addSubView方法。</p>\n<p>优点：</p>\n<ul>\n<li>性能好</li>\n<li>提供方便的api进行页面组合</li>\n<li>模块化平台，让更多的人为前端工程师服务</li>\n<li>管理平台：热更新，云数据等</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>样式需要前端开发者去模拟native的样式</li>\n<li>有些系统级的动画暂不支持，如导航栏渐变动画</li>\n</ul>\n<h2 id=\"5-Runtime-amp-Native-js\"><a href=\"#5-Runtime-amp-Native-js\" class=\"headerlink\" title=\"5+Runtime &amp; Native.js\"></a>5+Runtime &amp; Native.js</h2><ul>\n<li>5+Runtime是对HTML5+规范的实现，除了支持标准HTML5外，还扩展了JavaScript对象plus，使得js可以调用各种浏览器无法实现或实现不佳的系统能力，设备能力如摄像头、陀螺仪、文件系统等，业务能力如上传下载、二维码、地图、支付、语音输入、消息推送等。编写一次，可跨平台运行。</li>\n<li>大量的手机OS的原生API无法被HTML5使用，Native.js把原生API封装成了js对象，通过js可以直接调ios和android的原生API。这部分就不再跨平台，写法分别是plus.ios和plus.android。</li>\n<li>Native.js不是一个js库，不需要下载引入到页面的script中，也不像nodejs那样有单独的运行环境，Native.js的运行环境是集成在5+runtime里的。</li>\n</ul>\n<p>使用方式：</p>\n<ul>\n<li>对于web端开发者，使用HBuilder IDE，它集成了5+Runtime和Native.js，可以创建移动项目来开发App</li>\n<li>对于Native端开发者，可以从平台下载SDK集成到项目中使用</li>\n</ul>\n<p>看到5+runtime说是<a href=\"http://weibo.com/p/1001603806548597059383\" target=\"_blank\" rel=\"external\">开源</a>了,不过在<a href=\"https://github.com/dcloudio/H5P.Core\" target=\"_blank\" rel=\"external\">开源项目</a>中并未找到iOS native的代码实现，其中还是以静态库的形式提供，不过在pdr.js文件中，看到了plus.tools和plus.bridge的实现，这两个实现在后文中会使用到。</p>\n<h3 id=\"Native-js通信方式实现分析\"><a href=\"#Native-js通信方式实现分析\" class=\"headerlink\" title=\"Native.js通信方式实现分析\"></a>Native.js通信方式实现分析</h3><p>下面以使用iOS中的UIAlertView为示例。</p>\n<p>iOS端使用UIAlertView的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\">//...</div><div class=\"line\">// 创建UIAlertView类的实例对象</div><div class=\"line\">UIAlertView *view = [UIAlertView alloc];</div><div class=\"line\">// 设置提示对话上的内容</div><div class=\"line\">[view initWithTitle:@&quot;自定义标题&quot; // 提示框标题</div><div class=\"line\">    message:@&quot;使用NJS的原生弹出框，可自定义弹出框的标题、按钮&quot; // 提示框上显示的内容</div><div class=\"line\">    delegate:nil // 点击提示框后的通知代理对象，nil类似js的null，意为不设置</div><div class=\"line\">    cancelButtonTitle:@&quot;确定(或者其他字符)&quot; // 提示框上取消按钮的文字</div><div class=\"line\">    otherButtonTitles:nil]; // 提示框上其它按钮的文字，设置为nil表示不显示</div><div class=\"line\">// 调用show方法显示提示对话框，在OC中使用[]语法调用对象的方法</div><div class=\"line\">[view show];</div></pre></td></tr></table></figure>\n<p>JS端使用UIAlertView的方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建UIAlertView类的实例对象</div><div class=\"line\">var view = new UIAlertView();</div><div class=\"line\">// 设置提示对话上的内容</div><div class=\"line\">view.initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles(&quot;自定义标题&quot; // 提示框标题</div><div class=\"line\">\t, &quot;使用NJS的原生弹出框，可自定义弹出框的标题、按钮&quot; // 提示框上显示的内容</div><div class=\"line\">\t, null // 操作提示框后的通知代理对象，暂不设置</div><div class=\"line\">\t, &quot;确定(或者其他字符)&quot; // 提示框上取消按钮的文字</div><div class=\"line\">\t, null ); // 提示框上其它按钮的文字，设置为null表示不显示</div><div class=\"line\">// 调用show方法显示提示对话框</div><div class=\"line\">view.show();</div></pre></td></tr></table></figure>\n<p>其中UIAlertView、initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles和show的实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.plus.ios.UIAlertView = function(create) &#123;</div><div class=\"line\">        this.__UUID__ = window.plus.tools.UUID(&apos;JSB&apos;);</div><div class=\"line\">        this.__TYPE__ = &apos;JSBObject&apos;;</div><div class=\"line\">        var args = window.plus.ios.__Tool.process(arguments);</div><div class=\"line\">        if ( create &amp;&amp; plus.tools.IOS == plus.tools.platform ) &#123;</div><div class=\"line\">        </div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            window.plus.bridge.execSync(&apos;Invocation&apos;, &apos;__Instance&apos;, [this.__UUID__, &apos;UIAlertView&apos;, args]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">plus.ios.UIAlertView.prototype.initWithTitlemessagedelegatedefaultButtoncancelButtonotherButtons = function () &#123;</div><div class=\"line\">        var ret = null;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            var args = window.plus.ios.__Tool.process(arguments);</div><div class=\"line\">            ret = window.plus.bridge.execSync(&apos;Invocation&apos;, &apos;__exec&apos;, [this.__UUID__, &apos;initWithTitle:message:delegate:defaultButton:cancelButton:otherButtons:&apos;, args]);</div><div class=\"line\">            ret = plus.ios.__Tool.New(ret, false);</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">plus.ios.UIAlertView.prototype.show = function () &#123;</div><div class=\"line\">        var ret = null;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            var args = window.plus.ios.__Tool.process(arguments);</div><div class=\"line\">            ret = window.plus.bridge.execSync(&apos;Invocation&apos;, &apos;__exec&apos;, [this.__UUID__, &apos;show&apos;, args]);</div><div class=\"line\">            ret = plus.ios.__Tool.New(ret, false);</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>可以看到，我们创建的UIAlertView是一个JS对象，这个对象是当我们使用<code>UIAlertView = plus.ios.importClass(&quot;UIAlertView&quot;);</code>时动态创建的JS对象，与Native的UIAlertView相对应，我们称该JS对象为NJS对象。我们对NJS对象UIAlertView进行的方法调用，最终会执行<code>window.plus.bridge.execSync</code>，我们需要看下它的实现，在此之前，关于通过NJS对象访问Native对象，先做一些说明。</p>\n<ul>\n<li>首次导入Native类对象时，Native.js会动态创建一个JS对象与之相对应，JS对象包括相应的构造函数、方法、父类(prototype)等信息。</li>\n<li>由于是动态创建对应的JS对象，这里有一定的性能损耗，<a href=\"http://ask.dcloud.net.cn/docs/#http://ask.dcloud.net.cn/article/88\" target=\"_blank\" rel=\"external\">官方文档</a>中性能优化一节建议页面打开后触发的“plusready”事件中进行类对象的导入操作，这样提前导入了我们需要导入的类对象，是我们在后面逻辑中使用时保证其已经导入，这种方式只是将导入时机提前，并不是消除了导入带来的损耗。所以官方也不建议我们在一个页面中导入过多的类对象，这样会影响性能。</li>\n<li>数据类型转换：在NJS中调用Native API或从Native API返回数据到NJS时会自动转换数据类型。</li>\n<li>Native类对象的方法会在JS对象中有份映射，方法名是native方法名去掉‘冒号’之后的名称（字母大小写不变）。</li>\n<li>对于映射的JS对象，可以通过“.”调用方式来访问native对象的属性，但这种方式获得的值是Native层对象被映射为NJS对象那一刻的属性值，如果需要实时获取和设置native对象属性值，需要使用plusGetAttribute和plusSetAttribute方法，但这种方式效率比较低。</li>\n<li>Objective-C和Java中类如果存在继承自基类，在NJS中对应的对象会根据继承关系递归将所有基类的公有方法一一换成NJS对象的方法，所有基类的公有属性也可以通过其plusGetAttribute、plusSetAttribute方法访问。</li>\n<li>由于Objective-C中类没有静态变量，而是通过定义全局变量来实现，目前NJS中无法访问全局变量的值。对于全局常量，在NJS中也无法访问。</li>\n</ul>\n<p>继续之前的window.plus.bridge.execSync方法调用，其方法实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function (service,action,args,fn)&#123;</div><div class=\"line\">    var json,sync,ret;</div><div class=\"line\">    if(T.IOS==T.platform)&#123;</div><div class=\"line\">        try&#123;</div><div class=\"line\">            if(json=T.stringify([[window.__HtMl_Id__,service,action,null,args]]),</div><div class=\"line\">                sync=B.synExecXhr,</div><div class=\"line\">                sync.open(&quot;post&quot;,&quot;http://localhost:13131/cmds&quot;,!1),</div><div class=\"line\">                sync.setRequestHeader(&quot;Content-Type&quot;,&quot;multipart/form-data&quot;),</div><div class=\"line\">                sync.send(json),</div><div class=\"line\">                fn)</div><div class=\"line\">                return fn(sync.responseText)</div><div class=\"line\">        &#125;catch(e)&#123;</div><div class=\"line\">            console.log(&quot;sf:&quot;+action+&quot;-&quot;+service)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return window.eval(sync.responseText)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return T.ANDROID==T.platform?</div><div class=\"line\">        (ret=window.prompt(T.stringify(args),&quot;pdr:&quot;+T.stringify([service,action,!1])),fn?fn(ret):eval(ret))</div><div class=\"line\">        :void 0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">T=plus.tools,</div><div class=\"line\">B=plus.bridge</div></pre></td></tr></table></figure>\n<p>synExecXhr的全称是“同步调用XML HTTP Request”，前面我们提到了plus.bridge的实现中我们可以看到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">synExecXhr: new XMLHttpRequest()</div></pre></td></tr></table></figure>\n<p>可以看到，synExecXh实际是一个XMLHttpRequest对象，通过它最后将调用信息以http请求的方式发出去。我们在Native端利用oc-runtime hook住UIAlertView的构造函数，添加断点，可以看到调用栈如下图所示：</p>\n<p><img src=\"5+.png\" alt=\"\"></p>\n<p>可以看到，JS调用到Native端通过DCAsycSocket以这种进程间通信的方式来实现，并且在非主线程完成。至此，我们可以得知，native.js中js与native端的通信是通过本地socket同步通信的方式完成的，完成调用之后，调用结果会以字符串的形式保存在<code>sync.responseText</code>中，js端再通过evaluate其中的字符串来得到返回结果。</p>\n<p>小结：5+runtime还是基于WebView来做事，属于hybrid流派，通过本地socket通信方式来实现JS与Native的混合调用，支持动态导入native类对象，进行实例化、方法调用、属性访问等操作，与一般的hybrid技术不同的是，不需要native工程师来提供模块或者插件来支持扩展js的能力，web工程是可以参考native的方法调用类似的方式（只需要简单的修改），实现对native对象的访问。同时5+runtime还提供了一些跨平台的通用组件，如摄像头、陀螺仪、文件系统等。使用native.js技术所需要注意的问题就是性能问题，动态导入和访问native对象以及数据类型转化需要付出一定的性能损耗代价，官方给出了一些建议来进行性能优化。另外，值得一提的是DCloud公司还用HTML5做了一套模拟Native UI的开源项目MUI，有兴趣可以参考<a href=\"https://github.com/dcloudio/mui\" target=\"_blank\" rel=\"external\">这里</a>.</p>\n<p>优点：</p>\n<ul>\n<li>web端可以直接访问native的api，调用接口参考</li>\n<li><p>提供一套native样式库：MUI</p>\n<p>缺点：</p>\n</li>\n<li><p>与native交互性能有点弱</p>\n</li>\n</ul>\n<h2 id=\"Titanium\"><a href=\"#Titanium\" class=\"headerlink\" title=\"Titanium\"></a>Titanium</h2><p>Titanium:”Write in JavaScript, run native everywhere”.</p>\n<p>Titanium与PhoneGap不同，并不是基于WebView来做跨平台开发，属于JavaSciptBridge流派，关于它与PhoneGap的对比可以参考<a href=\"http://www.appcelerator.com/blog/2012/05/comparing-titanium-and-phonegap/\" target=\"_blank\" rel=\"external\">这篇文章</a>。值得一提的是，Titanium的上层语言并没有采用HTML+CSS+ JavaScript，而是XML+JSON+JavaScript，这增加了一定的学习成本。</p>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><p>ReactNative:”learn once，write anywhere”.</p>\n<p>ReactNative和Titanium的思路很像，也抛弃了WebView，属于JavaSciptBridge流派。ReactNative用JavaScript编写程序，渲染的界面全部都是Natvie的。<a href=\"https://facebook.github.io/react/\" target=\"_blank\" rel=\"external\">React</a>是前端的知名开发库，程序代码通过操作Virturl DOM来编写程序，React runtime负责操作和更新真正的DOM节点，而这个更新是通过diff做增量更新，这提高性能，ReactNative沿用了React的编程模型和更新模型。</p>\n<p>ReactNative的JS运行在与应用主线程独立的线程，通过异步操作与Natvie接口通信，线程模型可以参考下图：</p>\n<p><img src=\"移动端混合编程/reactnative.png\" alt=\"\"></p>\n<p>JS解释器可以运行于手机中的独立线程，也可以远程调试时运行在浏览器中，另外，I/O操作、图片解码、布局信息计算等其他一些消耗CPU的操作也可以放到独立线程中，iOS应用主线程用来操作UI控件和Native API访问，JS线程与UI主线程之间通过ReactNative桥接进行异步通信，实现JS与Objective-C之间的相互调用。</p>\n<p><img src=\"移动端混合编程/reactnative2.png\" alt=\"\"></p>\n<h3 id=\"React-Native通信机制源码分析\"><a href=\"#React-Native通信机制源码分析\" class=\"headerlink\" title=\"React Native通信机制源码分析\"></a>React Native通信机制源码分析</h3><p>源码分析基于React Native v0.23.1,不过下载了目前的最新版0.38.0调试了，实现方式大同小异。</p>\n<p>React Native 的思路就是将Native方法导出给JS用，使得用户可以用JS编写程序，而采用原生控件构建构建应用。<br>React Native 导出以模块（Module）为单位，在程序启动时，加载需要注册到js中的module，挂到js解释器的__fbBatchedBridgeConfig变量上，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;remoteModuleConfig&quot;:[</div><div class=\"line\"></div><div class=\"line\">[&quot;RCTStatusBarManager&quot;,</div><div class=\"line\">\t[&quot;getHeight&quot;,&quot;setStyle&quot;,&quot;setHidden&quot;,&quot;setNetworkActivityIndicatorVisible&quot;]],</div><div class=\"line\">[&quot;RCTSourceCode&quot;,</div><div class=\"line\">\t&#123;&quot;scriptURL&quot;:&quot;http:\\/\\/localhost:8081\\/index.ios.bundle?platform=ios&amp;dev=true&amp;hot=true&quot;&#125;,</div><div class=\"line\">\t[&quot;getScriptText&quot;],[0]]</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>React Native还在不断的迭代开发中，不同版本的实现方式可能不同，例如，在<a href=\"http://blog.cnbang.net/tech/2698/\" target=\"_blank\" rel=\"external\">React Native通信机制详解</a>一文中介绍，Natvie模块的注册方式是通过在利用编译指令将需要导出的模块存储到执行文件的二进制DATA端，程序启动时再从中读取导出的模块信息，我使用的源码是v0.23.1版本，可以看到，需要bridge的模块需要使用<code>RCTRegisterModule</code>宏，其展开如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define RCT_EXPORT_MODULE(js_name) \\</div><div class=\"line\">RCT_EXTERN void RCTRegisterModule(Class); \\</div><div class=\"line\">+ (NSString *)moduleName &#123; return @#js_name; &#125; \\</div><div class=\"line\">+ (void)load &#123; RCTRegisterModule(self); &#125;</div></pre></td></tr></table></figure>\n<p>可以看到，bridge的模块在load方法中进行注册，注册的模块保存在RCTBridge.m的<code>static NSMutableArray&lt;Class&gt; *RCTModuleClasses;</code>全局静态变量中。模块中需要bridge的方法使用<code>RCT_EXPORT_METHOD</code>宏，默认情况下，使用OC方法的第一个分号之前的部分作为JS中的调用名称，例如模块ModuleName中，需要导出的方法<code>- (void)doSomething:(NSString *)aString withA:(NSInteger)a andB:(NSInteger)b</code>，需要写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomething:(NSString *)aString</div><div class=\"line\">                   withA:(NSInteger)a</div><div class=\"line\">                   andB:(NSInteger)b)</div><div class=\"line\"> &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>最终JS的调用形式是<code>NativeModules.ModuleName.doSomething</code>。</p>\n<p>应用启动时，会创建一个CADisplayLink添加到线程（真机上是JS线程，模拟器上是主线程）的runloop中，周期性的调用JS的callFunctionReturnFlushedQueue方法，这个方法的作用就是从一个MessageQueue中取出消息内容。JS调用OC方法，会将调用的信息（moduleID、methodID、params）保存在这个MessageQueue中。</p>\n<p>这里需要说明一下：测试发现，在模拟器中，JS线程与Native端使用RCTSRWebSocketExecutor来进行通信，在真机上，使用RCTJSCExecutor来执行js脚本，在RCTJSCExecutor中可以看到对它的说明<strong>Uses a JavaScriptCore context as the execution engine.</strong>。</p>\n<p>回到刚才的话题，调用callFunctionReturnFlushedQueue之后，会从MessageQueue取出调用信息，已json字符串的形式返回给native端，native端通过RCTJSONParse接口parse出调用信息，信息包括模块id,方法id,参数,以及可能的回调id，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;__NSCFArray 0x7f8bd1610e60&gt;(</div><div class=\"line\"></div><div class=\"line\">//moduleIDs</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16c4ae0&gt;(</div><div class=\"line\">56,</div><div class=\"line\">33,</div><div class=\"line\">33,</div><div class=\"line\">34</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\"></div><div class=\"line\">//methodIDs</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16f0400&gt;(</div><div class=\"line\">1,</div><div class=\"line\">5,</div><div class=\"line\">4,</div><div class=\"line\">0</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\"></div><div class=\"line\">//params</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16396c0&gt;(</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16f7d60&gt;(</div><div class=\"line\">ws://localhost:8097/devtools,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">280</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd163d350&gt;(</div><div class=\"line\">29,</div><div class=\"line\">RCTView,</div><div class=\"line\">1,</div><div class=\"line\">&lt;null&gt;</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd162e670&gt;(</div><div class=\"line\">7,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16e4c90&gt;(</div><div class=\"line\">29</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16f0d90&gt;(</div><div class=\"line\">5</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd1621a10&gt;(</div><div class=\"line\">5</div><div class=\"line\">)</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16c7670&gt;(</div><div class=\"line\">5,</div><div class=\"line\">2,</div><div class=\"line\">3</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">//callID</div><div class=\"line\">1171</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>我们先来看下JS部分是如何创建这个队列以及将这些消息调用信息保存在队列中的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//BatchedBridge.js</div><div class=\"line\">const BatchedBridge = new MessageQueue(</div><div class=\"line\">  __fbBatchedBridgeConfig.remoteModuleConfig,</div><div class=\"line\">  __fbBatchedBridgeConfig.localModulesConfig,</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>前面提到过<strong>fbBatchedBridgeConfig.remoteModuleConfig是Native端注册的模块，</strong>fbBatchedBridgeConfig.localModulesConfig是JS本地模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//MessageQueue.js</div><div class=\"line\">constructor(remoteModules, localModules) &#123;</div><div class=\"line\">    this.RemoteModules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">    this._callableModules = &#123;&#125;;</div><div class=\"line\">    this._queue = [[], [], [], 0];</div><div class=\"line\">    this._moduleTable = &#123;&#125;;</div><div class=\"line\">    this._methodTable = &#123;&#125;;</div><div class=\"line\">    this._callbacks = [];</div><div class=\"line\">    this._callbackID = 0;</div><div class=\"line\">    this._callID = 0;</div><div class=\"line\">    this._lastFlush = 0;</div><div class=\"line\">    this._eventLoopStartTime = new Date().getTime();</div><div class=\"line\"></div><div class=\"line\">    [</div><div class=\"line\">      &apos;invokeCallbackAndReturnFlushedQueue&apos;,</div><div class=\"line\">      &apos;callFunctionReturnFlushedQueue&apos;,</div><div class=\"line\">      &apos;flushedQueue&apos;,</div><div class=\"line\">    ].forEach((fn) =&gt; this[fn] = this[fn].bind(this));</div><div class=\"line\"></div><div class=\"line\">    let modulesConfig = this._genModulesConfig(remoteModules);</div><div class=\"line\">    </div><div class=\"line\">    //构建模块信息</div><div class=\"line\">    this._genModules(modulesConfig);</div><div class=\"line\">    localModules &amp;&amp; this._genLookupTables(</div><div class=\"line\">      this._genModulesConfig(localModules),this._moduleTable, this._methodTable</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    this._debugInfo = &#123;&#125;;</div><div class=\"line\">    this._remoteModuleTable = &#123;&#125;;</div><div class=\"line\">    this._remoteMethodTable = &#123;&#125;;</div><div class=\"line\">    this._genLookupTables(</div><div class=\"line\">      modulesConfig, this._remoteModuleTable, this._remoteMethodTable</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>里面调用this._genModules(modulesConfig);，最后会调到_genModule。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//config是module信息，包括模块名，导出方法名列表等，moduleID模块对应的id（这个ID就是模块在remoteModules数组中的索引）</div><div class=\"line\">_genModule(config, moduleID) &#123;</div><div class=\"line\">    if (!config) &#123;</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let moduleName, constants, methods, asyncMethods;</div><div class=\"line\">    if (moduleHasConstants(config)) &#123;</div><div class=\"line\">      [moduleName, constants, methods, asyncMethods] = config;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      [moduleName, methods, asyncMethods] = config;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let module = &#123;&#125;;</div><div class=\"line\">    methods &amp;&amp; methods.forEach((methodName, methodID) =&gt; &#123;</div><div class=\"line\">      const methodType =</div><div class=\"line\">        asyncMethods &amp;&amp; arrayContains(asyncMethods, methodID) ?</div><div class=\"line\">          MethodTypes.remoteAsync : MethodTypes.remote;</div><div class=\"line\">      //构建方法信息</div><div class=\"line\">      module[methodName] = this._genMethod(moduleID, methodID, methodType);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    Object.assign(module, constants);</div><div class=\"line\"></div><div class=\"line\">    if (!constants &amp;&amp; !methods &amp;&amp; !asyncMethods) &#123;</div><div class=\"line\">      module.moduleID = moduleID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//构建的module信息保存在RemoteModules中</div><div class=\"line\">    this.RemoteModules[moduleName] = module;</div><div class=\"line\">    return module;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>调用this._genMethod构建方法信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">//module：模块ID,method：方法ID（是方法在方法名列表中的索引），type：&quot;remote，remoteAsync&quot;，区分是同步调用还是异步调用，异步调用用Promise实现</div><div class=\"line\">  _genMethod(module, method, type) &#123;</div><div class=\"line\">    let fn = null;</div><div class=\"line\">    let self = this;</div><div class=\"line\">    if (type === MethodTypes.remoteAsync) &#123;</div><div class=\"line\">      fn = function(...args) &#123;</div><div class=\"line\">        return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">          self.__nativeCall(</div><div class=\"line\">            module,</div><div class=\"line\">            method,</div><div class=\"line\">            args,</div><div class=\"line\">            (data) =&gt; &#123;</div><div class=\"line\">              resolve(data);</div><div class=\"line\">            &#125;,</div><div class=\"line\">            (errorData) =&gt; &#123;</div><div class=\"line\">              var error = createErrorFromErrorData(errorData);</div><div class=\"line\">              reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      fn = function(...args) &#123;</div><div class=\"line\">        let lastArg = args.length &gt; 0 ? args[args.length - 1] : null;</div><div class=\"line\">        let secondLastArg = args.length &gt; 1 ? args[args.length - 2] : null;</div><div class=\"line\">        let hasSuccCB = typeof lastArg === &apos;function&apos;;</div><div class=\"line\">        let hasErrorCB = typeof secondLastArg === &apos;function&apos;;</div><div class=\"line\">        hasErrorCB &amp;&amp; invariant(</div><div class=\"line\">          hasSuccCB,</div><div class=\"line\">          &apos;Cannot have a non-function arg after a function arg.&apos;</div><div class=\"line\">        );</div><div class=\"line\">        let numCBs = hasSuccCB + hasErrorCB;</div><div class=\"line\">        let onSucc = hasSuccCB ? lastArg : null;</div><div class=\"line\">        let onFail = hasErrorCB ? secondLastArg : null;</div><div class=\"line\">        args = args.slice(0, args.length - numCBs);</div><div class=\"line\">        return self.__nativeCall(module, method, args, onFail, onSucc);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    fn.type = type;</div><div class=\"line\">    return fn;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这里我们可以看到，__nativeCall的调用被包装在一个function中，这个function作为first-classed Value被返回，已<key,value>的形式保存在module信息中。我们开看到，native调用的成功和失败回调函数也是在这里传入。</key,value></p>\n<p>至此，Native方法的调用映射表构建完成。下面是JS端网络接口的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var RCTNetworkingNative = require(&apos;NativeModules&apos;).Networking;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * This class is a wrapper around the native RCTNetworking module.</div><div class=\"line\"> */</div><div class=\"line\">class RCTNetworking &#123;</div><div class=\"line\"></div><div class=\"line\">  static sendRequest(query, callback) &#123;</div><div class=\"line\">    RCTNetworkingNative.sendRequest(query, callback);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  static abortRequest(requestId) &#123;</div><div class=\"line\">    RCTNetworkingNative.cancelRequest(requestId);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">module.exports = RCTNetworking;</div></pre></td></tr></table></figure>\n<p>可以看到，RCTNetworking最终调用的是Native映射表中的本地方法。</p>\n<p>我们继续来看__nativeCall的实现，这里很重要。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __nativeCall(module, method, params, onFail, onSucc) &#123;</div><div class=\"line\"> </div><div class=\"line\"> \t//(1)</div><div class=\"line\">   if (onFail || onSucc) &#123;</div><div class=\"line\">     // eventually delete old debug info</div><div class=\"line\">     (this._callbackID &gt; (1 &lt;&lt; 5)) &amp;&amp;</div><div class=\"line\">       (this._debugInfo[this._callbackID &gt;&gt; 5] = null);</div><div class=\"line\"></div><div class=\"line\">     this._debugInfo[this._callbackID &gt;&gt; 1] = [module, method];</div><div class=\"line\">     onFail &amp;&amp; params.push(this._callbackID);</div><div class=\"line\">     this._callbacks[this._callbackID++] = onFail;</div><div class=\"line\">     onSucc &amp;&amp; params.push(this._callbackID);</div><div class=\"line\">     this._callbacks[this._callbackID++] = onSucc;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   global.nativeTraceBeginAsyncFlow &amp;&amp;</div><div class=\"line\">     global.nativeTraceBeginAsyncFlow(TRACE_TAG_REACT_APPS, &apos;native&apos;, this._callID);</div><div class=\"line\">   this._callID++;</div><div class=\"line\"></div><div class=\"line\">//（2）</div><div class=\"line\">   this._queue[MODULE_IDS].push(module);</div><div class=\"line\">   this._queue[METHOD_IDS].push(method);</div><div class=\"line\">   this._queue[PARAMS].push(params);</div><div class=\"line\"></div><div class=\"line\">//(3)</div><div class=\"line\">   var now = new Date().getTime();</div><div class=\"line\">   if (global.nativeFlushQueueImmediate &amp;&amp;</div><div class=\"line\">       now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123;</div><div class=\"line\">     global.nativeFlushQueueImmediate(this._queue);</div><div class=\"line\">     this._queue = [[], [], [], this._callID];</div><div class=\"line\">     this._lastFlush = now;</div><div class=\"line\">   &#125;</div><div class=\"line\">   Systrace.counterEvent(&apos;pending_js_to_native_queue&apos;, this._queue[0].length);</div><div class=\"line\">   if (__DEV__ &amp;&amp; SPY_MODE &amp;&amp; isFinite(module)) &#123;</div><div class=\"line\">     console.log(&apos;JS-&gt;N : &apos; + this._remoteModuleTable[module] + &apos;.&apos; +</div><div class=\"line\">       this._remoteMethodTable[module][method] + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>代码说明：<br>（1）往params中添加回调回调方法对应的id，可以看到，回调id保存在params数组最后，还会记录debug信息。<br>（2）将native调用信息添加到MessageQueue，可以看到，MessageQueue的格式是<code>this._queue = [[], [], [], this._callID];</code>，moduleID、methodID和params分别被加入到MessageQueue中不同数组中，所以就看到了前面我们打印出来的Native端收到的数据格式。<br>（3）如果是要求立即调用并且超时，则会调用global.nativeFlushQueueImmediate接口。这里我查找了下代码，js端和native端并没有为global.nativeFlushQueueImmediate，可见一般不会进入这个流程，一般还是使用前面介绍的Native定时驱动的方式来获取MessageQueue中的调用信息。但是，既然有这个值，说明是支持js主动调用到native端的，那又是如何实现的呢？</p>\n<p>在RCTJSCExecutor.m文件中的setUp方法，我们看到这样一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self addSynchronousHookWithName:@&quot;nativeFlushQueueImmediate&quot; usingBlock:^(NSArray&lt;NSArray *&gt; *calls)&#123;</div><div class=\"line\">    RCTJSCExecutor *strongSelf = weakSelf;</div><div class=\"line\">    if (!strongSelf.valid || !calls) &#123;</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    RCT_PROFILE_BEGIN_EVENT(0, @&quot;nativeFlushQueueImmediate&quot;, nil);</div><div class=\"line\">    [strongSelf-&gt;_bridge handleBuffer:calls batchEnded:NO];</div><div class=\"line\">    RCT_PROFILE_END_EVENT(0, @&quot;js_call&quot;, nil);</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<p>再看addSynchronousHookWithName的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)addSynchronousHookWithName:(NSString *)name usingBlock:(id)block</div><div class=\"line\">&#123;</div><div class=\"line\">  __weak RCTJSCExecutor *weakSelf = self;</div><div class=\"line\">  [self executeBlockOnJavaScriptQueue:^&#123;</div><div class=\"line\">    weakSelf.context.context[name] = block;</div><div class=\"line\">  &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们发现，这里是将native的方法挂到js解释器的全局上下文上，这样js端就可以直接调用这些native方法。除了nativeFlushQueueImmediate以外，还有其他一些全局方法。</p>\n<p>至此，我们看到了JS端如何调用组织数据发送给Native端，那Native端拿到数据之后是如何处理的呢？</p>\n<p>我跟踪了JS调用创建UIView的过程(通过hook UIView的initWithFrame方法，加断点进行测试)，其导出的Native方法在RCTUIManager.m中，方法签名如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">createView:(nonnull NSNumber *)reactTag</div><div class=\"line\">                  viewName:(NSString *)viewName</div><div class=\"line\">                  rootTag:(__unused NSNumber *)rootTag</div><div class=\"line\">                  props:(NSDictionary *)props</div></pre></td></tr></table></figure>\n<p>创建UIView的流程如下：<br>Native端接收到数据，传给RCTBatchedBridge.m中的handleBuffer函数处理，从中解析出多组信息，每组信息包括模块id,方法id,参数,以及可能的回调id，用匿名block将每组信息包起来（这里我们取个名叫block1），放到moduleID所对应的RCTModuleData的methodQueue中异步执行，RCTModuleData是对module示例的包装，methodQueue是由module实例返回，由于iOS对UI的操作一般需要放在这线程，所以可以看到，UI相关的module的method的queue的实现返回的都是主线程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//RCTActionSheet.m</div><div class=\"line\">- (dispatch_queue_t)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  return dispatch_get_main_queue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同时，还会往methodQueue中添加匿名block（这里我们取个名叫block2）的异步操作。block1执行时，首先根据moduleID在全局表中查找到对应的Module（RCTModuleData，ModuleData的创建会根据前面提到的RCTModuleClasses中的Class一一对应创建，保存在RCTBatchedBridge.m中的<code>NSArray&lt;RCTModuleData *&gt; *_moduleDataByID;</code>中），然后再根据methodID在Module中找到相应的方法RCTBridgeMethod（RCTBridgeMethod是对native方法的封装，内部会持有一个NSInvocation），为内部的_invocation设置参数并调用。这时实际调用的就是我们导出的Natvie方法了（也就是前面的createView: viewName:rootTag:props:），他会将创建UI的操作再次封装成一个个block（这里我们取个名叫block3），放到一个集合<code>NSMutableArray&lt;dispatch_block_t&gt; *_pendingUIBlocks;</code>中，当block2执行时，会从_pendingUIBlocks中逐个取出block3并执行，从而创建出相应的Natvie UI。</p>\n<p>如果调用Natvie之后，JS端需要CallBack被调用，会将CallBackID通过参数传给Native，Native函数执行完成之后，会通过发送json字符串的形式发送给JS调用结果，其中会带上CallBackID以及此次发送消息的ID。</p>\n<p>在查看ReactNative源码之前，本以为JS与OC之前的通信是通过利用JavaScriptCore进行JSBinding这种静态绑定的方式，查看源码之后才发现不是这样。通过上面对源码的分析，可以看到，RN自己实现以一套通信模式，JS与OC之间的调用采用动态查找的方式来实现，JS和Native工作于独立的线程，线程间根据一套基于ID映射协议的方式来进行通信，这样的动态查找的方式通信成本会高一些，为什么没有用JSBinding的方式，个人理解主要有一下两点原因。</p>\n<ol>\n<li>ReactNative 的目标是跨平台，并不是所有平台都采用JavaScriptCore引擎，另外，iOS7之前 JavaScriptCore也没有开发出来。</li>\n<li>ReactNative 的 JS 代码工作在独立线程（非主线程），如果采用静态绑定的方式，无法或者很难保证对UI的操作工作在主线程。</li>\n</ol>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><p>(1)Native</p>\n<p><img src=\"移动端混合编程/p-native.gif\" alt=\"\"></p>\n<p>(2)ReactNative</p>\n<p><img src=\"移动端混合编程/p-rn.gif\" alt=\"\"></p>\n<p>性能测试采用 RN v0.38.0，测试环境：iphone6,iOS9.3.2，测试用例，点击‘GO’按钮，push(带动画)一个新页面，新页面包含一个列表，首屏展示6项，向上滑动，总共展示20项，列表使用的数据是本地数据。测试数据如下，其中</p>\n<ul>\n<li>响应时间：从点击button开始构建页面，到页面完全构建完成（viewDidAppear）的时间</li>\n<li>页面构建内存开销：从点击button开始构建页面，到页面构建完成内存的增量</li>\n<li>页面滚动之后内存开销：向下滑动，加载所有的cell之后的内存增量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">测试数据</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">页面构建内存开销(MB)</th>\n<th style=\"text-align:center\">页面滚动之后内存开销(MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">React Native</td>\n<td style=\"text-align:center\">831</td>\n<td style=\"text-align:center\">2.56</td>\n<td style=\"text-align:center\">0.50</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Native</td>\n<td style=\"text-align:center\">555</td>\n<td style=\"text-align:center\">1.29</td>\n<td style=\"text-align:center\">1.36</td>\n</tr>\n</tbody>\n</table>\n<p>从体验上点击响应的顺滑程度明显native要顺滑很多，从上面的gif图中也可以看出。另外，内存开销上RN首屏列表开销明显高于Native。这里需要补充说明：React Native的ListView并不是使用UITableView实现，而是自己采用UIView实现的，这一点可以从视图层级中看出，如下图：</p>\n<p><img src=\"移动端混合编程/reactnative-scrollview.png\" alt=\"\"></p>\n<p>ListView的缓存策略也是自己做的，从<a href=\"https://github.com/facebook/react-native/issues/499\" target=\"_blank\" rel=\"external\">这里</a>得知，React Native的ListView的”Cell”每次都是重新创建，之所以这么做原因是RN认为UITableView<br>的复用存在“脏数据”的问题，而且，在现在的手机设备上，创建新的cell已经足够快。当”Cell”划出屏幕，相应的“Cell”会被从view tree上取下来，但并不会销毁，只有当内存警告或者列表项太多时，会有Cell的销毁工作，下次使用，再重新构建出来。</p>\n<p>其实，ListView在RN中无法用UITableView实现，原因是，如前面所介绍，JS对Native的调用是异步操作，而且消息派发的驱动是Native端做的，试想一下，如果采用UITableView来做，在列表页快速滚动的时候，JS端是不能立刻同步获取下一个Cell来展示的。RN现在的实现方式是用ScrollView来实现，并且会预先创建若干个Cell来用户快速滑动时，下一个Cell的展示。测试发现，对于DataSource有20个数据，首屏只能显示6个cell的情况下，Native端首屏会创建6个cell，总共会创建7个（缓速的滑动）；React Native首屏会创建17个cell（用于快速滑动展示而预创建），总共会创建20个。</p>\n<p>优点：</p>\n<ul>\n<li>JS与native的异步通信，脚本不会卡住主线程</li>\n<li>原生的控件+原生的体验</li>\n<li>热调试能力</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>JS与native的异步通信</li>\n<li>门槛较高</li>\n<li>仅面向React前端开发</li>\n</ul>\n<h2 id=\"samurai-native\"><a href=\"#samurai-native\" class=\"headerlink\" title=\"samurai-native\"></a>samurai-native</h2><p>samurai-native的思路跟ReactNatvie的思路是一样的，也是将native的接口导给web端使用，而界面的渲染采用natvie控件，它与RN区别主要有两点：</p>\n<p>(1)表达语法是HTML+CSS;</p>\n<p>(2)标签名称与Native的View的名称对应，RN中由于对标签进行了抽象，有些标签与Native类名称上并不能对应，React Native书写一个tableview cell如下，可以看出，和原生的写法的命名有差异。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;TouchableHighlight onPress=&#123;() =&gt; this.rowPressed(rowData.guid)&#125;</div><div class=\"line\">                underlayColor=&apos;#dddddd&apos;&gt;</div><div class=\"line\">              &lt;View&gt;</div><div class=\"line\">                &lt;View style=&#123;styles.rowContainer&#125;&gt;</div><div class=\"line\">                  &lt;Image style=&#123;styles.thumb&#125; source=&#123;&#123; uri: rowData.img_url &#125;&#125; /&gt;</div><div class=\"line\">                  &lt;View  style=&#123;styles.textContainer&#125;&gt;</div><div class=\"line\">                    &lt;Text style=&#123;styles.price&#125;&gt;£&#123;price&#125;&lt;/Text&gt;</div><div class=\"line\">                    &lt;Text style=&#123;styles.title&#125;</div><div class=\"line\">                          numberOfLines=&#123;1&#125;&gt;&#123;rowData.title&#125;&lt;/Text&gt;</div><div class=\"line\">                  &lt;/View&gt;</div><div class=\"line\">                &lt;/View&gt;</div><div class=\"line\">                &lt;View style=&#123;styles.separator&#125;/&gt;</div><div class=\"line\">              &lt;/View&gt;</div><div class=\"line\">            &lt;/TouchableHighlight&gt;</div></pre></td></tr></table></figure>\n<p>关于samurai-native的介绍可以参考他在infoq上的<a href=\"http://www.infoq.com/cn/presentations/semi-hybrid-app-framework\" target=\"_blank\" rel=\"external\">演讲</a>。</p>\n","excerpt":"<p>本文主要介绍笔者前些日子对市面上一些移动端混合编程方案的实现方式上的调研，读者可以据此了解移动端目前常见的一些混合开发框架的实现原理，欢迎读者在本文基础上做更深入的探索和调研，如有纰漏，欢迎指正。","more":"</p>\n<p>本文示例代码链接: <a href=\"https://github.com/jackwee/hybrid-demos\">https://github.com/jackwee/hybrid-demos</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li><p>2008年，HTML5发布首个版本。</p>\n</li>\n<li><p>2011年，Facebook开展<a href=\"http://techcrunch.com/2011/06/15/facebook-project-spartan/\">Spartan</a>项目，企图用HTML5的思想武装自己，占领iOS的浏览器，以此来与苹果抗衡。因为浏览器是相对开放的，Apple总不可能在浏览器端设置一个开关对网页内容进行限制。</p>\n</li>\n<li><p>2012年，Mark Zuckerberg:”the biggest mistake that we made as a company is betting too much on HTML5 as opposed to native.”Facebook放弃HTML5，转投Native。</p>\n</li>\n<li>2015年，Facebook发布react-native。</li>\n</ul>\n<p>如今，混合开发的呼声越来越高，世面上也有很多混合开发框架，采用混合开发的应用也是越来越多。</p>\n<p>以下将从什么是混合开发、为什么要做混合开发、移动端都在怎么做混合开发来做逐步介绍。</p>\n<hr>\n<font color=#CC0033 size=6px>What?</font>\n\n<p>两种或两种以上的程序设计语言的邂逅。</p>\n<ul>\n<li>JNI:Java与C/C++的混合开发</li>\n<li>iOS中Objective-C与C、Swift与C的混合开发</li>\n<li>ReactNative中JavaScript与Native语言的混合开发</li>\n</ul>\n<p>本文介绍和调研的主要是移动平台上WEB(WebView、JavaScript)与Native语言的混合开发。</p>\n<font color=#CC0033 size=6px>Why?</font>\n\n<h1 id=\"Web-amp-Native\"><a href=\"#Web-amp-Native\" class=\"headerlink\" title=\"Web &amp; Native\"></a>Web &amp; Native</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对比</th>\n<th style=\"text-align:center\">Web</th>\n<th style=\"text-align:center\">Native</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">优势</td>\n<td style=\"text-align:center\">跨平台、开发效率高、方便调试、方便部署</td>\n<td style=\"text-align:center\">性能体验好、访问Low API、强大的IDE、原生的动画、系统手势</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">存在问题</td>\n<td style=\"text-align:center\">性能问题、浏览器兼容性问题、访问Low API受限、需要模拟原生动画和手势</td>\n<td style=\"text-align:center\">平台依赖性强、调试不便、应用更新周期长、开发效率低</td>\n</tr>\n</tbody>\n</table>\n<p>混合编程就是为了将两者的优点结合起来，做到“兼得🐟和🐻👐”。</p>\n<font color=#CC0033 size=6px>How?</font>\n\n<h1 id=\"那些混合编程们\"><a href=\"#那些混合编程们\" class=\"headerlink\" title=\"那些混合编程们\"></a>那些混合编程们</h1><p>目前移动端主流的混合开发有两个流派，一个是基于WebView做混合开发的Hybrid流派，一个是基于虚拟机做混合开发的’JavaSciptBridge’流派。</p>\n<ol>\n<li>WebViewBridge流派(Hybrid流派):基于WebView做与Native语言的混合开发<ul>\n<li><a href=\"http://phonegap.com/\">PhoneGap</a> / <a href=\"https://cordova.apache.org\">Cordova</a></li>\n<li><a href=\"http://www.apicloud.com/superwebview\">SuperWebView</a></li>\n<li><a href=\"http://dcloud.io/runtime.html#toDownload\">5+Runtime &amp; Native.js</a></li>\n</ul>\n</li>\n<li>‘JavaScipt Bridge’流派(JSBinding,LuaBinding,自定义消息传递):基于脚本语言本身做与Native语言的混合开发<ul>\n<li><a href=\"http://www.appcelerator.com/mobile-app-development-products/\">Titanium</a></li>\n<li><a href=\"https://facebook.github.io/react-native/\">ReactNative</a></li>\n<li><a href=\"https://github.com/hackers-painters/samurai-native\">samurai-native</a></li>\n</ul>\n</li>\n</ol>\n<p>另外，还有翻译流派，如<a href=\"http://j2objc.org/\">J2ObjC</a>将Java语言翻译成Objective-C，编译流派，如<a href=\"http://xamarin.com/\">Xamarin</a>直接C#编译为二进制文件来开发iOS应用，这两种做法相对比较小众，本文并不做探讨。</p>\n<h2 id=\"PhoneGap-Cordova\"><a href=\"#PhoneGap-Cordova\" class=\"headerlink\" title=\"PhoneGap/Cordova\"></a>PhoneGap/Cordova</h2><p><code>PhoneGap: &quot;Write Once, Run Anywhere&quot;。</code></p>\n<p>目标是让使用者编写一套代码来实现跨平台操作，它是Hybrid技术的一种实现，赋予WebView访问Native API的能力，屏蔽掉平台相关API实现跨平台开发。</p>\n<p><img src=\"移动端混合编程/Cordova.png\" alt=\"\"></p>\n<p>上图是Cordova的架构图，其中Web App部分是前端开发部分，在WebView上执行。Cordova Plugins是Cordova所提供的用于访问本地代码的插件，这些插件具有操作本地资源的能力，如定位、陀螺仪、相机、联系人等等，此外，用户也可以自定义插件，js代码部分可以通过Cordova Native APIs来访问这些插件。那么这里对插件的调用实际是怎么实现的？</p>\n<p>我们使用一个简单的demo进行测试。</p>\n<p>Native端定义了自定义插件MyHybridPlugin，其中定义了addBookmark方法，在html页面上点击按钮，我们通过cordova调用addBookmark。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1)html</div><div class=\"line\">//页面上添加点击事件处理</div><div class=\"line\">&lt;button id=&quot;bookmarkBtn&quot; onclick=&quot;app.addBookmark()&quot;&gt;Add a bookmark&lt;/button&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">(2)JavaScript(index.js)</div><div class=\"line\">var app = &#123;</div><div class=\"line\">    addBookmark: function() &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        cordova.exec(win, fail, &quot;MyHybridPlugin&quot;, &quot;addBookmark&quot;, [bookmark]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">(3)JavaScript(cordova.js)</div><div class=\"line\">//添加消息到消息队列</div><div class=\"line\">commandQueue.push(JSON.stringify(command));</div><div class=\"line\"></div><div class=\"line\">(4)JavaScript(cordova.js)</div><div class=\"line\">//通过iframe通知native</div><div class=\"line\">pokeNativeViaIframe();</div><div class=\"line\"></div><div class=\"line\">===&gt;</div><div class=\"line\">execIframe = document.createElement(&apos;iframe&apos;);</div><div class=\"line\">execIframe.style.display = &apos;none&apos;;</div><div class=\"line\">execIframe.src = &apos;gap://ready&apos;;</div><div class=\"line\">document.body.appendChild(execIframe);   </div><div class=\"line\"></div><div class=\"line\">(5)Objective-C</div><div class=\"line\">//从js消息队列中取消息内容</div><div class=\"line\">webView:shouldStartLoadWithRequest:navigationType:</div><div class=\"line\">[_commandQueue fetchCommandsFromJs];</div><div class=\"line\"></div><div class=\"line\">(6)JavaScript(cordova.js)</div><div class=\"line\">//以json方式返回消息内容，包括callbackId</div><div class=\"line\">nativeFetchMessages();</div><div class=\"line\"> </div><div class=\"line\">(7)Objective-C</div><div class=\"line\">//根据json内容查找对应的class和selector，并执行相应方法</div><div class=\"line\">- (BOOL)execute:(CDVInvokedUrlCommand*)command</div><div class=\"line\"></div><div class=\"line\">(8)Objective-C</div><div class=\"line\">//回调执行结果，带上callbackId</div><div class=\"line\">sendPluginResult:callbackId:</div><div class=\"line\"></div><div class=\"line\">(9)JavaScript(cordova.js)</div><div class=\"line\">//根据callbackId回调执行结果</div><div class=\"line\">iOSExec.nativeCallback();</div></pre></td></tr></table></figure>\n<p>通过调试发现，cordova是通过将js对native的方法调用信息，封装成一个UIL，并通过iframe的形式加载该url。native端通过UIWebViewDelegate的代理方法<code>webView:shouldStartLoadWithRequest:navigationType:</code>拦截url，并解析出其中的函数签名信息，通过oc的runtime查找对应的类和方法，实现了本地方法调用，并返回本次调用对应的callbackId，cordova会根据该id查找到对应的js回调方法，实现回调给js。</p>\n<p>优点：</p>\n<ul>\n<li>跨平台</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>性能问题：从上面的分析可以看出js到native的调用流程比较繁琐</li>\n<li>对native工程师的依赖：前端工程师需要native开发来提供所需插件</li>\n</ul>\n<h2 id=\"SuperWebView\"><a href=\"#SuperWebView\" class=\"headerlink\" title=\"SuperWebView\"></a>SuperWebView</h2><p><code>SuperWebView:能够帮助原生APP团队解决“如何在短时间内开发出体验好、功能强的HTML5页面”的问题</code></p>\n<p>SuperWebView为web程序员开发App提供一套整体的解决方案，以SDK的方式提供使用（不开源），总结一下主要包括特点：</p>\n<ul>\n<li>管理平台提供上百种模块，平台可以根据用户选取组合的模块构建生成SDK，开发者下载使用放到项目中使用</li>\n<li>支持用户自定义模块，导出给js使用，需要构建静态库，并打包成zip上传到管理平台，由平台编译生成sdk</li>\n<li>利用管理平台，可以进行资源包的热更新</li>\n<li>系统API对象提供的JS接口，可以在使用JS进行以下操作：获取系统属性、系统事件、使用进行封装了的接口</li>\n<li>提供云API来进行：操作云端数据、统计、推送、短信验证等功能</li>\n<li>提供与腾讯X5浏览器的集成（Android）</li>\n</ul>\n<p>下面是SuperWebView的架构图：</p>\n<p><img src=\"移动端混合编程/superwebview.png\" alt=\"\"></p>\n<p>先看右侧部分，上面是SuperWebView提供的页面组织结构，用户可以利用API对象提供的接口创建界面，用户可以创建window（整个界面），frame（界面中的模块界面），frameGroup（一组可以左右滑动浏览的界面），UIModule（native自定义视图）；右侧下面部分是SuperWebView提供的基础服务，并提供了与Native通信的机制；左侧部分是SuperWebView平台已模块的形式提供的可以供JS使用的Native模块单元，官网上有模块管理平台提供了模块可以供开发者使用，开发者也可以根据平台标准自定义模块。</p>\n<p>下面是使用SuperWebView实现的模拟网易云音乐的一个demo示例：</p>\n<p><img src=\"移动端混合编程/superwebview.gif\" alt=\"\"></p>\n<p>主页面的层级结构：</p>\n<p><img src=\"移动端混合编程/superwebview2.png\" alt=\"\"></p>\n<p>可以看到，应用界面可以由多个APIWebView与UIView（或其子类）组合而来，但是这些组合关系并不需要web端开发者来操心，可以借助平台api对象开放的接口调用，平台接口会构建出相应界面的的组合，例如,可以使用下面这样的方式打开一个可以左右滑动的多个页面组合而成的页面，其构建的界面结果就是UIScrollView中横向放置了四个页面，可以左右滑动翻页浏览。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">api.openFrameGroup(&#123;</div><div class=\"line\">        name: &apos;framegroup01&apos;,</div><div class=\"line\">        background: &apos;#FFF&apos;,</div><div class=\"line\">        scrollEnabled: true,</div><div class=\"line\">        rect: &#123;</div><div class=\"line\">            x: 0,</div><div class=\"line\">            y: firstHeaderOffset.h + firstHeaderIndexHeight,</div><div class=\"line\">            w: &quot;auto&quot;,</div><div class=\"line\">            h: api.frameHeight - firstHeaderOffset.h - firstHeaderIndexHeight - footerPos.h</div><div class=\"line\">        &#125;,</div><div class=\"line\">        index: 0,</div><div class=\"line\">        frames: [&#123;</div><div class=\"line\">            name: &apos;frame01_recommand&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_recommand.html&apos;,</div><div class=\"line\">            bounces: false,</div><div class=\"line\">        &#125;, &#123;</div><div class=\"line\">            name: &apos;frame01_list&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_list.html&apos;,</div><div class=\"line\">            bounces: true,</div><div class=\"line\">        &#125;, &#123;</div><div class=\"line\">            name: &apos;frame01_radio&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_radio.html&apos;,</div><div class=\"line\">            bounces: false,</div><div class=\"line\">        &#125;, &#123;</div><div class=\"line\">            name: &apos;frame01_rank&apos;,</div><div class=\"line\">            url: &apos;./html/first_frame/frame01_rank.html&apos;,</div><div class=\"line\">            bounces: false,</div><div class=\"line\">        &#125;]</div><div class=\"line\">    &#125;, function(ret) &#123;</div><div class=\"line\">        setFrameGroupStatus(ret.index);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>我们来看看APIWebView的真面目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface APIWebView : UZWebView</div><div class=\"line\">@interface UZWebView : UIWebView</div></pre></td></tr></table></figure>\n<p>我们看到，APIWebView实际是UIWebView的子类，整个页面结构使用APIWebView嵌套的方式构建。</p>\n<ul>\n<li>通过Instruments在iPhone5s上进行内存测试，对前面云音乐demo反复操作，累计创建11个APIWebView，内存开销在35M左右(创建11个UIWebView，并加载本地类似静态页面内存开销在24M左右)。</li>\n<li>通过对APIWebView的构造方法initWithFrame:和dealloc方法进行拦截，发现在打开新页面是通过[UZWebViewController loadWindow]和[UZWebViewController openFrame:]创建多个APIWebView，再结合Native控件，构建出页面。</li>\n</ul>\n<p>SuperWebView的用户通过对页面结构进行拆分，利用SuperWebView提供的API来构建页面，SuperWebView所提供的API会构建出相应的页面结构，例如上面云音乐demo中的首页面，就是由2个APIWebView和一个UIScrollView嵌套组合而成。至于界面的样式，需要用户用HTML+CSS进行描述。</p>\n<h3 id=\"SuperWebView中JS与Native通信的实现原理\"><a href=\"#SuperWebView中JS与Native通信的实现原理\" class=\"headerlink\" title=\"SuperWebView中JS与Native通信的实现原理\"></a>SuperWebView中JS与Native通信的实现原理</h3><p>下面分析下SuperWebView的实现JS与Native的通信机制。</p>\n<p>测试环境：iPhone5S,iOS8.3和iPhone4S,iOS7.1.1</p>\n<p>我们在JS端调用<code>alert(&quot;alert from js&quot;);</code>接口，利用远程调试进行断点跟踪。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//alert的实现</div><div class=\"line\">function (msg) &#123;</div><div class=\"line\">\t!function(msg)&#123;</div><div class=\"line\">\t\tif(msg===null)&#123;</div><div class=\"line\">\t\t\tmsg=&apos;null&apos;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tif(msg===undefined)&#123;</div><div class=\"line\">\t\t\tmsg=&apos;undefined&apos;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tmsg=msg.toString();</div><div class=\"line\">\t\tapi.alert(&#123;title:&apos;index.html&apos;,msg:msg,buttons:[&apos;好&apos;]&#125;);</div><div class=\"line\">\t&#125;(msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//api.alert的实现</div><div class=\"line\">function () &#123;</div><div class=\"line\">\treturn uz$e(&apos;UZAPI&apos;,&apos;alert&apos;,arguments,false,&apos;api&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">///uz$e的实现</div><div class=\"line\">function uz$e(c, m, p, isSync, module) &#123;</div><div class=\"line\">    var param = &#123;&#125;;</div><div class=\"line\">    </div><div class=\"line\">    //(1)</div><div class=\"line\">    if (p.length === 1) &#123;</div><div class=\"line\">        var p0 = p[0];</div><div class=\"line\">       //(1.1)</div><div class=\"line\">\t\tif (Object.prototype.toString.call(p0) === &quot;[object Object]&quot;) &#123;</div><div class=\"line\">            param = p0;</div><div class=\"line\">        &#125; else if (typeof p0 === &quot;function&quot;) &#123;</div><div class=\"line\">            param.cbId = uz$cb.id++;</div><div class=\"line\">            uz$cb.fn[param.cbId] = p0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else if (p.length === 2) &#123;</div><div class=\"line\">    \t//(1.2)</div><div class=\"line\">        var p0 = p[0];</div><div class=\"line\">        var p1 = p[1];</div><div class=\"line\">        if (Object.prototype.toString.call(p0) === &quot;[object Object]&quot;) &#123;</div><div class=\"line\">            param = p0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (typeof p1 === &quot;function&quot;) &#123;</div><div class=\"line\">            param.cbId = uz$cb.id++;</div><div class=\"line\">            uz$cb.fn[param.cbId] = p1;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//（2）</div><div class=\"line\">    if (typeof(_apiBridgeMethod)===&apos;function&apos;)&#123;</div><div class=\"line\">    \t //(2.1)\t</div><div class=\"line\">        return _apiBridgeMethod(c, m, param, isSync, module);</div><div class=\"line\">    &#125; else if (api.useWKWebView) &#123;</div><div class=\"line\">    \t //(2.2)\t</div><div class=\"line\">        var message = &#123;&#125;;</div><div class=\"line\">        message.class = c;</div><div class=\"line\">        message.method = m;</div><div class=\"line\">        message.param = param;</div><div class=\"line\">        message.isSync = false;</div><div class=\"line\">        message.module = module;</div><div class=\"line\">        window.webkit.messageHandlers.api.postMessage(message);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    \t //(2.3)\t</div><div class=\"line\">        uz$q.c.push(module+&apos;.&apos;+c+&apos;.&apos;+m+&apos;/?&apos;+encodeURIComponent(JSON.stringify(param)));</div><div class=\"line\">        uz$r();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对这段代码进行分析：</p>\n<p>（1）对参数进行处理</p>\n<p>(1.1) 只有一个参数，对调用参数或者回调函数分别处理</p>\n<p>(1.2) 有两个参数，对调用参数和回调函数分别处理</p>\n<p>（2）执行函数调用</p>\n<p>(2.1) 调用_apiBridgeMethod方法，在当前测试环境下，会走2.1的逻辑，其实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function () &#123;</div><div class=\"line\">    [native code]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到_apiBridgeMethod的方法体是native code，那么是如何将native code注册给WebView的JS解释器的呢？</p>\n<p>将APICloud.a中的UZWebView.o反编译出来伪代码看到如下实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">// UZWebView - (void)initJavaScriptCoreBridgeMethod</div><div class=\"line\">void __cdecl -[UZWebView initJavaScriptCoreBridgeMethod](struct UZWebView *self, SEL a2)</div><div class=\"line\">&#123;</div><div class=\"line\">  struct UZWebView *v7; // r8@1</div><div class=\"line\">  void *v8; // r0@1</div><div class=\"line\">  void *v9; // r5@1</div><div class=\"line\">  void *v10; // r0@1</div><div class=\"line\">  void *v11; // r6@1</div><div class=\"line\">  void *v13; // r0@2</div><div class=\"line\">  void *v14; // r6@2</div><div class=\"line\">  void *v15; // r0@2</div><div class=\"line\">  int v16; // r4@2</div><div class=\"line\">  void *v17; // r0@2</div><div class=\"line\">  void *v18; // r5@2</div><div class=\"line\">  int *v19; // r4@3</div><div class=\"line\">  int v23; // [sp+0h] [bp-78h]@1</div><div class=\"line\">  void *v24; // [sp+4h] [bp-74h]@3</div><div class=\"line\">  void *v25; // [sp+8h] [bp-70h]@3</div><div class=\"line\">  void *v26; // [sp+Ch] [bp-6Ch]@3</div><div class=\"line\">  int v27; // [sp+10h] [bp-68h]@3</div><div class=\"line\">  int v28; // [sp+14h] [bp-64h]@3</div><div class=\"line\">  int (__fastcall *v29)(__block_literal_3 *, Foundation::NSString::NSString *, Foundation::NSString::NSString *, Foundation::NSDictionary::NSDictionary *, Foundation::NSString::NSString *, int); // [sp+18h] [bp-60h]@3</div><div class=\"line\">  void *v30; // [sp+1Ch] [bp-5Ch]@3</div><div class=\"line\">  int v31; // [sp+20h] [bp-58h]@1</div><div class=\"line\">  char v32; // [sp+24h] [bp-54h]@3</div><div class=\"line\">  int *v33; // [sp+28h] [bp-50h]@3</div><div class=\"line\">  char v34; // [sp+2Ch] [bp-4Ch]@1</div><div class=\"line\">  int v35; // [sp+30h] [bp-48h]@2</div><div class=\"line\">  void *v36; // [sp+44h] [bp-34h]@1</div><div class=\"line\">  void *v37; // [sp+48h] [bp-30h]@1</div><div class=\"line\">  __int64 *v38; // [sp+4Ch] [bp-2Ch]@1</div><div class=\"line\">  unsigned int v39; // [sp+50h] [bp-28h]@1</div><div class=\"line\">  int *v40; // [sp+54h] [bp-24h]@1</div><div class=\"line\">  char v41; // [sp+60h] [bp-18h]@5</div><div class=\"line\">  __int64 savedregs; // [sp+78h] [bp+0h]@1</div><div class=\"line\"></div><div class=\"line\">  _R4 = (unsigned int)&amp;v31 &amp; 0xFFFFFFF0;</div><div class=\"line\">  __asm</div><div class=\"line\">  &#123;</div><div class=\"line\">    VST1.64         &#123;D8-D11&#125;, [R4@128]!</div><div class=\"line\">    VST1.64         &#123;D12-D15&#125;, [R4@128]</div><div class=\"line\">  &#125;</div><div class=\"line\">  v7 = self;</div><div class=\"line\">  v8 = objc_msgSend(&amp;OBJC_CLASS___UIDevice, &quot;currentDevice&quot;);</div><div class=\"line\">  v9 = (void *)objc_retainAutoreleasedReturnValue(v8);</div><div class=\"line\">  v10 = objc_msgSend(v9, &quot;systemVersion&quot;);</div><div class=\"line\">  v11 = (void *)objc_retainAutoreleasedReturnValue(v10);</div><div class=\"line\">  _R4 = objc_msgSend(v11, &quot;floatValue&quot;);</div><div class=\"line\">  objc_release(v11);</div><div class=\"line\">  objc_release(v9);</div><div class=\"line\">  v36 = &amp;__objc_personality_v0;</div><div class=\"line\">  v37 = &amp;GCC_except_table117;</div><div class=\"line\">  v38 = &amp;savedregs;</div><div class=\"line\">  v40 = &amp;v23;</div><div class=\"line\">  v39 = (((unsigned int)&amp;loc_13E + 2) | 1) + 42164;</div><div class=\"line\">  _Unwind_SjLj_Register(&amp;v34);</div><div class=\"line\">  __asm</div><div class=\"line\">  &#123;</div><div class=\"line\">    VMOV.F32        D0, #7.0</div><div class=\"line\">    VMOV            D1, R4, R4</div><div class=\"line\">    VCMPE.F32       S2, S0</div><div class=\"line\">    VMRS            APSR_nzcv, FPSCR</div><div class=\"line\">  &#125;</div><div class=\"line\">  if ( !(_NF ^ _VF) )</div><div class=\"line\">  &#123;</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v13 = objc_msgSend(v7, &quot;webView&quot;);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v14 = (void *)objc_retainAutoreleasedReturnValue(v13);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v15 = objc_msgSend(v7, &quot;jsContextKeyPath&quot;);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v16 = objc_retainAutoreleasedReturnValue(v15);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v17 = objc_msgSend(v14, &quot;valueForKeyPath:&quot;, v16);</div><div class=\"line\">    v35 = -1;</div><div class=\"line\">    v18 = (void *)objc_retainAutoreleasedReturnValue(v17);</div><div class=\"line\">    objc_release(v16);</div><div class=\"line\">    if ( v18 )</div><div class=\"line\">    &#123;</div><div class=\"line\">      v25 = v14;</div><div class=\"line\">      objc_initWeak(&amp;v32, v7);</div><div class=\"line\">      v26 = &amp;_NSConcreteStackBlock;</div><div class=\"line\">      v27 = -1040187392;</div><div class=\"line\">      v28 = 0;</div><div class=\"line\">      v29 = _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke;</div><div class=\"line\">      v33 = &amp;v31;</div><div class=\"line\">      v30 = &amp;__block_descriptor_tmp_1135;</div><div class=\"line\">      objc_copyWeak(&amp;v31, &amp;v32);</div><div class=\"line\">      v23 = objc_retainBlock(&amp;v26);</div><div class=\"line\">      v35 = 1;</div><div class=\"line\">      v24 = v18;</div><div class=\"line\">      objc_msgSend(v18, &quot;setObject:forKeyedSubscript:&quot;);</div><div class=\"line\">      v19 = v33;</div><div class=\"line\">      objc_release(v23);</div><div class=\"line\">      objc_destroyWeak(v19);</div><div class=\"line\">      objc_destroyWeak(&amp;v32);</div><div class=\"line\">      v14 = v25;</div><div class=\"line\">      v18 = v24;</div><div class=\"line\">    &#125;</div><div class=\"line\">    objc_release(v18);</div><div class=\"line\">    objc_release(v14);</div><div class=\"line\">  &#125;</div><div class=\"line\">  _Unwind_SjLj_Unregister(&amp;v34);</div><div class=\"line\">  _R4 = &amp;v41;</div><div class=\"line\">  __asm</div><div class=\"line\">  &#123;</div><div class=\"line\">    VLD1.64         &#123;D8-D11&#125;, [R4@128]!</div><div class=\"line\">    VLD1.64         &#123;D12-D15&#125;, [R4@128]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们可以看到，首先是利用KVC从UZWebView获得JSContext，然后setObject:forKeyedSubscript:设置_apiBridgeMethod的值为<code>_43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke</code>，它的实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">int __fastcall _43__UZWebView_initJavaScriptCoreBridgeMethod__block_invoke(</div><div class=\"line\">__block_literal_3 *.block_descriptor, </div><div class=\"line\">Foundation::NSString::NSString *a2, </div><div class=\"line\">Foundation::NSString::NSString *method, </div><div class=\"line\">Foundation::NSDictionary::NSDictionary *param, </div><div class=\"line\">Foundation::NSString::NSString *module, </div><div class=\"line\">int a6)</div><div class=\"line\">&#123;</div><div class=\"line\">  Foundation::NSDictionary::NSDictionary *v7; // r5@1</div><div class=\"line\">  Foundation::NSString::NSString *v8; // r4@1</div><div class=\"line\">  int v9; // r10@1</div><div class=\"line\">  int v10; // r4@1</div><div class=\"line\">  void *v11; // r8@1</div><div class=\"line\">  int v12; // r11@1</div><div class=\"line\">  void *v13; // r2@1</div><div class=\"line\">  int v14; // r0@2</div><div class=\"line\">  void *v15; // r0@3</div><div class=\"line\">  void *v16; // ST04_4@4</div><div class=\"line\">  int v17; // r5@4</div><div class=\"line\">  void *v18; // r0@4</div><div class=\"line\">  void *v19; // r8@4</div><div class=\"line\">  void *v20; // r4@4</div><div class=\"line\">  void *v21; // r0@4</div><div class=\"line\">  int v22; // r6@4</div><div class=\"line\">  __block_literal_3 *v24; // [sp+8h] [bp-20h]@1</div><div class=\"line\"></div><div class=\"line\">  v24 = .block_descriptor;</div><div class=\"line\">  v7 = param;</div><div class=\"line\">  v8 = method;</div><div class=\"line\">  v9 = objc_retain(a2);</div><div class=\"line\">  v10 = objc_retain(v8);</div><div class=\"line\">  v11 = (void *)objc_retain(v7);</div><div class=\"line\">  v12 = objc_retain(a6);</div><div class=\"line\">  v13 = objc_msgSend(&amp;OBJC_CLASS___NSDictionary, &quot;class&quot;);</div><div class=\"line\">  if ( (unsigned int)objc_msgSend(v11, &quot;isKindOfClass:&quot;, v13) &amp; 0xFF )</div><div class=\"line\">  &#123;</div><div class=\"line\">    v14 = objc_retain(v11);</div><div class=\"line\">  &#125;</div><div class=\"line\">  else</div><div class=\"line\">  &#123;</div><div class=\"line\">    v15 = objc_msgSend(&amp;OBJC_CLASS___NSDictionary, &quot;dictionaryWithObjects:forKeys:count:&quot;);</div><div class=\"line\">    v14 = objc_retainAutoreleasedReturnValue(v15);</div><div class=\"line\">  &#125;</div><div class=\"line\">  v16 = v11;</div><div class=\"line\">  v17 = v14;</div><div class=\"line\">  v18 = objc_msgSend(&amp;OBJC_CLASS___UZCommand, &quot;alloc&quot;);</div><div class=\"line\">  v19 = objc_msgSend(v18, &quot;initWithClassName:methodName:param:&quot;, v9, v10, v17);</div><div class=\"line\">  objc_release(v10);</div><div class=\"line\">  objc_release(v9);</div><div class=\"line\">  objc_msgSend(v19, &quot;setIsSyncMethod:&quot;, module);</div><div class=\"line\">  objc_msgSend(v19, &quot;setModule:&quot;, v12);</div><div class=\"line\">  objc_release(v12);</div><div class=\"line\">  v20 = (void *)objc_loadWeakRetained(&amp;v24-&gt;weakSelf);</div><div class=\"line\">  v21 = objc_msgSend(v20, &quot;execute:&quot;, v19);</div><div class=\"line\">  v22 = objc_retainAutoreleasedReturnValue(v21);</div><div class=\"line\">  objc_release(v20);</div><div class=\"line\">  objc_release(v19);</div><div class=\"line\">  objc_release(v17);</div><div class=\"line\">  objc_release(v16);</div><div class=\"line\">  return objc_autoreleaseReturnValue(v22);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大概意思是，读取调用信息，根据信息创建一个UZCommand对象，再去执行UZCommand，再看execute的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div></pre></td><td class=\"code\"><pre><div class=\"line\">// UZWebView - (id)execute:(id) </div><div class=\"line\">id __cdecl -[UZWebView execute:](struct UZWebView *self, SEL a2, id a3)</div><div class=\"line\">&#123;</div><div class=\"line\">  struct UZWebView *v3; // r11@1</div><div class=\"line\">  void *v4; // r6@1</div><div class=\"line\">  int v5; // r5@2</div><div class=\"line\">  void *v6; // r0@3</div><div class=\"line\">  int v7; // r10@3</div><div class=\"line\">  void *v8; // r0@3</div><div class=\"line\">  void *v9; // r8@3</div><div class=\"line\">  void *v10; // r0@3</div><div class=\"line\">  void *v11; // r0@3</div><div class=\"line\">  void *v12; // r4@3</div><div class=\"line\">  void *v13; // r0@3</div><div class=\"line\">  int v14; // r5@3</div><div class=\"line\">  void *v15; // r0@3</div><div class=\"line\">  int v16; // r0@3</div><div class=\"line\">  void *v17; // r6@3</div><div class=\"line\">  void *v18; // r0@3</div><div class=\"line\">  void *v19; // r5@3</div><div class=\"line\">  int v20; // r10@4</div><div class=\"line\">  void *v21; // r0@5</div><div class=\"line\">  void *v22; // r4@5</div><div class=\"line\">  void *v23; // r0@5</div><div class=\"line\">  void *v24; // r0@5</div><div class=\"line\">  void *v25; // r6@5</div><div class=\"line\">  void *v26; // r0@5</div><div class=\"line\">  void *v27; // r10@5</div><div class=\"line\">  void *v28; // ST10_4@5</div><div class=\"line\">  void *v29; // r4@5</div><div class=\"line\">  void *v30; // r0@5</div><div class=\"line\">  void *v31; // r0@5</div><div class=\"line\">  int v32; // r4@5</div><div class=\"line\">  void *v33; // r2@6</div><div class=\"line\">  void *v34; // r0@7</div><div class=\"line\">  void *v35; // r0@10</div><div class=\"line\">  int v36; // r8@10</div><div class=\"line\">  int v37; // r6@10</div><div class=\"line\">  int v38; // r11@11</div><div class=\"line\">  void *v39; // r0@12</div><div class=\"line\">  void *v40; // r4@12</div><div class=\"line\">  void *v41; // r0@13</div><div class=\"line\">  int v42; // r4@13</div><div class=\"line\">  void *v43; // r0@16</div><div class=\"line\">  int v44; // r4@16</div><div class=\"line\">  int v46; // [sp+18h] [bp-28h]@4</div><div class=\"line\">  void *v47; // [sp+1Ch] [bp-24h]@10</div><div class=\"line\">  int v48; // [sp+20h] [bp-20h]@3</div><div class=\"line\">  void *v49; // [sp+24h] [bp-1Ch]@3</div><div class=\"line\"></div><div class=\"line\">  v3 = self;</div><div class=\"line\">  v4 = (void *)objc_retain(a3);</div><div class=\"line\">  if ( !((unsigned int)objc_msgSend(v3, &quot;shouldClosed&quot;) &amp; 0xFF) )</div><div class=\"line\">  &#123;</div><div class=\"line\">    v6 = objc_msgSend(v4, &quot;methodName&quot;);</div><div class=\"line\">    v7 = objc_retainAutoreleasedReturnValue(v6);</div><div class=\"line\">    v8 = objc_msgSend(v4, &quot;className&quot;);</div><div class=\"line\">    v9 = (void *)objc_retainAutoreleasedReturnValue(v8);</div><div class=\"line\">    v10 = objc_msgSend(v4, &quot;paramDict&quot;);</div><div class=\"line\">    v48 = objc_retainAutoreleasedReturnValue(v10);</div><div class=\"line\">    v11 = objc_msgSend(v3, &quot;request&quot;);</div><div class=\"line\">    v12 = (void *)objc_retainAutoreleasedReturnValue(v11);</div><div class=\"line\">    v13 = objc_msgSend(v12, &quot;URL&quot;);</div><div class=\"line\">    v14 = objc_retainAutoreleasedReturnValue(v13);</div><div class=\"line\">    v49 = v4;</div><div class=\"line\">    v15 = objc_msgSend(v4, &quot;module&quot;);</div><div class=\"line\">    v16 = objc_retainAutoreleasedReturnValue(v15);</div><div class=\"line\">    objc_release(v16);</div><div class=\"line\">    v17 = v9;</div><div class=\"line\">    objc_release(v14);</div><div class=\"line\">    objc_release(v12);</div><div class=\"line\">    v18 = objc_msgSend((void *)v3-&gt;_moduleDict, &quot;objectForKey:&quot;, v9);</div><div class=\"line\">    v19 = (void *)objc_retainAutoreleasedReturnValue(v18);</div><div class=\"line\">    if ( !v19 )</div><div class=\"line\">    &#123;</div><div class=\"line\">      v46 = v7;</div><div class=\"line\">      v20 = NSClassFromString(v9);</div><div class=\"line\">      if ( v20</div><div class=\"line\">        || (v21 = objc_msgSend(&amp;OBJC_CLASS___NSBundle, &quot;mainBundle&quot;),</div><div class=\"line\">            v22 = (void *)objc_retainAutoreleasedReturnValue(v21),</div><div class=\"line\">            v23 = objc_msgSend(v22, &quot;infoDictionary&quot;),</div><div class=\"line\">            v24 = (void *)objc_retainAutoreleasedReturnValue(v23),</div><div class=\"line\">            v25 = v24,</div><div class=\"line\">            v26 = objc_msgSend(v24, &quot;stringValueForKey:defaultValue:&quot;, CFSTR(&quot;CFBundleExecutable&quot;), &amp;stru_12864),</div><div class=\"line\">            v27 = (void *)objc_retainAutoreleasedReturnValue(v26),</div><div class=\"line\">            v28 = v27,</div><div class=\"line\">            objc_release(v25),</div><div class=\"line\">            objc_release(v22),</div><div class=\"line\">            v29 = objc_msgSend(v27, &quot;length&quot;),</div><div class=\"line\">            v17 = v9,</div><div class=\"line\">            v19 = 0,</div><div class=\"line\">            v30 = objc_msgSend(v9, &quot;length&quot;),</div><div class=\"line\">            v31 = objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;_TtC%lu%@%lu%@&quot;), v29, v27, v30, v9),</div><div class=\"line\">            v32 = objc_retainAutoreleasedReturnValue(v31),</div><div class=\"line\">            v20 = NSClassFromString(v32),</div><div class=\"line\">            objc_release(v32),</div><div class=\"line\">            objc_release(v28),</div><div class=\"line\">            v20) )</div><div class=\"line\">      &#123;</div><div class=\"line\">        v33 = objc_msgSend(&amp;OBJC_CLASS___UZModule, &quot;class&quot;);</div><div class=\"line\">        if ( (unsigned int)objc_msgSend((void *)v20, &quot;isSubclassOfClass:&quot;, v33) &amp; 0xFF )</div><div class=\"line\">        &#123;</div><div class=\"line\">          v34 = objc_msgSend((void *)v20, &quot;alloc&quot;);</div><div class=\"line\">          v19 = objc_msgSend(v34, &quot;initWithUZWebView:&quot;, v3);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      if ( !v19 )</div><div class=\"line\">      &#123;</div><div class=\"line\">        v43 = objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;ERROR: Module &apos;%@&apos; not found&quot;), v17);</div><div class=\"line\">        v44 = objc_retainAutoreleasedReturnValue(v43);</div><div class=\"line\">        objc_msgSend(v3, &quot;sendErrorEvent:&quot;, v44);</div><div class=\"line\">        NSLog(CFSTR(&quot;%@&quot;), v44);</div><div class=\"line\">        objc_release(v44);</div><div class=\"line\">        v5 = 0;</div><div class=\"line\">        v7 = v46;</div><div class=\"line\">        v38 = v48;</div><div class=\"line\">        goto LABEL_17;</div><div class=\"line\">      &#125;</div><div class=\"line\">      objc_msgSend((void *)v3-&gt;_moduleDict, &quot;setObject:forKey:&quot;, v19, v17);</div><div class=\"line\">      v7 = v46;</div><div class=\"line\">    &#125;</div><div class=\"line\">    v47 = v17;</div><div class=\"line\">    v35 = objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;%@:&quot;), v7);</div><div class=\"line\">    v36 = objc_retainAutoreleasedReturnValue(v35);</div><div class=\"line\">    v37 = NSSelectorFromString();</div><div class=\"line\">    if ( (unsigned int)objc_msgSend(v19, &quot;respondsToSelector:&quot;, v37) &amp; 0xFF )</div><div class=\"line\">    &#123;</div><div class=\"line\">      v38 = v48;</div><div class=\"line\">      if ( (unsigned int)objc_msgSend(v49, &quot;isSyncMethod&quot;) &amp; 0xFF )</div><div class=\"line\">      &#123;</div><div class=\"line\">        v39 = objc_msgSend(v19, &quot;performSelector:withObject:&quot;, v37, v48);</div><div class=\"line\">        v40 = v19;</div><div class=\"line\">        v5 = objc_retainAutoreleasedReturnValue(v39);</div><div class=\"line\">        objc_release(v36);</div><div class=\"line\">        objc_release(v40);</div><div class=\"line\">        v17 = v47;</div><div class=\"line\">LABEL_17:</div><div class=\"line\">        objc_release(v38);</div><div class=\"line\">        objc_release(v17);</div><div class=\"line\">        objc_release(v7);</div><div class=\"line\">        v4 = v49;</div><div class=\"line\">        goto LABEL_18;</div><div class=\"line\">      &#125;</div><div class=\"line\">      objc_msgSend(v19, &quot;performSelectorOnMainThread:withObject:waitUntilDone:&quot;, v37, v48, 0);</div><div class=\"line\">      v17 = v47;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">      v17 = v47;</div><div class=\"line\">      v41 = objc_msgSend(</div><div class=\"line\">              &amp;OBJC_CLASS___NSString,</div><div class=\"line\">              &quot;stringWithFormat:&quot;,</div><div class=\"line\">              CFSTR(&quot;ERROR: Method &apos;%@&apos; not defined in Module &apos;%@&apos;&quot;),</div><div class=\"line\">              v7,</div><div class=\"line\">              v47);</div><div class=\"line\">      v42 = objc_retainAutoreleasedReturnValue(v41);</div><div class=\"line\">      objc_msgSend(v3, &quot;sendErrorEvent:&quot;, v42);</div><div class=\"line\">      NSLog(CFSTR(&quot;%@&quot;), v42);</div><div class=\"line\">      objc_release(v42);</div><div class=\"line\">      v38 = v48;</div><div class=\"line\">    &#125;</div><div class=\"line\">    objc_release(v36);</div><div class=\"line\">    objc_release(v19);</div><div class=\"line\">    v5 = 0;</div><div class=\"line\">    goto LABEL_17;</div><div class=\"line\">  &#125;</div><div class=\"line\">  v5 = 0;</div><div class=\"line\">LABEL_18:</div><div class=\"line\">  objc_release(v4);</div><div class=\"line\">  return (id)objc_autoreleaseReturnValue(v5);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要流程是从UZCommand中读出模块，方法，参数等信息，根据类名创建了实例，然后调用初始化构造函数initWithUZWebView（这里和官网介绍<a href=\"http://docs.apicloud.com/APICloud/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/module-dev-guide-for-ios\">如何自定义模块</a>中的说明是一致的）,然后会判断是同步调用还是异步调用，同步调用则直接执行<code>performSelector:withObject:</code>，异步调用执行<code>performSelectorOnMainThread:withObject:waitUntilDone:</code>，至此，完成了JS到native方法的调用。</p>\n<p>(2.2)如果使用了WKWebView，则通过发送信息的方式将调用信息发给Native端。</p>\n<p>不过，目前SuperWebView暂未支持WKWebView，没有开放api和文档出来。</p>\n<p>(2.3)uz$q和uz$r的实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//uz$q</div><div class=\"line\">&#123;c: Array[0], flag: true&#125;</div><div class=\"line\"></div><div class=\"line\">//uz$r</div><div class=\"line\">function uz$r() &#123;</div><div class=\"line\">    if(uz$q.flag &amp;&amp; uz$q.c.length&gt;0)&#123;</div><div class=\"line\">        uz$q.flag = false;</div><div class=\"line\">        window.location = &apos;uz://&apos; + uz$q.c[0];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里是将调用信息拼接成一个URL，scheme采用uz:，赋值给window.location赋值对当前页面重定向，这里应该是采用UIWebView的代理方式实现与Native端通信，会调用到<code>webView:shouldStartLoadWithRequest:navigationType:</code>代理方法中去，这种就是JSBridge的方式了。</p>\n<p>补充说明一点，从Native回调到JS端的方式是，通过<code>stringByEvaluatingJavaScriptFromString:</code>的方式，通知js端，并把callbackID作为参数回传过去。</p>\n<h3 id=\"关于SuperWebView所指的混合渲染的说明\"><a href=\"#关于SuperWebView所指的混合渲染的说明\" class=\"headerlink\" title=\"关于SuperWebView所指的混合渲染的说明\"></a>关于SuperWebView所指的混合渲染的说明</h3><p>看到混合渲染，第一理解是，SuperWebView支持将Native的View直接fix在UIWebView内部做渲染，这样做就需要修改webview的渲染机制，并且还要支持将css的解析映射到native view中去，通过官方文档和使用教程，并没有看到相关介绍。目前我的理解是，将Native的View作为子View添加到UIWebView中去。为了验证这一点，我们使用官网提供个UISlider模块来写示例代码，在JS中使用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">var uislider = api.require(&apos;UISlider&apos;);</div><div class=\"line\">            uislider.open(&#123;</div><div class=\"line\">                animation: true,</div><div class=\"line\">                orientation: &apos;horizontal&apos;,</div><div class=\"line\">                rect: &#123;</div><div class=\"line\">                    x: 10,</div><div class=\"line\">                    y: 100,</div><div class=\"line\">                    size: 300</div><div class=\"line\">                &#125;,</div><div class=\"line\">                bubble: &#123;</div><div class=\"line\">                    direction: &apos;top&apos;,</div><div class=\"line\">                    state: &apos;always&apos;,</div><div class=\"line\">                    w: 80,</div><div class=\"line\">                    h: 30,</div><div class=\"line\">                    size: 14,</div><div class=\"line\">                    color: &apos;#888&apos;,</div><div class=\"line\">                    bg: &apos;widget://res/slider/bubble.png&apos;,</div><div class=\"line\">                    prefix: &apos;温度：&apos;,</div><div class=\"line\">                    suffix: &apos;摄氏度&apos;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                handler: &#123;</div><div class=\"line\">                    w: 10,</div><div class=\"line\">                    h: 8,</div><div class=\"line\">                    bg: &apos;widget://res/slider/handler.png&apos;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                bar: &#123;</div><div class=\"line\">                    h: 4,</div><div class=\"line\">                    bg: &apos;widget://res/slider/background.png&apos;,</div><div class=\"line\">                    active: &apos;widget://res/slider/bar-active.png&apos;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                value: &#123;</div><div class=\"line\">                    min: 16,</div><div class=\"line\">                    max: 32,</div><div class=\"line\">                    step: 0.5,</div><div class=\"line\">                    init: 26</div><div class=\"line\">                &#125;,</div><div class=\"line\">                fixedOn: api.frameName,</div><div class=\"line\">                fixed: false</div><div class=\"line\">            &#125;, function(ret, err) &#123;</div><div class=\"line\">                if (ret) &#123;</div><div class=\"line\">                    alert(JSON.stringify(ret));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    alert(JSON.stringify(err));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure>\n<p>打开的视图效果如下：</p>\n<p><img src=\"./superwebview3.png\" alt=\"\"></p>\n<p>我们看到UISlider是悬浮在WebView之上的，那么我们可以猜测，其是通过在native构建并添加到WebView上的，这一点可以通过反编译了UISlider的目标文件，可以看到open方法的实现里面多次调用了addSubView方法。</p>\n<p>优点：</p>\n<ul>\n<li>性能好</li>\n<li>提供方便的api进行页面组合</li>\n<li>模块化平台，让更多的人为前端工程师服务</li>\n<li>管理平台：热更新，云数据等</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>样式需要前端开发者去模拟native的样式</li>\n<li>有些系统级的动画暂不支持，如导航栏渐变动画</li>\n</ul>\n<h2 id=\"5-Runtime-amp-Native-js\"><a href=\"#5-Runtime-amp-Native-js\" class=\"headerlink\" title=\"5+Runtime &amp; Native.js\"></a>5+Runtime &amp; Native.js</h2><ul>\n<li>5+Runtime是对HTML5+规范的实现，除了支持标准HTML5外，还扩展了JavaScript对象plus，使得js可以调用各种浏览器无法实现或实现不佳的系统能力，设备能力如摄像头、陀螺仪、文件系统等，业务能力如上传下载、二维码、地图、支付、语音输入、消息推送等。编写一次，可跨平台运行。</li>\n<li>大量的手机OS的原生API无法被HTML5使用，Native.js把原生API封装成了js对象，通过js可以直接调ios和android的原生API。这部分就不再跨平台，写法分别是plus.ios和plus.android。</li>\n<li>Native.js不是一个js库，不需要下载引入到页面的script中，也不像nodejs那样有单独的运行环境，Native.js的运行环境是集成在5+runtime里的。</li>\n</ul>\n<p>使用方式：</p>\n<ul>\n<li>对于web端开发者，使用HBuilder IDE，它集成了5+Runtime和Native.js，可以创建移动项目来开发App</li>\n<li>对于Native端开发者，可以从平台下载SDK集成到项目中使用</li>\n</ul>\n<p>看到5+runtime说是<a href=\"http://weibo.com/p/1001603806548597059383\">开源</a>了,不过在<a href=\"https://github.com/dcloudio/H5P.Core\">开源项目</a>中并未找到iOS native的代码实现，其中还是以静态库的形式提供，不过在pdr.js文件中，看到了plus.tools和plus.bridge的实现，这两个实现在后文中会使用到。</p>\n<h3 id=\"Native-js通信方式实现分析\"><a href=\"#Native-js通信方式实现分析\" class=\"headerlink\" title=\"Native.js通信方式实现分析\"></a>Native.js通信方式实现分析</h3><p>下面以使用iOS中的UIAlertView为示例。</p>\n<p>iOS端使用UIAlertView的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\">//...</div><div class=\"line\">// 创建UIAlertView类的实例对象</div><div class=\"line\">UIAlertView *view = [UIAlertView alloc];</div><div class=\"line\">// 设置提示对话上的内容</div><div class=\"line\">[view initWithTitle:@&quot;自定义标题&quot; // 提示框标题</div><div class=\"line\">    message:@&quot;使用NJS的原生弹出框，可自定义弹出框的标题、按钮&quot; // 提示框上显示的内容</div><div class=\"line\">    delegate:nil // 点击提示框后的通知代理对象，nil类似js的null，意为不设置</div><div class=\"line\">    cancelButtonTitle:@&quot;确定(或者其他字符)&quot; // 提示框上取消按钮的文字</div><div class=\"line\">    otherButtonTitles:nil]; // 提示框上其它按钮的文字，设置为nil表示不显示</div><div class=\"line\">// 调用show方法显示提示对话框，在OC中使用[]语法调用对象的方法</div><div class=\"line\">[view show];</div></pre></td></tr></table></figure>\n<p>JS端使用UIAlertView的方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建UIAlertView类的实例对象</div><div class=\"line\">var view = new UIAlertView();</div><div class=\"line\">// 设置提示对话上的内容</div><div class=\"line\">view.initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles(&quot;自定义标题&quot; // 提示框标题</div><div class=\"line\">\t, &quot;使用NJS的原生弹出框，可自定义弹出框的标题、按钮&quot; // 提示框上显示的内容</div><div class=\"line\">\t, null // 操作提示框后的通知代理对象，暂不设置</div><div class=\"line\">\t, &quot;确定(或者其他字符)&quot; // 提示框上取消按钮的文字</div><div class=\"line\">\t, null ); // 提示框上其它按钮的文字，设置为null表示不显示</div><div class=\"line\">// 调用show方法显示提示对话框</div><div class=\"line\">view.show();</div></pre></td></tr></table></figure>\n<p>其中UIAlertView、initWithTitlemessagedelegatecancelButtonTitleotherButtonTitles和show的实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.plus.ios.UIAlertView = function(create) &#123;</div><div class=\"line\">        this.__UUID__ = window.plus.tools.UUID(&apos;JSB&apos;);</div><div class=\"line\">        this.__TYPE__ = &apos;JSBObject&apos;;</div><div class=\"line\">        var args = window.plus.ios.__Tool.process(arguments);</div><div class=\"line\">        if ( create &amp;&amp; plus.tools.IOS == plus.tools.platform ) &#123;</div><div class=\"line\">        </div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            window.plus.bridge.execSync(&apos;Invocation&apos;, &apos;__Instance&apos;, [this.__UUID__, &apos;UIAlertView&apos;, args]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">plus.ios.UIAlertView.prototype.initWithTitlemessagedelegatedefaultButtoncancelButtonotherButtons = function () &#123;</div><div class=\"line\">        var ret = null;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            var args = window.plus.ios.__Tool.process(arguments);</div><div class=\"line\">            ret = window.plus.bridge.execSync(&apos;Invocation&apos;, &apos;__exec&apos;, [this.__UUID__, &apos;initWithTitle:message:delegate:defaultButton:cancelButton:otherButtons:&apos;, args]);</div><div class=\"line\">            ret = plus.ios.__Tool.New(ret, false);</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">plus.ios.UIAlertView.prototype.show = function () &#123;</div><div class=\"line\">        var ret = null;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            var args = window.plus.ios.__Tool.process(arguments);</div><div class=\"line\">            ret = window.plus.bridge.execSync(&apos;Invocation&apos;, &apos;__exec&apos;, [this.__UUID__, &apos;show&apos;, args]);</div><div class=\"line\">            ret = plus.ios.__Tool.New(ret, false);</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>可以看到，我们创建的UIAlertView是一个JS对象，这个对象是当我们使用<code>UIAlertView = plus.ios.importClass(&quot;UIAlertView&quot;);</code>时动态创建的JS对象，与Native的UIAlertView相对应，我们称该JS对象为NJS对象。我们对NJS对象UIAlertView进行的方法调用，最终会执行<code>window.plus.bridge.execSync</code>，我们需要看下它的实现，在此之前，关于通过NJS对象访问Native对象，先做一些说明。</p>\n<ul>\n<li>首次导入Native类对象时，Native.js会动态创建一个JS对象与之相对应，JS对象包括相应的构造函数、方法、父类(prototype)等信息。</li>\n<li>由于是动态创建对应的JS对象，这里有一定的性能损耗，<a href=\"http://ask.dcloud.net.cn/docs/#http://ask.dcloud.net.cn/article/88\">官方文档</a>中性能优化一节建议页面打开后触发的“plusready”事件中进行类对象的导入操作，这样提前导入了我们需要导入的类对象，是我们在后面逻辑中使用时保证其已经导入，这种方式只是将导入时机提前，并不是消除了导入带来的损耗。所以官方也不建议我们在一个页面中导入过多的类对象，这样会影响性能。</li>\n<li>数据类型转换：在NJS中调用Native API或从Native API返回数据到NJS时会自动转换数据类型。</li>\n<li>Native类对象的方法会在JS对象中有份映射，方法名是native方法名去掉‘冒号’之后的名称（字母大小写不变）。</li>\n<li>对于映射的JS对象，可以通过“.”调用方式来访问native对象的属性，但这种方式获得的值是Native层对象被映射为NJS对象那一刻的属性值，如果需要实时获取和设置native对象属性值，需要使用plusGetAttribute和plusSetAttribute方法，但这种方式效率比较低。</li>\n<li>Objective-C和Java中类如果存在继承自基类，在NJS中对应的对象会根据继承关系递归将所有基类的公有方法一一换成NJS对象的方法，所有基类的公有属性也可以通过其plusGetAttribute、plusSetAttribute方法访问。</li>\n<li>由于Objective-C中类没有静态变量，而是通过定义全局变量来实现，目前NJS中无法访问全局变量的值。对于全局常量，在NJS中也无法访问。</li>\n</ul>\n<p>继续之前的window.plus.bridge.execSync方法调用，其方法实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function (service,action,args,fn)&#123;</div><div class=\"line\">    var json,sync,ret;</div><div class=\"line\">    if(T.IOS==T.platform)&#123;</div><div class=\"line\">        try&#123;</div><div class=\"line\">            if(json=T.stringify([[window.__HtMl_Id__,service,action,null,args]]),</div><div class=\"line\">                sync=B.synExecXhr,</div><div class=\"line\">                sync.open(&quot;post&quot;,&quot;http://localhost:13131/cmds&quot;,!1),</div><div class=\"line\">                sync.setRequestHeader(&quot;Content-Type&quot;,&quot;multipart/form-data&quot;),</div><div class=\"line\">                sync.send(json),</div><div class=\"line\">                fn)</div><div class=\"line\">                return fn(sync.responseText)</div><div class=\"line\">        &#125;catch(e)&#123;</div><div class=\"line\">            console.log(&quot;sf:&quot;+action+&quot;-&quot;+service)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return window.eval(sync.responseText)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return T.ANDROID==T.platform?</div><div class=\"line\">        (ret=window.prompt(T.stringify(args),&quot;pdr:&quot;+T.stringify([service,action,!1])),fn?fn(ret):eval(ret))</div><div class=\"line\">        :void 0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">T=plus.tools,</div><div class=\"line\">B=plus.bridge</div></pre></td></tr></table></figure>\n<p>synExecXhr的全称是“同步调用XML HTTP Request”，前面我们提到了plus.bridge的实现中我们可以看到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">synExecXhr: new XMLHttpRequest()</div></pre></td></tr></table></figure>\n<p>可以看到，synExecXh实际是一个XMLHttpRequest对象，通过它最后将调用信息以http请求的方式发出去。我们在Native端利用oc-runtime hook住UIAlertView的构造函数，添加断点，可以看到调用栈如下图所示：</p>\n<p><img src=\"5+.png\" alt=\"\"></p>\n<p>可以看到，JS调用到Native端通过DCAsycSocket以这种进程间通信的方式来实现，并且在非主线程完成。至此，我们可以得知，native.js中js与native端的通信是通过本地socket同步通信的方式完成的，完成调用之后，调用结果会以字符串的形式保存在<code>sync.responseText</code>中，js端再通过evaluate其中的字符串来得到返回结果。</p>\n<p>小结：5+runtime还是基于WebView来做事，属于hybrid流派，通过本地socket通信方式来实现JS与Native的混合调用，支持动态导入native类对象，进行实例化、方法调用、属性访问等操作，与一般的hybrid技术不同的是，不需要native工程师来提供模块或者插件来支持扩展js的能力，web工程是可以参考native的方法调用类似的方式（只需要简单的修改），实现对native对象的访问。同时5+runtime还提供了一些跨平台的通用组件，如摄像头、陀螺仪、文件系统等。使用native.js技术所需要注意的问题就是性能问题，动态导入和访问native对象以及数据类型转化需要付出一定的性能损耗代价，官方给出了一些建议来进行性能优化。另外，值得一提的是DCloud公司还用HTML5做了一套模拟Native UI的开源项目MUI，有兴趣可以参考<a href=\"https://github.com/dcloudio/mui\">这里</a>.</p>\n<p>优点：</p>\n<ul>\n<li>web端可以直接访问native的api，调用接口参考</li>\n<li><p>提供一套native样式库：MUI</p>\n<p>缺点：</p>\n</li>\n<li><p>与native交互性能有点弱</p>\n</li>\n</ul>\n<h2 id=\"Titanium\"><a href=\"#Titanium\" class=\"headerlink\" title=\"Titanium\"></a>Titanium</h2><p>Titanium:”Write in JavaScript, run native everywhere”.</p>\n<p>Titanium与PhoneGap不同，并不是基于WebView来做跨平台开发，属于JavaSciptBridge流派，关于它与PhoneGap的对比可以参考<a href=\"http://www.appcelerator.com/blog/2012/05/comparing-titanium-and-phonegap/\">这篇文章</a>。值得一提的是，Titanium的上层语言并没有采用HTML+CSS+ JavaScript，而是XML+JSON+JavaScript，这增加了一定的学习成本。</p>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><p>ReactNative:”learn once，write anywhere”.</p>\n<p>ReactNative和Titanium的思路很像，也抛弃了WebView，属于JavaSciptBridge流派。ReactNative用JavaScript编写程序，渲染的界面全部都是Natvie的。<a href=\"https://facebook.github.io/react/\">React</a>是前端的知名开发库，程序代码通过操作Virturl DOM来编写程序，React runtime负责操作和更新真正的DOM节点，而这个更新是通过diff做增量更新，这提高性能，ReactNative沿用了React的编程模型和更新模型。</p>\n<p>ReactNative的JS运行在与应用主线程独立的线程，通过异步操作与Natvie接口通信，线程模型可以参考下图：</p>\n<p><img src=\"移动端混合编程/reactnative.png\" alt=\"\"></p>\n<p>JS解释器可以运行于手机中的独立线程，也可以远程调试时运行在浏览器中，另外，I/O操作、图片解码、布局信息计算等其他一些消耗CPU的操作也可以放到独立线程中，iOS应用主线程用来操作UI控件和Native API访问，JS线程与UI主线程之间通过ReactNative桥接进行异步通信，实现JS与Objective-C之间的相互调用。</p>\n<p><img src=\"移动端混合编程/reactnative2.png\" alt=\"\"></p>\n<h3 id=\"React-Native通信机制源码分析\"><a href=\"#React-Native通信机制源码分析\" class=\"headerlink\" title=\"React Native通信机制源码分析\"></a>React Native通信机制源码分析</h3><p>源码分析基于React Native v0.23.1,不过下载了目前的最新版0.38.0调试了，实现方式大同小异。</p>\n<p>React Native 的思路就是将Native方法导出给JS用，使得用户可以用JS编写程序，而采用原生控件构建构建应用。<br>React Native 导出以模块（Module）为单位，在程序启动时，加载需要注册到js中的module，挂到js解释器的__fbBatchedBridgeConfig变量上，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;remoteModuleConfig&quot;:[</div><div class=\"line\"></div><div class=\"line\">[&quot;RCTStatusBarManager&quot;,</div><div class=\"line\">\t[&quot;getHeight&quot;,&quot;setStyle&quot;,&quot;setHidden&quot;,&quot;setNetworkActivityIndicatorVisible&quot;]],</div><div class=\"line\">[&quot;RCTSourceCode&quot;,</div><div class=\"line\">\t&#123;&quot;scriptURL&quot;:&quot;http:\\/\\/localhost:8081\\/index.ios.bundle?platform=ios&amp;dev=true&amp;hot=true&quot;&#125;,</div><div class=\"line\">\t[&quot;getScriptText&quot;],[0]]</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>React Native还在不断的迭代开发中，不同版本的实现方式可能不同，例如，在<a href=\"http://blog.cnbang.net/tech/2698/\">React Native通信机制详解</a>一文中介绍，Natvie模块的注册方式是通过在利用编译指令将需要导出的模块存储到执行文件的二进制DATA端，程序启动时再从中读取导出的模块信息，我使用的源码是v0.23.1版本，可以看到，需要bridge的模块需要使用<code>RCTRegisterModule</code>宏，其展开如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define RCT_EXPORT_MODULE(js_name) \\</div><div class=\"line\">RCT_EXTERN void RCTRegisterModule(Class); \\</div><div class=\"line\">+ (NSString *)moduleName &#123; return @#js_name; &#125; \\</div><div class=\"line\">+ (void)load &#123; RCTRegisterModule(self); &#125;</div></pre></td></tr></table></figure>\n<p>可以看到，bridge的模块在load方法中进行注册，注册的模块保存在RCTBridge.m的<code>static NSMutableArray&lt;Class&gt; *RCTModuleClasses;</code>全局静态变量中。模块中需要bridge的方法使用<code>RCT_EXPORT_METHOD</code>宏，默认情况下，使用OC方法的第一个分号之前的部分作为JS中的调用名称，例如模块ModuleName中，需要导出的方法<code>- (void)doSomething:(NSString *)aString withA:(NSInteger)a andB:(NSInteger)b</code>，需要写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomething:(NSString *)aString</div><div class=\"line\">                   withA:(NSInteger)a</div><div class=\"line\">                   andB:(NSInteger)b)</div><div class=\"line\"> &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>最终JS的调用形式是<code>NativeModules.ModuleName.doSomething</code>。</p>\n<p>应用启动时，会创建一个CADisplayLink添加到线程（真机上是JS线程，模拟器上是主线程）的runloop中，周期性的调用JS的callFunctionReturnFlushedQueue方法，这个方法的作用就是从一个MessageQueue中取出消息内容。JS调用OC方法，会将调用的信息（moduleID、methodID、params）保存在这个MessageQueue中。</p>\n<p>这里需要说明一下：测试发现，在模拟器中，JS线程与Native端使用RCTSRWebSocketExecutor来进行通信，在真机上，使用RCTJSCExecutor来执行js脚本，在RCTJSCExecutor中可以看到对它的说明<strong>Uses a JavaScriptCore context as the execution engine.</strong>。</p>\n<p>回到刚才的话题，调用callFunctionReturnFlushedQueue之后，会从MessageQueue取出调用信息，已json字符串的形式返回给native端，native端通过RCTJSONParse接口parse出调用信息，信息包括模块id,方法id,参数,以及可能的回调id，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;__NSCFArray 0x7f8bd1610e60&gt;(</div><div class=\"line\"></div><div class=\"line\">//moduleIDs</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16c4ae0&gt;(</div><div class=\"line\">56,</div><div class=\"line\">33,</div><div class=\"line\">33,</div><div class=\"line\">34</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\"></div><div class=\"line\">//methodIDs</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16f0400&gt;(</div><div class=\"line\">1,</div><div class=\"line\">5,</div><div class=\"line\">4,</div><div class=\"line\">0</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\"></div><div class=\"line\">//params</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16396c0&gt;(</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16f7d60&gt;(</div><div class=\"line\">ws://localhost:8097/devtools,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">280</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd163d350&gt;(</div><div class=\"line\">29,</div><div class=\"line\">RCTView,</div><div class=\"line\">1,</div><div class=\"line\">&lt;null&gt;</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd162e670&gt;(</div><div class=\"line\">7,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">&lt;null&gt;,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16e4c90&gt;(</div><div class=\"line\">29</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16f0d90&gt;(</div><div class=\"line\">5</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd1621a10&gt;(</div><div class=\"line\">5</div><div class=\"line\">)</div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">&lt;__NSCFArray 0x7f8bd16c7670&gt;(</div><div class=\"line\">5,</div><div class=\"line\">2,</div><div class=\"line\">3</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">)</div><div class=\"line\">,</div><div class=\"line\">//callID</div><div class=\"line\">1171</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>我们先来看下JS部分是如何创建这个队列以及将这些消息调用信息保存在队列中的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//BatchedBridge.js</div><div class=\"line\">const BatchedBridge = new MessageQueue(</div><div class=\"line\">  __fbBatchedBridgeConfig.remoteModuleConfig,</div><div class=\"line\">  __fbBatchedBridgeConfig.localModulesConfig,</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>前面提到过<strong>fbBatchedBridgeConfig.remoteModuleConfig是Native端注册的模块，</strong>fbBatchedBridgeConfig.localModulesConfig是JS本地模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//MessageQueue.js</div><div class=\"line\">constructor(remoteModules, localModules) &#123;</div><div class=\"line\">    this.RemoteModules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">    this._callableModules = &#123;&#125;;</div><div class=\"line\">    this._queue = [[], [], [], 0];</div><div class=\"line\">    this._moduleTable = &#123;&#125;;</div><div class=\"line\">    this._methodTable = &#123;&#125;;</div><div class=\"line\">    this._callbacks = [];</div><div class=\"line\">    this._callbackID = 0;</div><div class=\"line\">    this._callID = 0;</div><div class=\"line\">    this._lastFlush = 0;</div><div class=\"line\">    this._eventLoopStartTime = new Date().getTime();</div><div class=\"line\"></div><div class=\"line\">    [</div><div class=\"line\">      &apos;invokeCallbackAndReturnFlushedQueue&apos;,</div><div class=\"line\">      &apos;callFunctionReturnFlushedQueue&apos;,</div><div class=\"line\">      &apos;flushedQueue&apos;,</div><div class=\"line\">    ].forEach((fn) =&gt; this[fn] = this[fn].bind(this));</div><div class=\"line\"></div><div class=\"line\">    let modulesConfig = this._genModulesConfig(remoteModules);</div><div class=\"line\">    </div><div class=\"line\">    //构建模块信息</div><div class=\"line\">    this._genModules(modulesConfig);</div><div class=\"line\">    localModules &amp;&amp; this._genLookupTables(</div><div class=\"line\">      this._genModulesConfig(localModules),this._moduleTable, this._methodTable</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    this._debugInfo = &#123;&#125;;</div><div class=\"line\">    this._remoteModuleTable = &#123;&#125;;</div><div class=\"line\">    this._remoteMethodTable = &#123;&#125;;</div><div class=\"line\">    this._genLookupTables(</div><div class=\"line\">      modulesConfig, this._remoteModuleTable, this._remoteMethodTable</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>里面调用this._genModules(modulesConfig);，最后会调到_genModule。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//config是module信息，包括模块名，导出方法名列表等，moduleID模块对应的id（这个ID就是模块在remoteModules数组中的索引）</div><div class=\"line\">_genModule(config, moduleID) &#123;</div><div class=\"line\">    if (!config) &#123;</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let moduleName, constants, methods, asyncMethods;</div><div class=\"line\">    if (moduleHasConstants(config)) &#123;</div><div class=\"line\">      [moduleName, constants, methods, asyncMethods] = config;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      [moduleName, methods, asyncMethods] = config;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let module = &#123;&#125;;</div><div class=\"line\">    methods &amp;&amp; methods.forEach((methodName, methodID) =&gt; &#123;</div><div class=\"line\">      const methodType =</div><div class=\"line\">        asyncMethods &amp;&amp; arrayContains(asyncMethods, methodID) ?</div><div class=\"line\">          MethodTypes.remoteAsync : MethodTypes.remote;</div><div class=\"line\">      //构建方法信息</div><div class=\"line\">      module[methodName] = this._genMethod(moduleID, methodID, methodType);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    Object.assign(module, constants);</div><div class=\"line\"></div><div class=\"line\">    if (!constants &amp;&amp; !methods &amp;&amp; !asyncMethods) &#123;</div><div class=\"line\">      module.moduleID = moduleID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//构建的module信息保存在RemoteModules中</div><div class=\"line\">    this.RemoteModules[moduleName] = module;</div><div class=\"line\">    return module;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>调用this._genMethod构建方法信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">//module：模块ID,method：方法ID（是方法在方法名列表中的索引），type：&quot;remote，remoteAsync&quot;，区分是同步调用还是异步调用，异步调用用Promise实现</div><div class=\"line\">  _genMethod(module, method, type) &#123;</div><div class=\"line\">    let fn = null;</div><div class=\"line\">    let self = this;</div><div class=\"line\">    if (type === MethodTypes.remoteAsync) &#123;</div><div class=\"line\">      fn = function(...args) &#123;</div><div class=\"line\">        return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">          self.__nativeCall(</div><div class=\"line\">            module,</div><div class=\"line\">            method,</div><div class=\"line\">            args,</div><div class=\"line\">            (data) =&gt; &#123;</div><div class=\"line\">              resolve(data);</div><div class=\"line\">            &#125;,</div><div class=\"line\">            (errorData) =&gt; &#123;</div><div class=\"line\">              var error = createErrorFromErrorData(errorData);</div><div class=\"line\">              reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      fn = function(...args) &#123;</div><div class=\"line\">        let lastArg = args.length &gt; 0 ? args[args.length - 1] : null;</div><div class=\"line\">        let secondLastArg = args.length &gt; 1 ? args[args.length - 2] : null;</div><div class=\"line\">        let hasSuccCB = typeof lastArg === &apos;function&apos;;</div><div class=\"line\">        let hasErrorCB = typeof secondLastArg === &apos;function&apos;;</div><div class=\"line\">        hasErrorCB &amp;&amp; invariant(</div><div class=\"line\">          hasSuccCB,</div><div class=\"line\">          &apos;Cannot have a non-function arg after a function arg.&apos;</div><div class=\"line\">        );</div><div class=\"line\">        let numCBs = hasSuccCB + hasErrorCB;</div><div class=\"line\">        let onSucc = hasSuccCB ? lastArg : null;</div><div class=\"line\">        let onFail = hasErrorCB ? secondLastArg : null;</div><div class=\"line\">        args = args.slice(0, args.length - numCBs);</div><div class=\"line\">        return self.__nativeCall(module, method, args, onFail, onSucc);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    fn.type = type;</div><div class=\"line\">    return fn;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这里我们可以看到，__nativeCall的调用被包装在一个function中，这个function作为first-classed Value被返回，已<key,value>的形式保存在module信息中。我们开看到，native调用的成功和失败回调函数也是在这里传入。</p>\n<p>至此，Native方法的调用映射表构建完成。下面是JS端网络接口的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var RCTNetworkingNative = require(&apos;NativeModules&apos;).Networking;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * This class is a wrapper around the native RCTNetworking module.</div><div class=\"line\"> */</div><div class=\"line\">class RCTNetworking &#123;</div><div class=\"line\"></div><div class=\"line\">  static sendRequest(query, callback) &#123;</div><div class=\"line\">    RCTNetworkingNative.sendRequest(query, callback);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  static abortRequest(requestId) &#123;</div><div class=\"line\">    RCTNetworkingNative.cancelRequest(requestId);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">module.exports = RCTNetworking;</div></pre></td></tr></table></figure>\n<p>可以看到，RCTNetworking最终调用的是Native映射表中的本地方法。</p>\n<p>我们继续来看__nativeCall的实现，这里很重要。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __nativeCall(module, method, params, onFail, onSucc) &#123;</div><div class=\"line\"> </div><div class=\"line\"> \t//(1)</div><div class=\"line\">   if (onFail || onSucc) &#123;</div><div class=\"line\">     // eventually delete old debug info</div><div class=\"line\">     (this._callbackID &gt; (1 &lt;&lt; 5)) &amp;&amp;</div><div class=\"line\">       (this._debugInfo[this._callbackID &gt;&gt; 5] = null);</div><div class=\"line\"></div><div class=\"line\">     this._debugInfo[this._callbackID &gt;&gt; 1] = [module, method];</div><div class=\"line\">     onFail &amp;&amp; params.push(this._callbackID);</div><div class=\"line\">     this._callbacks[this._callbackID++] = onFail;</div><div class=\"line\">     onSucc &amp;&amp; params.push(this._callbackID);</div><div class=\"line\">     this._callbacks[this._callbackID++] = onSucc;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   global.nativeTraceBeginAsyncFlow &amp;&amp;</div><div class=\"line\">     global.nativeTraceBeginAsyncFlow(TRACE_TAG_REACT_APPS, &apos;native&apos;, this._callID);</div><div class=\"line\">   this._callID++;</div><div class=\"line\"></div><div class=\"line\">//（2）</div><div class=\"line\">   this._queue[MODULE_IDS].push(module);</div><div class=\"line\">   this._queue[METHOD_IDS].push(method);</div><div class=\"line\">   this._queue[PARAMS].push(params);</div><div class=\"line\"></div><div class=\"line\">//(3)</div><div class=\"line\">   var now = new Date().getTime();</div><div class=\"line\">   if (global.nativeFlushQueueImmediate &amp;&amp;</div><div class=\"line\">       now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123;</div><div class=\"line\">     global.nativeFlushQueueImmediate(this._queue);</div><div class=\"line\">     this._queue = [[], [], [], this._callID];</div><div class=\"line\">     this._lastFlush = now;</div><div class=\"line\">   &#125;</div><div class=\"line\">   Systrace.counterEvent(&apos;pending_js_to_native_queue&apos;, this._queue[0].length);</div><div class=\"line\">   if (__DEV__ &amp;&amp; SPY_MODE &amp;&amp; isFinite(module)) &#123;</div><div class=\"line\">     console.log(&apos;JS-&gt;N : &apos; + this._remoteModuleTable[module] + &apos;.&apos; +</div><div class=\"line\">       this._remoteMethodTable[module][method] + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>代码说明：<br>（1）往params中添加回调回调方法对应的id，可以看到，回调id保存在params数组最后，还会记录debug信息。<br>（2）将native调用信息添加到MessageQueue，可以看到，MessageQueue的格式是<code>this._queue = [[], [], [], this._callID];</code>，moduleID、methodID和params分别被加入到MessageQueue中不同数组中，所以就看到了前面我们打印出来的Native端收到的数据格式。<br>（3）如果是要求立即调用并且超时，则会调用global.nativeFlushQueueImmediate接口。这里我查找了下代码，js端和native端并没有为global.nativeFlushQueueImmediate，可见一般不会进入这个流程，一般还是使用前面介绍的Native定时驱动的方式来获取MessageQueue中的调用信息。但是，既然有这个值，说明是支持js主动调用到native端的，那又是如何实现的呢？</p>\n<p>在RCTJSCExecutor.m文件中的setUp方法，我们看到这样一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self addSynchronousHookWithName:@&quot;nativeFlushQueueImmediate&quot; usingBlock:^(NSArray&lt;NSArray *&gt; *calls)&#123;</div><div class=\"line\">    RCTJSCExecutor *strongSelf = weakSelf;</div><div class=\"line\">    if (!strongSelf.valid || !calls) &#123;</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    RCT_PROFILE_BEGIN_EVENT(0, @&quot;nativeFlushQueueImmediate&quot;, nil);</div><div class=\"line\">    [strongSelf-&gt;_bridge handleBuffer:calls batchEnded:NO];</div><div class=\"line\">    RCT_PROFILE_END_EVENT(0, @&quot;js_call&quot;, nil);</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<p>再看addSynchronousHookWithName的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)addSynchronousHookWithName:(NSString *)name usingBlock:(id)block</div><div class=\"line\">&#123;</div><div class=\"line\">  __weak RCTJSCExecutor *weakSelf = self;</div><div class=\"line\">  [self executeBlockOnJavaScriptQueue:^&#123;</div><div class=\"line\">    weakSelf.context.context[name] = block;</div><div class=\"line\">  &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们发现，这里是将native的方法挂到js解释器的全局上下文上，这样js端就可以直接调用这些native方法。除了nativeFlushQueueImmediate以外，还有其他一些全局方法。</p>\n<p>至此，我们看到了JS端如何调用组织数据发送给Native端，那Native端拿到数据之后是如何处理的呢？</p>\n<p>我跟踪了JS调用创建UIView的过程(通过hook UIView的initWithFrame方法，加断点进行测试)，其导出的Native方法在RCTUIManager.m中，方法签名如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">createView:(nonnull NSNumber *)reactTag</div><div class=\"line\">                  viewName:(NSString *)viewName</div><div class=\"line\">                  rootTag:(__unused NSNumber *)rootTag</div><div class=\"line\">                  props:(NSDictionary *)props</div></pre></td></tr></table></figure>\n<p>创建UIView的流程如下：<br>Native端接收到数据，传给RCTBatchedBridge.m中的handleBuffer函数处理，从中解析出多组信息，每组信息包括模块id,方法id,参数,以及可能的回调id，用匿名block将每组信息包起来（这里我们取个名叫block1），放到moduleID所对应的RCTModuleData的methodQueue中异步执行，RCTModuleData是对module示例的包装，methodQueue是由module实例返回，由于iOS对UI的操作一般需要放在这线程，所以可以看到，UI相关的module的method的queue的实现返回的都是主线程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//RCTActionSheet.m</div><div class=\"line\">- (dispatch_queue_t)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  return dispatch_get_main_queue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同时，还会往methodQueue中添加匿名block（这里我们取个名叫block2）的异步操作。block1执行时，首先根据moduleID在全局表中查找到对应的Module（RCTModuleData，ModuleData的创建会根据前面提到的RCTModuleClasses中的Class一一对应创建，保存在RCTBatchedBridge.m中的<code>NSArray&lt;RCTModuleData *&gt; *_moduleDataByID;</code>中），然后再根据methodID在Module中找到相应的方法RCTBridgeMethod（RCTBridgeMethod是对native方法的封装，内部会持有一个NSInvocation），为内部的_invocation设置参数并调用。这时实际调用的就是我们导出的Natvie方法了（也就是前面的createView: viewName:rootTag:props:），他会将创建UI的操作再次封装成一个个block（这里我们取个名叫block3），放到一个集合<code>NSMutableArray&lt;dispatch_block_t&gt; *_pendingUIBlocks;</code>中，当block2执行时，会从_pendingUIBlocks中逐个取出block3并执行，从而创建出相应的Natvie UI。</p>\n<p>如果调用Natvie之后，JS端需要CallBack被调用，会将CallBackID通过参数传给Native，Native函数执行完成之后，会通过发送json字符串的形式发送给JS调用结果，其中会带上CallBackID以及此次发送消息的ID。</p>\n<p>在查看ReactNative源码之前，本以为JS与OC之前的通信是通过利用JavaScriptCore进行JSBinding这种静态绑定的方式，查看源码之后才发现不是这样。通过上面对源码的分析，可以看到，RN自己实现以一套通信模式，JS与OC之间的调用采用动态查找的方式来实现，JS和Native工作于独立的线程，线程间根据一套基于ID映射协议的方式来进行通信，这样的动态查找的方式通信成本会高一些，为什么没有用JSBinding的方式，个人理解主要有一下两点原因。</p>\n<ol>\n<li>ReactNative 的目标是跨平台，并不是所有平台都采用JavaScriptCore引擎，另外，iOS7之前 JavaScriptCore也没有开发出来。</li>\n<li>ReactNative 的 JS 代码工作在独立线程（非主线程），如果采用静态绑定的方式，无法或者很难保证对UI的操作工作在主线程。</li>\n</ol>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><p>(1)Native</p>\n<p><img src=\"移动端混合编程/p-native.gif\" alt=\"\"></p>\n<p>(2)ReactNative</p>\n<p><img src=\"移动端混合编程/p-rn.gif\" alt=\"\"></p>\n<p>性能测试采用 RN v0.38.0，测试环境：iphone6,iOS9.3.2，测试用例，点击‘GO’按钮，push(带动画)一个新页面，新页面包含一个列表，首屏展示6项，向上滑动，总共展示20项，列表使用的数据是本地数据。测试数据如下，其中</p>\n<ul>\n<li>响应时间：从点击button开始构建页面，到页面完全构建完成（viewDidAppear）的时间</li>\n<li>页面构建内存开销：从点击button开始构建页面，到页面构建完成内存的增量</li>\n<li>页面滚动之后内存开销：向下滑动，加载所有的cell之后的内存增量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">测试数据</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">页面构建内存开销(MB)</th>\n<th style=\"text-align:center\">页面滚动之后内存开销(MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">React Native</td>\n<td style=\"text-align:center\">831</td>\n<td style=\"text-align:center\">2.56</td>\n<td style=\"text-align:center\">0.50</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Native</td>\n<td style=\"text-align:center\">555</td>\n<td style=\"text-align:center\">1.29</td>\n<td style=\"text-align:center\">1.36</td>\n</tr>\n</tbody>\n</table>\n<p>从体验上点击响应的顺滑程度明显native要顺滑很多，从上面的gif图中也可以看出。另外，内存开销上RN首屏列表开销明显高于Native。这里需要补充说明：React Native的ListView并不是使用UITableView实现，而是自己采用UIView实现的，这一点可以从视图层级中看出，如下图：</p>\n<p><img src=\"移动端混合编程/reactnative-scrollview.png\" alt=\"\"></p>\n<p>ListView的缓存策略也是自己做的，从<a href=\"https://github.com/facebook/react-native/issues/499\">这里</a>得知，React Native的ListView的”Cell”每次都是重新创建，之所以这么做原因是RN认为UITableView<br>的复用存在“脏数据”的问题，而且，在现在的手机设备上，创建新的cell已经足够快。当”Cell”划出屏幕，相应的“Cell”会被从view tree上取下来，但并不会销毁，只有当内存警告或者列表项太多时，会有Cell的销毁工作，下次使用，再重新构建出来。</p>\n<p>其实，ListView在RN中无法用UITableView实现，原因是，如前面所介绍，JS对Native的调用是异步操作，而且消息派发的驱动是Native端做的，试想一下，如果采用UITableView来做，在列表页快速滚动的时候，JS端是不能立刻同步获取下一个Cell来展示的。RN现在的实现方式是用ScrollView来实现，并且会预先创建若干个Cell来用户快速滑动时，下一个Cell的展示。测试发现，对于DataSource有20个数据，首屏只能显示6个cell的情况下，Native端首屏会创建6个cell，总共会创建7个（缓速的滑动）；React Native首屏会创建17个cell（用于快速滑动展示而预创建），总共会创建20个。</p>\n<p>优点：</p>\n<ul>\n<li>JS与native的异步通信，脚本不会卡住主线程</li>\n<li>原生的控件+原生的体验</li>\n<li>热调试能力</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>JS与native的异步通信</li>\n<li>门槛较高</li>\n<li>仅面向React前端开发</li>\n</ul>\n<h2 id=\"samurai-native\"><a href=\"#samurai-native\" class=\"headerlink\" title=\"samurai-native\"></a>samurai-native</h2><p>samurai-native的思路跟ReactNatvie的思路是一样的，也是将native的接口导给web端使用，而界面的渲染采用natvie控件，它与RN区别主要有两点：</p>\n<p>(1)表达语法是HTML+CSS;</p>\n<p>(2)标签名称与Native的View的名称对应，RN中由于对标签进行了抽象，有些标签与Native类名称上并不能对应，React Native书写一个tableview cell如下，可以看出，和原生的写法的命名有差异。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;TouchableHighlight onPress=&#123;() =&gt; this.rowPressed(rowData.guid)&#125;</div><div class=\"line\">                underlayColor=&apos;#dddddd&apos;&gt;</div><div class=\"line\">              &lt;View&gt;</div><div class=\"line\">                &lt;View style=&#123;styles.rowContainer&#125;&gt;</div><div class=\"line\">                  &lt;Image style=&#123;styles.thumb&#125; source=&#123;&#123; uri: rowData.img_url &#125;&#125; /&gt;</div><div class=\"line\">                  &lt;View  style=&#123;styles.textContainer&#125;&gt;</div><div class=\"line\">                    &lt;Text style=&#123;styles.price&#125;&gt;£&#123;price&#125;&lt;/Text&gt;</div><div class=\"line\">                    &lt;Text style=&#123;styles.title&#125;</div><div class=\"line\">                          numberOfLines=&#123;1&#125;&gt;&#123;rowData.title&#125;&lt;/Text&gt;</div><div class=\"line\">                  &lt;/View&gt;</div><div class=\"line\">                &lt;/View&gt;</div><div class=\"line\">                &lt;View style=&#123;styles.separator&#125;/&gt;</div><div class=\"line\">              &lt;/View&gt;</div><div class=\"line\">            &lt;/TouchableHighlight&gt;</div></pre></td></tr></table></figure>\n<p>关于samurai-native的介绍可以参考他在infoq上的<a href=\"http://www.infoq.com/cn/presentations/semi-hybrid-app-framework\">演讲</a>。</p>"}],"PostAsset":[{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRequest.png","slug":"NAPMRequest.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/cordova.png","slug":"cordova.png","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview3.png","slug":"superwebview3.png","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMUITrace.png","slug":"NAPMUITrace.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/reactnative.png","slug":"reactnative.png","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/p-rn.gif","slug":"p-rn.gif","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/android/Android Js引擎/Android平台上的JavaScript引擎/android_shape.png","post":"cixk0c24o000h7ekkw1v0m0vu","slug":"android_shape.png","modified":1,"renderable":1},{"_id":"source/_posts/android/Android Js引擎/Android平台上的JavaScript引擎/web_shape.png","post":"cixk0c24o000h7ekkw1v0m0vu","slug":"web_shape.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/5+.png","post":"cixk0c24q000k7ekkq0t492es","slug":"5+.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/p-native.gif","slug":"p-native.gif","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/reactnative-scrollview.png","slug":"reactnative-scrollview.png","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/reactnative2.png","post":"cixk0c24q000k7ekkq0t492es","slug":"reactnative2.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview.gif","slug":"superwebview.gif","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview.png","post":"cixk0c24q000k7ekkq0t492es","slug":"superwebview.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/移动端混合编程/移动端混合编程/superwebview2.png","slug":"superwebview2.png","post":"cixk0c24q000k7ekkq0t492es","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMAOPTheory.png","slug":"NAPMAOPTheory.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCFHookConnectionFlow.png","slug":"NAPMCFHookConnectionFlow.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCFHookCreate.png","slug":"NAPMCFHookCreate.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMCopyProperty.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"NAPMCopyProperty.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMDlsymClose.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"NAPMDlsymClose.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMErrorPropertyForKey.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"NAPMErrorPropertyForKey.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMFindSymbolIMPLocation.png","slug":"NAPMFindSymbolIMPLocation.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRequestSearch.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"NAPMRequestSearch.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMRightPropertyForKey.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"NAPMRightPropertyForKey.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMStruct.png","slug":"NAPMStruct.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMStructDesign.png","slug":"NAPMStructDesign.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMURLConnectionHook.png","slug":"NAPMURLConnectionHook.png","post":"cixk0c24p000i7ekk8k6xy4sf","modified":1,"renderable":0},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/NAPMUseSample.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"NAPMUseSample.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/Objective-CAOP.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"Objective-CAOP.png","modified":1,"renderable":1},{"_id":"source/_posts/ios/NeteaseAPM iOS SDK技术实现/NeteaseAPM iOS SDK技术实现/ProxyDelegateInvocation.png","post":"cixk0c24p000i7ekk8k6xy4sf","slug":"ProxyDelegateInvocation.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cixk0c23f00007ekkb4wnz5p0","category_id":"cixk0c23q00027ekkubvck7pk","_id":"cixk0c24400077ekk3pzp7f7q"},{"post_id":"cixk0c23m00017ekkpdfmd2pn","category_id":"cixk0c23q00027ekkubvck7pk","_id":"cixk0c246000b7ekkywjflkh1"},{"post_id":"cixk0c23x00047ekk4zbz5w17","category_id":"cixk0c24400087ekk566a4s3e","_id":"cixk0c246000f7ekk7urkv3z5"},{"post_id":"cixk0c24o000h7ekkw1v0m0vu","category_id":"cixk0c23q00027ekkubvck7pk","_id":"cixk0c24x000l7ekkf3sbcww0"},{"post_id":"cixk0c24p000i7ekk8k6xy4sf","category_id":"cixk0c24400087ekk566a4s3e","_id":"cixk0c251000m7ekkwd0mp2gz"},{"post_id":"cixk0c24q000k7ekkq0t492es","category_id":"cixk0c24400087ekk566a4s3e","_id":"cixk0c255000o7ekkjct5rjwe"}],"PostTag":[{"post_id":"cixk0c23f00007ekkb4wnz5p0","tag_id":"cixk0c23w00037ekku0noqw4g","_id":"cixk0c246000a7ekkg59g9fj1"},{"post_id":"cixk0c23f00007ekkb4wnz5p0","tag_id":"cixk0c23z00067ekk8gkxxmqi","_id":"cixk0c246000c7ekk9kl8r9vx"},{"post_id":"cixk0c23m00017ekkpdfmd2pn","tag_id":"cixk0c24500097ekkj591m1zl","_id":"cixk0c246000e7ekkg4y6es45"},{"post_id":"cixk0c23x00047ekk4zbz5w17","tag_id":"cixk0c246000d7ekk77wx42er","_id":"cixk0c246000g7ekkzgwurdqz"},{"post_id":"cixk0c24o000h7ekkw1v0m0vu","tag_id":"cixk0c24p000j7ekkyujiitrg","_id":"cixk0c255000p7ekk0jtisf6z"},{"post_id":"cixk0c24p000i7ekk8k6xy4sf","tag_id":"cixk0c253000n7ekkmbrttig3","_id":"cixk0c256000r7ekktdknd4yp"},{"post_id":"cixk0c24q000k7ekkq0t492es","tag_id":"cixk0c256000q7ekkub7ew73v","_id":"cixk0c257000s7ekkwpejsynl"}],"Tag":[{"name":"Jenkins","_id":"cixk0c23w00037ekku0noqw4g"},{"name":"ci容器","_id":"cixk0c23z00067ekk8gkxxmqi"},{"name":"android工程模板","_id":"cixk0c24500097ekkj591m1zl"},{"name":"LLVM","_id":"cixk0c246000d7ekk77wx42er"},{"name":"Js引擎","_id":"cixk0c24p000j7ekkyujiitrg"},{"name":"NeteaseAPM","_id":"cixk0c253000n7ekkmbrttig3"},{"name":"混合开发框架","_id":"cixk0c256000q7ekkub7ew73v"}]}}